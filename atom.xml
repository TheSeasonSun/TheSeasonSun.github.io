<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TheSeasonSun</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-15T09:56:05.693Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TheSeasonSun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何利用主键索引提高效率</title>
    <link href="http://example.com/2022/08/09/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/"/>
    <id>http://example.com/2022/08/09/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/</id>
    <published>2022-08-09T08:49:41.000Z</published>
    <updated>2022-08-15T09:56:05.693Z</updated>
    
    <content type="html"><![CDATA[<p>通过本文你可以了解B+树索引的数据结构，计算机系统的内存预读机制，以及不同种类主键对B+树索引的影响从而了解如何利用主键索引提高索引效率。</p><span id="more"></span><h2 id="情景与解决方案"><a href="#情景与解决方案" class="headerlink" title="情景与解决方案"></a>情景与解决方案</h2><p>我曾经用SpringBoot与Vue写过一个管理电子书的项目，可以对电子书进行增删改查，主键使用uuid。在初步完成这个项目后，我造了一部分数据去测试系统效率，发现效率并不快，尤其在增加与删除数据时。</p><p>而这个效率慢与主键索引有关，这要从MySQL的数据结构说起：</p><p>MySQL有多个存储引擎，每种引擎各有特点，从索引角度来说如下：</p><table><thead><tr><th>存储引擎</th><th>索引</th></tr></thead><tbody><tr><td>memory</td><td>hash</td></tr><tr><td>InnoDB</td><td>B+树</td></tr><tr><td>MyISAM</td><td>B+树</td></tr></tbody></table><p>更详细的在我这篇文章：<a href="http://theseasonsun.cn/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/">MySQL索引数据结构浅聊 | TheSeasonSun</a></p><p>现在最常用的是InnoDB，它的索引为B+树，数据结构如下图：</p><p><img src="/2022/08/09/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87/image-20220325093749585.png" alt="B+树数据结构"></p><p>注意：在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。<strong>因此B+Tree 支持两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</strong></p><p>当MySQL借助索引查找某个数据时，现在B+树根节点进行二分查找，找到所查找项对应区间的结点之后继续递归的查找，直到在叶子节点找出Key所对应的data。我们可以发现B+树整个数据结构是有序的，正因如此，<strong>插入操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性</strong>。这也是索引共同的缺点。</p><p>那么效率低下的问题我们就可以明白了：<strong>uuid是无序的</strong></p><p>现在想要提高效率，只能将主键改为自增主键</p><p><em><strong>B+树为了维护索引的有序性，在新插入值时会做必要的维护，常常需要逻辑上挪动后面的数据以腾出位置。这时候会导致页分裂与页合并，插入效率和空间利用率都不高</strong></em></p><p>在当时也曾考虑过加一个自增属性作为Key来创建索引，这种方法或许可以提高查找数据的效率，但本身并不能解决插入效率低的问题，因为在插入数据时依然会维护主键索引，同时多加一个索引消耗的内存是巨大的。而且平时使用主键查找数据时，也可避免回表查询。最后敲定使用雪花算法作为主键（虽然项目只是单体架构）。</p><h2 id="怎么选择索引的Key？"><a href="#怎么选择索引的Key？" class="headerlink" title="怎么选择索引的Key？"></a>怎么选择索引的Key？</h2><p>对于这个问题，人们的回答众说纷纭，有的人说要<strong>易于比较</strong>，因为索引查找数据时会把目标Key与B+树上的Key不断比对，所以Key越容易比较，查找效率就越高。有的人说要<strong>节省空间</strong>，因为索引占用空间与数据相比是巨大的。</p><p>我的看法是要根据实际情况决定，以上不论是哪种情况，都是在索引不会有过多改动的前提下的，不然就会出现我上文遇到的插入效率低的问题。当然这都是在目前最常见的B+树索引的情况下</p><h2 id="为什么B-树最常用？"><a href="#为什么B-树最常用？" class="headerlink" title="为什么B+树最常用？"></a>为什么B+树最常用？</h2><p>因为B+树与其他索引相比，能在占用内存相同的情况下做到效率最高，主要原因从数据结构上来说有一下两点：</p><ol><li><strong>B+ 树有更低的树高</strong></li><li><strong>B+ 树迎合了磁盘预读特性</strong></li></ol><p>详情可以看另一篇文章：<a href="http://theseasonsun.cn/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/">MySQL索引数据结构浅聊 | TheSeasonSun</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过本文你可以了解B+树索引的数据结构，计算机系统的内存预读机制，以及不同种类主键对B+树索引的影响从而了解如何利用主键索引提高索引效率。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    <category term="解决方案" scheme="http://example.com/categories/MySQL/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>高并发时为什么是四层负载均衡？</title>
    <link href="http://example.com/2022/08/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F/"/>
    <id>http://example.com/2022/08/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F/</id>
    <published>2022-08-07T10:45:36.000Z</published>
    <updated>2022-08-07T10:50:33.363Z</updated>
    
    <content type="html"><![CDATA[<p>在说明负载均衡模型之前应该先说以下前置知识：网络</p><span id="more"></span><p>我们都知道网络通信时网络模型，以5层模型为例，如图：</p><p><img src="/2022/08/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F/image-20220807175358147.png" alt="image-20220807175358147"></p><p>客户端发起通信的过程大致可以简略描述为以下步骤：</p><p>客户端<strong>应用层</strong>某个进程向服务端发起通信时，所发出的信息会携带该进程的<strong>端口号</strong>（通信时端口号为某个进程的具体标识），向下传递给<strong>传输控制层</strong>的<strong>TCP</strong>协议封装成报文，TCP协议再向下传输给<strong>网络层</strong>的<strong>IP协议</strong>组成报文，之后再向下在<strong>数据链路层</strong>组成<strong>MAC</strong>报文，最后交给物理层传输向其他设备。</p><p>最后的报文简单来说如下：</p><p><img src="/2022/08/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F/image-20220807180857667.png" alt="image-20220807180857667"></p><p>那么目标服务器的各个地址是如何得知的呢？</p><p>IP地址是由DNS域名向浏览器缓存，操作系统缓存等等地方解析而来的。</p><p>MAC地址是由已知的IP地址通过ARP协议广播得到的。<strong>注意MAC地址并非是目标服务器的MAC地址，而是去往目标服务器的道路上的下一个设备。</strong></p><p>报文正是这样通过MAC地址传递到一个一个设备，最后到达服务器的。所以我们可以看到路由器和交换机都有数据链路层，因为报文需要在数据链路层来提取并再封装为新的MAC报文以传递到下一个设备。</p><p>在高并发情况下，多个请求涌向服务器会使服务器不堪重负，效率很慢，这种情况的解决方案也很朴实：多设几个服务器，那么怎么向多个服务器分发请求就是应该关注的问题了。</p><p><strong>计算机领域中的任何问题，都可以通过在两层之间增加一个中间层去解决</strong>，分发请求我们可以通过在客户端与服务器之间加一个中间层去实现。那么中间层该是怎么样的呢？</p><p>在通信中，比较耗费时间的地方有两处：运输层的建立连接（三次握手）与应用层向下传输数据（操作系统用户态调用内核态）</p><p>。那么我们就要避免使用到运输层与应用层，但也不是单纯的路由器，我们还是希望中间层可以有运输层将各个请求分发给各个服务器，但中间件本身不建立连接。所以我们可以得到如下模型：</p><p><img src="/2022/08/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F/image-20220807183616344.png" alt="image-20220807183616344"></p><p>而这就是<strong>“四层负载均衡”</strong></p><p>在此基础上，有衍生出D-NAT模型（替换报文的IP地址），RD模型（只替换请求报文的MAC地址，服务器响应报文直接传回客户端），TUN隧道模型（创建一个新的报文携带客户端发来的请求报文，发向服务器）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在说明负载均衡模型之前应该先说以下前置知识：网络&lt;/p&gt;</summary>
    
    
    
    <category term="高并发" scheme="http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    <category term="解决方案" scheme="http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="高并发" scheme="http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL调优之索引匹配方式与优化细节</title>
    <link href="http://example.com/2022/05/29/MySQL%E8%B0%83%E4%BC%98%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82/"/>
    <id>http://example.com/2022/05/29/MySQL%E8%B0%83%E4%BC%98%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82/</id>
    <published>2022-05-29T08:34:53.000Z</published>
    <updated>2022-05-29T08:45:58.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引匹配方式"><a href="#索引匹配方式" class="headerlink" title="索引匹配方式"></a>索引匹配方式</h2><p>下面举例皆在索引 idx（name，age，pos）建立前提下</p><span id="more"></span><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>全值匹配指的是和索引中的所有列进行匹配</p><h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>只匹配前面的几列</p><h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>可以匹配某一列的值的开头部分</p><p>比如：select * from staffs where name like ‘J%’;<br>这个语句可以利用到用name建立的索引进行查找。但是如果是 select * from staffs where name like ‘%J%’;就无法用到。</p><h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p>可以查找某一个范围的数据</p><p>比如：explain select * from staffs where name &gt; ‘Mary’;</p><h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>可以查询第一列的全部和第二列的部分</p><p>比如：explain select * from staffs where name = ‘July’ and age &gt; 25;</p><h3 id="只访问索引的查询"><a href="#只访问索引的查询" class="headerlink" title="只访问索引的查询"></a>只访问索引的查询</h3><p>查询的时候只需要访问索引，不需要访问数据行，本质上就是覆盖索引</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引是memory存储引擎使用的索引，memory的数据文件存储在内存中，这是它效率很高的原因，但正因如此memory不支持持久化，数据易丢失。</p><p>特点：</p><ul><li>哈希索引基于哈希表的实现，只有精确匹配索引所有列的查询才有效（不只是范围查询）</li><li>在mysql中，只有memory的存储引擎显式支持哈希索引</li><li>哈希索引自身只需存储对应的hash值，所以索引的结构十分紧凑，这让哈希索引查找的速度非常快</li></ul><p>限制/缺点：</p><ul><li>哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引中的值来避免读取行</li><li>哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序</li><li>哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值</li><li>哈希索引支持等值比较查询，但不支持任何范围查询</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行</li><li>哈希冲突比较多的话，维护的代价也会很高</li></ul><h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>当包含多个列作为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要</p><p>案例：</p><p><img src="/2022/05/29/MySQL%E8%B0%83%E4%BC%98%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82/image-20220330210521713.png" alt="image-20220330210521713"><br>注意倒数第二条语句，范围查找，后方的列不会再使用索引</p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起</p><p>优点：</p><ul><li>可以把相关数据保存在一起</li><li>数据访问更快，因为索引和数据保存在同一个树中</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li></ul><p>缺点：</p><ul><li>聚簇数据最大限度地提高了IO密集型应用的性能，如果数据全部在内存，那么聚簇索引就没有什么优势</li><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式（因此建议使用自增主键，每次插入新纪录都是追加，不涉及挪动其他记录，因此效率最高（性能），非主键索引占用的空间也最小（存储空间）。）</li><li>更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置</li><li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</li></ul><p>在MySQL中，B+树为了维护索引的有序性，在新插入值时会做必要的维护，常常需要逻辑上挪动后面的数据以腾出位置。</p><p>在挪动过程中，会出现页分裂与页合并。</p><p>页分裂：申请新的数据页，挪动部分数据从旧数据页到新数据页。</p><p>页合并：相邻两个页由于删除了数据，利用率很低之后，会将两个数据页合并。</p><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>数据文件跟索引文件分开存放</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><ul><li>如果一个索引包含所有需要查询的字段的值，我们称之为覆盖索引</li><li>不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值</li><li>不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引，memory不支持覆盖索引</li></ul><p>优点：</p><ol><li>索引条目通常远小于数据行大小，如果只需要读取索引，那么mysql就会极大的减少数据访问量</li><li>因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多（符合磁盘预读特性）</li><li>一些存储引擎如MYISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用，这可能会导致严重的性能问题</li><li>由于INNODB的聚簇索引，覆盖索引对INNODB表优势很大</li></ol><p><em>在执行计划中可以看到语句是否用到了覆盖索引：在explain的extra列可以看到using index的信息，此时就使用了覆盖索引，如下：</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> store_id,film_id <span class="keyword">from</span> inventory\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: inventory</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: index</span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: idx_store_id_film_id</span><br><span class="line">      key_len: <span class="number">3</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">4581</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> index</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的查询。不过，可以进一步的进行优化，可以使用innodb的二级索引来覆盖查询。</em></p><p><em>例如：actor使用innodb存储引擎，并在last_name字段又二级索引，虽然该索引的列不包括主键actor_id，但也能够用于对actor_id做覆盖查询</em></p><h2 id="索引优化细节"><a href="#索引优化细节" class="headerlink" title="索引优化细节"></a>索引优化细节</h2><ol><li><p>当使用索引列进行查询的时候尽量不要使用表达式，把计算放到业务层而不是数据库层</p></li><li><p>尽量使用主键查询，而不是其他索引，因为主键查询不会触发回表查询</p></li><li><p>当用长字段建立索引时，可使用前缀索引</p><p>有时候需要索引很长的字符串，这会让索引变的大且慢，通常情况下可以使用某个列开始的部分字符串，这样大大的节约索引空间，从而提高索引效率，但这会降低<strong>索引的选择性</strong>，索引的选择性是指不重复的索引值和数据表记录总数的比值。索引的选择性越高则查询效率越高，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。</p><p><em>比如：app，apple，apples，取前三个字符串的话，就都是app了，这种情况下索引的选择性就偏低</em></p><p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOB,TEXT,VARCHAR类型的列，必须要使用前缀索引，因为mysql不允许索引这些列的完整长度，使用该方法的诀窍在于要选择足够长的前缀以保证较高的选择性，通过又不能太长。</p></li></ol><ol start="4"><li><p>使用索引扫描来排序</p><p>mysql有两种方式可以生成有序的结果：通过排序操作或者按索引顺序扫描，如果explain出来的type列的值为index,则说明mysql使用了索引扫描来做排序</p><p>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那么就不得不每扫描一条索引记录就得回表查询一次对应的行，这基本都是随机IO，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢。</p><p>但按索引查询有诸多限制：</p><ul><li><strong>只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方式都一样时，mysql才能够使用索引来对结果进行排序</strong></li><li><strong>如果查询需要关联多张表，则只有当orderby子句引用的字段全部为第一张表时，才能使用索引做排序。</strong></li><li><strong>order by子句和查找型查询的限制是一样的，where之后的条件的列如果满足索引的最左匹配的要求的话，会用到索引排序，否则，mysql都需要执行顺序操作，而无法利用索引排序。同样如果where之后的有范围条件的话，无法用索引排序</strong></li></ul></li><li><p>union all,in,or都能够使用索引，但是推荐使用in（其实差别不大）</p></li><li><p>范围列可以用到索引<br>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列</p></li><li><p>强制类型转换会全表扫描<br>比如有索引：idx_1(phone)，phone为varchar类型<br>explain select * from user where phone=13800001234;不会报错，但也不会用到索引<br>explain select * from user where phone=’13800001234’;就可以用到索引</p></li><li><p>更新十分频繁，数据区分度不高的字段上不宜建立索引</p><ul><li><p>更新会变更B+树，更新频繁的字段建议索引会大大降低数据库性能</p></li><li><p>类似于性别这类区分不大的属性（即离散度低的数据），建立索引是没有意义的，不能有效的过滤数据</p></li><li><p>一般区分度在80%以上的时候就可以建立索引，区分度（或者说离散度）可以使用 count(distinct(列名))/count(*) 来计算</p><p><em><strong>究竟用什么字段来创建索引，必须要考虑实际情况：</strong></em><br><em><strong>比如，数据表不需要再改动也不需要再插入新数据时，当然就可以使用有序且易于比较大小的字段，查询效率会更高，但是这可能在一定程度上牺牲了空间，算是以空间换时间的方法。那么反过来，为了节省空间，我们也可以用较短或者较简单的字段去创建索引。</strong></em><br><em><strong>但是如果建立索引之后数据会频繁插入呢？插入数据时，B+树为了维护索引的有序性，在新插入值时会做必要的维护，常常需要逻辑上挪动后面的数据以腾出位置。这时候会导致页分裂与页合并，插入效率和空间利用率都不高，这个时候还是用自增主键更好，因为顺序插入不会涉及到页分裂与页合并问题。</strong></em></p></li></ul></li></ol><ol start="9"><li><p>创建索引的列，不允许为null，为null时可能会得到不符合预期的结果（根据实际情况判断）</p></li><li><p>当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致，不然在多表查询时会效率变慢。</p><p>MySQL join算法(以下部分引用自<a href="https://zhuanlan.zhihu.com/p/54275505">数据库基础（七）Mysql Join算法原理</a>)</p><ol><li>Simple Nested-Loop Join（简单的嵌套循环连接）</li></ol><p>  简单来说嵌套循环连接算法就是一个双层for 循环 ，通过循环外层表的行数据，逐个与内层表的所有行数据进行比较来获取结果，如图：</p><p>  <img src="/2022/05/29/MySQL%E8%B0%83%E4%BC%98%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82/v2-2b9d48da48c6c436283fdec14db9d174_720w.jpg" alt="img"></p><ol start="2"><li>Index Nested-Loop Join（索引嵌套循环连接）</li></ol><p>  Index Nested-Loop Join其优化的思路 主要是为了减少内层表数据的匹配次数， 简单来说Index Nested-Loop Join 就是通过外层表匹配条件 直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较， 这样极大的减少了对内层表的匹配次数，从原来的匹配次数=外层表行数 * 内层表行数,变成了 外层表的行数 * 内层表索引的高度，极大的提升了 join的性能。</p><p>  <img src="/2022/05/29/MySQL%E8%B0%83%E4%BC%98%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82/v2-e48f1be1f869c5211b76f68270a9c716_720w.jpg" alt="img">注意：使用Index Nested-Loop Join 算法的前提是匹配的字段必须建立了索引。</p><ol start="3"><li><p>Block Nested-Loop Join（缓存块嵌套循环连接）</p><p>缓存块嵌套循环连接算法意在通过一次性缓存外层表的多条数据，以此来减少内层表的扫表次数，从而达到提升性能的目的。如果无法使用Index Nested-Loop Join的时候，数据库是默认使用的是Block Nested-Loop Join算法的。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了join buffer缓冲区，将驱动表join相关的部分数据列(大小是join buffer的限制)缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了非驱动表的访问频率。</p><p>当level 表的 user_id 不为索引的时候，默认会使用Block Nested-Loop Join算法，匹配的过程类似下图：</p><p><img src="/2022/05/29/MySQL%E8%B0%83%E4%BC%98%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%8C%B9%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82/v2-0e81dd7fe538f67559bc24c0a5a3207e_720w.jpg" alt="img"></p><p>驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下join_buffer_size=256k,查询的时候Join Buffer 会缓存所有参与查询的列而不是只有join的列，在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。</p></li></ol><p><strong>Index Nested-Loop Join 是通过索引的机制减少内层表的循环匹配次数达到优化效果，而Block Nested-Loop Join 是通过一次缓存多条数据批量匹配的方式来减少外层表的IO次数,同时也减少了内层表的扫表次数，通过 理解join 的算法原理我们可以得出以下表连接查询的优化思路。</strong></p><p>注意事项：</p><ul><li>永远用小结果集驱动大结果集(其本质就是减少外层循环的数据数量)</li><li>为匹配的条件增加索引(减少内层表的循环匹配次数)</li><li>增大join buffer size的大小（一次缓存的数据越多，那么内层包的扫表次数就越少）</li><li>减少不必要的字段查询（字段越少，join buffer 所缓存的数据就越多）</li></ul></li><li><p>能使用limit的时候尽量使用limit</p></li></ol><p>索引本质上功能是限制输出，在sql调优的步骤中，其实最核心的是减少数据的IO量，因此使用limit能保证返回的数据量最少，查询效率也就因此得到提升。</p><ol start="12"><li>单表索引建议控制在5个以内</li></ol><p>主要原因是索引占用空间很大。</p><ol start="13"><li>单索引字段数不允许超过5个（组合索引）</li></ol><p>主要原因是是列太多导致占用太多的内存空间，会导致树的深度加深，降低效率。</p><ol start="14"><li><p>创建索引的时候应该避免以下错误概念：</p><ul><li>索引越多越好。</li><li>过早优化，在不了解系统的情况下进行优化。</li></ul></li></ol><h2 id="索引选择性策略"><a href="#索引选择性策略" class="headerlink" title="索引选择性策略"></a>索引选择性策略</h2><p>在InnoDB存储引擎中，每个表中可以添加多个索引，若一个SQL中涉及多个索引，只会选择最优的一个</p><p>索引的选择性的策略，选择性为某一索引列不重复的值的比例；选择性大小的公式：S = C / #T<br>S(Selectivity)为选择性，C(Cardinality)为基数，即不重复的索引值，#T为记录总数。</p><h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><p><a href="https://cloud.tencent.com/developer/article/1347079">MySQL 谈谈Memory存储引擎</a></p><p><a href="https://www.cnblogs.com/edisonchou/p/mysql_relearning_notes_part3.html#:~:text=%E5%9C%A8%E6%8C%AA%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%A1%B5%E5%88%86%E8%A3%82%E4%B8%8E%E9%A1%B5%E5%90%88%E5%B9%B6%E3%80%82,%E9%A1%B5%E5%88%86%E8%A3%82%EF%BC%9A%E7%94%B3%E8%AF%B7%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5%EF%BC%8C%E6%8C%AA%E5%8A%A8%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E4%BB%8E%E6%97%A7%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%B0%E6%96%B0%E6%95%B0%E6%8D%AE%E9%A1%B5%E3%80%82%20%E9%A1%B5%E5%90%88%E5%B9%B6%EF%BC%9A%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E9%A1%B5%E7%94%B1%E4%BA%8E%E5%88%A0%E9%99%A4%E4%BA%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%A9%E7%94%A8%E7%8E%87%E5%BE%88%E4%BD%8E%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E5%B0%86%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%90%88%E5%B9%B6%E3%80%82">MySQL核心知识学习之路 页分裂与页合并</a></p><p><a href="https://blog.csdn.net/mingyundezuoan/article/details/79038989">MySQL索引基数</a></p><p><a href="https://zhuanlan.zhihu.com/p/54275505">数据库基础（七）Mysql Join算法原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/411723794">MySQL进阶系列：join连接的原理-3种算法</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;索引匹配方式&quot;&gt;&lt;a href=&quot;#索引匹配方式&quot; class=&quot;headerlink&quot; title=&quot;索引匹配方式&quot;&gt;&lt;/a&gt;索引匹配方式&lt;/h2&gt;&lt;p&gt;下面举例皆在索引 idx（name，age，pos）建立前提下&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL调优" scheme="http://example.com/tags/MySQL%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之数据类型，范式，主键，字符集</title>
    <link href="http://example.com/2022/05/23/MySQL%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%8C%83%E5%BC%8F%EF%BC%8C%E4%B8%BB%E9%94%AE%EF%BC%8C%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    <id>http://example.com/2022/05/23/MySQL%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%8C%83%E5%BC%8F%EF%BC%8C%E4%B8%BB%E9%94%AE%EF%BC%8C%E5%AD%97%E7%AC%A6%E9%9B%86/</id>
    <published>2022-05-23T13:03:32.000Z</published>
    <updated>2022-05-23T13:08:46.568Z</updated>
    
    <content type="html"><![CDATA[<p>要在数据类型方面优化MySQL，应该先理解MySQL的各个数据类型的特点和范围</p><span id="more"></span><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th align="left">范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 Bytes</td><td>(-128，127)</td><td align="left">(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 Bytes</td><td>(-32 768，32 767)</td><td align="left">(0，65 535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 Bytes</td><td>(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 Bytes</td><td>(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 Bytes</td><td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 Bytes</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度 浮点数值</td></tr><tr><td>DOUBLE</td><td>8 Bytes</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度 浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td>小数值</td></tr></tbody></table><h3 id="日期-时间类型"><a href="#日期-时间类型" class="headerlink" title="日期/时间类型"></a>日期/时间类型</h3><table><thead><tr><th>类型</th><th>大小 ( bytes)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’/‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901/2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00/9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><h3 id="数据类型更小的通常更好"><a href="#数据类型更小的通常更好" class="headerlink" title="数据类型更小的通常更好"></a>数据类型更小的通常更好</h3><p>在建表选择字段的数据类型时，应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少，但是要确保没有低估需要存储的值的范围。</p><h3 id="在满足条件的情况下尽量选择简单的数据类型"><a href="#在满足条件的情况下尽量选择简单的数据类型" class="headerlink" title="在满足条件的情况下尽量选择简单的数据类型"></a>在满足条件的情况下尽量选择简单的数据类型</h3><p>简单数据类型的操作通常需要更少的CPU周期，例如：</p><ol><li>整型比字符操作代价更低，因为字符集和校对规则是字符比较比整型比较更复杂，</li><li>使用mysql自建类型而不是字符串来存储日期和时间</li><li>用整型存储IP地址</li></ol><h3 id="尽量避免使用null"><a href="#尽量避免使用null" class="headerlink" title="尽量避免使用null"></a>尽量避免使用null</h3><p>在MySQl中null并不等于null，而且需要额外的列来描述是否允许为null。<br>同时，如果查询中包含可为NULL的列，对mysql来说很难优化，因为可为null的列使得索引、索引统计和值比较都更加复杂。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>可以使用的几种整数类型：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。尽量使用满足需求的最小数据类型。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h3 id="字符和字符串类型"><a href="#字符和字符串类型" class="headerlink" title="字符和字符串类型"></a>字符和字符串类型</h3><p>MySQL实际应用最多的是char，varchar，text等，它们最关键的不同在于最长度的控制，长度越固定，查询效率通常越快，长度控制越松散，存储内容更灵活时查询效率就越低。</p><h4 id="char"><a href="#char" class="headerlink" title="char"></a>char</h4><p>特点：</p><ul><li>最大长度：255；长度固定，即每条数据占用等长字节空间</li><li>会自动删除末尾的空格（varchar会保留空格）</li><li>检索效率、写效率会比varchar高，以空间换时间</li></ul><p>应用场景：</p><ul><li>存储长度波动不大的数据，如：md5摘要，身份证号、手机号等定长字符串。</li><li>存储短字符串、经常更新的字符串</li></ul><h4 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h4><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>特点：</p><ul><li>往往使用最小的符合需求的长度，长度可变，可以设置最大长度。</li><li>varchar(n) n小于等于255使用额外一个字节保存长度，n&gt;255使用额外两个字节保存长度。</li><li>varchar(5)与varchar(255)保存同样的内容，硬盘存储空间相同，但内存空间占用不同，是指定的大小 。</li><li>varchar在mysql5.6之前变更长度，或者从255一下变更到255以上时时，都会导致锁表。</li></ul><p>应用场景：</p><ul><li>存储长度波动较大的数据，如：文章，有的会很短有的会很长</li><li>字符串很少更新的场景，每次更新后都会重算并使用额外存储空间保存长度</li><li>适合保存多字节字符，如：汉字，特殊字符等</li></ul><h4 id="text与BLOB"><a href="#text与BLOB" class="headerlink" title="text与BLOB"></a>text与BLOB</h4><p>text不设置长度，当不知道属性的最大长度时，适合用text，MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理。<br>两者都是为了存储很大数据而设计的字符串类型，分别采用二进制和字符方式存储。</p><h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><p>时间类型的选择要看需要的精度</p><h4 id="datatime"><a href="#datatime" class="headerlink" title="datatime"></a>datatime</h4><ul><li>占用8个字节</li><li>与时区无关，数据库底层时区配置，对datetime无效</li><li>可保存到毫秒</li><li>可保存时间范围大</li><li>不要使用字符串存储日期类型，占用空间大，损失日期类型函数的便捷性</li></ul><h4 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h4><ul><li>占用4个字节</li><li>时间范围：1970-01-01到2038-01-19</li><li>精确到秒</li><li>采用整形存储</li><li>依赖数据库设置的时区</li><li>自动更新timestamp列的值</li></ul><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><ul><li>占用的字节数比使用字符串、datetime、int存储要少，使用date类型只需要3个字节</li><li>使用date类型还可以利用日期时间函数进行日期之间的计算</li><li>date类型用于保存1000-01-01到9999-12-31之间的日期</li></ul><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>用枚举类型代替字符串类型，可以用在数据为多个但为定值的列里，比如：状态，是否，性别等</p><p>mysql存储枚举类型会非常紧凑，会根据列表值的数据压缩到一个或两个字节中，<strong>mysql在内部会将每个值在列表中的位置保存为整数</strong>，并且在表的.frm文件中保存“数字-字符串”映射关系的查找表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> create table enum_test(e enum(&#x27;fish&#x27;,&#x27;apple&#x27;,&#x27;dog&#x27;) not null);</span><br><span class="line"> //插入枚举类型</span><br><span class="line"> insert into enum_test(e) values(&#x27;fish&#x27;),(&#x27;dog&#x27;),(&#x27;apple&#x27;);</span><br><span class="line"> //直接存储的是整数，所以可以对e加减，字符与创建列时的值一一对应，比如上表‘fish’对应0，‘apple’对应1，‘dog’对应2</span><br><span class="line"> select e+0 from enum_test;</span><br></pre></td></tr></table></figure><h3 id="特殊类型数据"><a href="#特殊类型数据" class="headerlink" title="特殊类型数据"></a>特殊类型数据</h3><p>人们经常使用varchar(15)来存储ip地址，然而，它的本质是32位无符号整数不是字符串，MySQL提供了INET_ATON() 和 INET_NTOA() 函数，用于IPv4地址在整型和字符串之间的转化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select inet_aton(&#x27;1.1.1.1&#x27;)</span><br><span class="line">select inet_ntoa(16843009)</span><br></pre></td></tr></table></figure><h2 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h2><p>大家都知道数据库设计时要遵循反范式原则，这样可以尽可能的降低数据冗余，但数据之间的联系本身就需要数据冗余（例如外键），所以在实际开发中要根据我们的需求来权衡范式与反范式。</p><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>范式化的更新通常比反范式要快</li><li>当数据较好的范式化后，很少或者没有重复的数据</li><li>范式化的数据比较小，可以放在内存中，操作比较快</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>通常需要进行关联</li></ul><h3 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>所有的数据都在同一张表中，可以避免关联</li><li>可以设计有效的索引；</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>在企业中很好能做到严格意义上的范式或者反范式，一般需要混合使用：</p><p>在一个网站实例中，这个网站，允许用户发送消息，并且一些用户是付费用户。现在想查看付费用户最近的10条信息。  在user表和message表中都存储用户类型(account_type)而不用完全的反范式化。这避免了完全反范式化的插入和删除问题，因为即使没有消息的时候也绝不会丢失用户的信息。这样也不会把user_message表搞得太大，有利于高效地获取数据。</p><p>另一个从父表冗余一些数据到子表的理由是排序的需要。</p><p>缓存衍生值也是有用的。如果需要显示每个用户发了多少消息（类似论坛的），可以每次执行一个昂贵的自查询来计算并显示它；也可以在user表中建一个num_messages列，每当用户发新消息时更新这个值。（所以实际上我们要权衡时应该用count(*) 还是增加一个列 num_messages，每次去更新这个列）</p><h2 id="主键的选择"><a href="#主键的选择" class="headerlink" title="主键的选择"></a>主键的选择</h2><p>主键分为代理主键与自然主键：</p><ul><li>代理主键：与业务无关的，无意义的数字序列</li><li>自然主键：事物属性中的自然唯一标识</li></ul><p>一般推荐使用代理主键，因为它们不与业务耦合，因此更容易维护。另外，数据库里大多数表，最好是全部表，通用的键策略能够减少需要编写的源码数量，减少系统的总体拥有成本。（比如雪花算法生成ID）</p><h2 id="字符集的选择"><a href="#字符集的选择" class="headerlink" title="字符集的选择"></a>字符集的选择</h2><p>utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。Emoji表情或者某些特殊字符 = 4个字节，所以当需要存储中文时，建议使用UTF-8mb4作为字符集。</p><ol><li>纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间。</li><li>如果我们可以确定不需要存放多种语言，就没必要非得使用UTF8或者其他UNICODE字符类型，这回造成大量的存储空间浪费。</li><li>MySQL的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率。</li></ol><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎区别本质上是数据文件的组织形式的不同。</p><p>下面是MyISAM与InnoDB的对比：InnoDB中主键索引为聚簇索引，其他未非聚簇索引。</p><p><img src="/2022/05/23/MySQL%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%8C%83%E5%BC%8F%EF%BC%8C%E4%B8%BB%E9%94%AE%EF%BC%8C%E5%AD%97%E7%AC%A6%E9%9B%86/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94.png" alt="存储引擎对比"></p><h2 id="适当的数据冗余"><a href="#适当的数据冗余" class="headerlink" title="适当的数据冗余"></a>适当的数据冗余</h2><p>被<strong>频繁引用</strong>且<strong>只能通过 Join 2张(或者更多)大表的方式才能得到</strong>的独立小字段。这样的场景由于每次Join仅仅只是为了取得某个小字段的值，Join到的记录又大，会造成大量不必要的 IO，这种情况下把这些字段单独拿出来建一张表最好（即通过空间换取时间的方式来优化）。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。</p><h2 id="适当拆分"><a href="#适当拆分" class="headerlink" title="适当拆分"></a>适当拆分</h2><p>适当拆分指的不是分库分表中的垂直切分与水平切分，垂直切分指的是按照业务来进行切分，把不同业务的表放到不同服务器上，减少服务器压力；水平切分指把数据按照某一范围放到不同的物理服务器上。</p><p>当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</p><h2 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h2><p><a href="https://www.runoob.com/mysql/mysql-data-types.html">菜鸟教程 MySQL 数据类型</a></p><p><a href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">CS-Notes MySQL 数据类型 </a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;要在数据类型方面优化MySQL，应该先理解MySQL的各个数据类型的特点和范围&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引类型，优点及使用原则</title>
    <link href="http://example.com/2022/05/23/MySQL%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BC%98%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/05/23/MySQL%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BC%98%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99/</id>
    <published>2022-05-23T12:50:11.000Z</published>
    <updated>2022-05-23T13:00:51.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="逻辑分类"><a href="#逻辑分类" class="headerlink" title="逻辑分类"></a>逻辑分类</h3><h4 id="按功能分类"><a href="#按功能分类" class="headerlink" title="按功能分类"></a>按功能分类</h4><p>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL</p><span id="more"></span><p>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一</p><p>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入</p><p>全文索引：它查找的是文本中的关键词，主要用于全文检索</p><h4 id="按列数分类"><a href="#按列数分类" class="headerlink" title="按列数分类"></a>按列数分类</h4><p>单例索引：一个索引只包含一个列，一个表可以有多个单例索引</p><p>组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效</p><h3 id="物理分类"><a href="#物理分类" class="headerlink" title="物理分类"></a>物理分类</h3><p>聚簇索引：指的是数据跟对应的索引列紧凑的存储在一起的数据存储方式。</p><p>非聚簇索引：数据跟索引分开存储</p><p><strong>InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引，但是只有InnoDB的主键索引才是聚簇索引，InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。这与存储引擎的文件系统的不同有关。</strong></p><p><img src="https://img-blog.csdnimg.cn/20210130233352294.png" alt="存储引擎是基于表的，以下建立两张别使用MyISAM和InnoDB引擎的表，看看其在文件系统中对应的文件存储格式。"></p><p>存储引擎为MyISAM：</p><ul><li>*.frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li>*.MYD：MyISAM DATA，用于存储MyISAM表的数据</li><li>*.MYI：MyISAM INDEX，用于存储MyISAM表的索引相关信息</li></ul><p>存储引擎为InnoDB：</p><ul><li>*.frm：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li>*.ibd：InnoDB DATA，表数据和索引的文件。该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据</li></ul><h4 id="聚簇索引优点"><a href="#聚簇索引优点" class="headerlink" title="聚簇索引优点"></a>聚簇索引优点</h4><ul><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><h4 id="聚簇索引缺点"><a href="#聚簇索引缺点" class="headerlink" title="聚簇索引缺点"></a>聚簇索引缺点</h4><ul><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键</li><li>更新聚簇索引的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li><li>聚簇索引最大限度的提高了IO密集型应用的性能，如果数据全部在内存，聚簇索引就没有什么优势</li><li>基于聚簇索引的表插入新行，或者主键被更新导致行移动时，可能面临列分页的问题</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li></ul><h2 id="索引优点与用处"><a href="#索引优点与用处" class="headerlink" title="索引优点与用处"></a>索引优点与用处</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>减少服务器扫描的数据量</li><li>避免排序和临时表</li><li>将随机IO变为顺序IO</li></ol><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><ol><li>快速查找匹配WHERE子句的行</li><li>当有多个索引可以选择，MySQL会使用最少行的索引</li><li>如果表具有多列索引，则优化器使用索引的任何最左前缀来查找行</li><li>当有表连接时，从其他表检索行数据</li><li>查找特定索引列的min或max值，因为索引在叶子节点就是有顺序的，所以可以直接获取到极值</li><li>如果排序或分组时在可用索引的最左前缀上完成，则对表进行排序和分组。</li><li>在某些情况下，可以优化查询以检索值而无需查询数据行</li></ol><h2 id="索引使用原则"><a href="#索引使用原则" class="headerlink" title="索引使用原则"></a>索引使用原则</h2><h3 id="列的离散度"><a href="#列的离散度" class="headerlink" title="列的离散度"></a>列的离散度</h3><p>离散度 = 不同值的数量/总行数</p><p>越接近1，那么离散度越高，越接近0，离散度越低。</p><p>不建议对离散度低的列建立索引，比如性别（男，女），这种情况比起索引更建议分表</p><h3 id="组合索引最左匹配"><a href="#组合索引最左匹配" class="headerlink" title="组合索引最左匹配"></a>组合索引最左匹配</h3><p>有的时候我们的多条件查询的时候，也会建立联合索引，例如查询成绩的时候必须同时输入身份证和考号。</p><p>联合索引在 B+Tree 中是复合的数据结构，它是按照<strong>从左到右的顺序</strong>来建立搜索树的（name 在左边，phone 在右边）。</p><p><img src="/2022/05/23/MySQL%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BC%98%E7%82%B9%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99/suoy.png" alt="suoy"><br>从这张图可以看出来，name 是有序的，phone 是无序的。当 name 相等的时候，phone 才是有序的。</p><p>查询数据的时候，B+Tree 会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。如果 name相同的时候再比较 phone。但是如果查询条件没有 name，就不知道第一步应该查哪个节点，因为建立搜索树的时候 name 是第一个比较因子，所以用不到索引。</p><p>B+树的搜索与普通搜索树一样，依赖顺序，所以<strong>建立索引的字段建议是有序且易于比较大小的字段</strong>。</p><p><strong>究竟用什么字段来创建索引，必须要考虑实际情况：</strong><br><strong>比如，数据表不需要再改动也不需要再插入新数据时，当然就可以使用有序且易于比较大小的字段，查询效率会更高，但是这可能在一定程度上牺牲了空间，算是以空间换时间的方法。那么反过来，为了节省空间，我们也可以用较短或者较简单的字段去创建索引。</strong><br><strong>但是如果建立索引之后数据会频繁插入呢？插入数据时，B+树为了维护索引的有序性，在新插入值时会做必要的维护，常常需要逻辑上挪动后面的数据以腾出位置。这时候会导致页分裂与页合并，插入效率和空间利用率都不高，这个时候还是用自增主键更好，因为顺序插入不会涉及到页分裂与页合并问题。</strong></p><p>再举一个例子：<br>一个表包含id，name，age三个列，id为主键，name和age是组合索引，那么如果查询的时候有以下4句：</p><ul><li>select * from table where name = ‘zhangsan’ and age = 10;</li><li>select * from table where name = ‘zhangsan’;</li><li>select * from table where age = 10;</li><li>select * from table where age = 10 and name = ‘zhangsan’;</li></ul><p>上述4条语句中，只有第三条sql语句不会使用索引，因为没有匹配name直接匹配age是无法使用此组合索引的。第四条之所以可以使用索引是因为MySQL的优化器会对这个语句进行优化，调整成与第一句同样的效果。</p><h3 id="组合索引的使用"><a href="#组合索引的使用" class="headerlink" title="组合索引的使用"></a>组合索引的使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name on user_innodb(name); </span><br><span class="line">CREATE INDEX idx_name_phone on user_innodb(name,phone);</span><br></pre></td></tr></table></figure><p>如上建立两条索引，按照最左匹配原则，用左边的字段 name 去查询的时候，也能用到索引，所以第一个索引完全没必要。<br>同样，根据最左匹配原则，只用where phone = ？查询是用不到此索引。</p><h3 id="回表与覆盖索引"><a href="#回表与覆盖索引" class="headerlink" title="回表与覆盖索引"></a>回表与覆盖索引</h3><p>回表就是先通过数据库索引扫描出数据所在的行，再通过主键索引取出上个索引未提供的数据，即基于非主键索引的查询需要多扫描一颗索引树。<br>索引覆盖是跟回表相反的概念，在索引的叶子节点中如果能获取到查询的所有列数据，就无需回表的过程称之为索引覆盖。可以说没有回表的必要就是覆盖索引。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推指的是数据筛选的过程下移到存储引擎层来完成，而不是在server完成。（MySQL架构包含客户端，server层，存储引擎三部分）</p><p>例如：select * from table where name = ‘zhangsan’ and age = 10;<br>在索引没有下推之前，会先根据name的值将所有符合条件的数据加载到server层，再用age对数据进行筛选。<br>而使用索引下推之后，会根据name与age的结果直接从存储引擎返回所有符合条件的结果，而不是在server层。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;索引类型&quot;&gt;&lt;a href=&quot;#索引类型&quot; class=&quot;headerlink&quot; title=&quot;索引类型&quot;&gt;&lt;/a&gt;索引类型&lt;/h2&gt;&lt;h3 id=&quot;逻辑分类&quot;&gt;&lt;a href=&quot;#逻辑分类&quot; class=&quot;headerlink&quot; title=&quot;逻辑分类&quot;&gt;&lt;/a&gt;逻辑分类&lt;/h3&gt;&lt;h4 id=&quot;按功能分类&quot;&gt;&lt;a href=&quot;#按功能分类&quot; class=&quot;headerlink&quot; title=&quot;按功能分类&quot;&gt;&lt;/a&gt;按功能分类&lt;/h4&gt;&lt;p&gt;主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="MySQL索引" scheme="http://example.com/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引数据结构浅聊</title>
    <link href="http://example.com/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/"/>
    <id>http://example.com/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/</id>
    <published>2022-05-17T11:06:19.000Z</published>
    <updated>2022-05-17T12:04:04.117Z</updated>
    
    <content type="html"><![CDATA[<p>聊一下索引的底层数据结构，着重介绍现在用的比较广泛的B树与B+树。</p><span id="more"></span><h3 id="hash-表"><a href="#hash-表" class="headerlink" title="hash 表"></a>hash 表</h3><p>hash表的数据结构在此就不多赘述了，直接说hash表的缺点：</p><ul><li>需要大量内存空间，因为每次使用hash表的时候都需要将全量的数据加载到内存中。（memory存储引擎使用hash索引）</li><li>使用hash表时需要设计优秀的hash算法，否则会导致数据分布不均匀，浪费存储空间，查询效率低下。</li><li>hash表只能支持等值搜索，不能范围或区间搜索。比如要查询id &lt; 500的人，hash表只能从1到499依次查出来。这是hash表比较致命的缺点。</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>使用二叉搜索树可以使用二分查找方式查找数据，但是如果插入的数据是递增的，二叉树就会退化成链表，树的深度也很大，而<strong>树的深度与查找次数成正比</strong>（下面会解释，<strong>减少树的深度正是提高索引效率的核心思路之一</strong>）。因此单纯的二叉搜索树效率可能会低下。</p><p>那么使用二叉平衡树（AVL树）呢？<br>二叉平衡树要求左右子树高度差不大于1，这避免了上面数据退化成链表的情况，提高了搜索效率，但是在插入数据时，二叉平衡树为了保证平衡性，插入时要进行旋转，而这降低了插入效率。此外，在数据量大的情况下，二叉平衡树还是无法避免深度大的情况。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>为了解决二叉树插入效率低的情况，在看看红黑树，他也是二叉平衡树，但它只要求最长子树的深度不超过最短子树的二倍，而且还添加了变色的行为来保证树的平衡性。</p><p>可是这还是无法避免深度大的情况，接下来的思路大家应该也想到了，就是增加树的的分支来减少树的深度，这就是B树。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树最大的特点是每个节点可以包含多个Key值，B树中有一个叫degree概念，表示每个节点最多可以存储N-1个节点。</p><p>B树特点：</p><ol><li>所有键值分布在整颗树中</li><li>搜索有可能在非叶子结点结束，在关键字全集内做一次查找,性能逼近二分查找</li><li>每个节点最多拥有m个子树</li><li>根节点至少有2个子树</li><li>分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）</li><li>所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</li></ol><p>下面看一个实例：</p><p><img src="/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/Bshu.png" alt="Bshu"></p><p>实例图说明：</p><p>每个节点占用一个磁盘块，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为 16 和 34，P1 指针指向的子树的数据范围为小于 16，P2 指针指向的子树的数据范围为 16~34，P3 指针指向的子树的数据范围为大于 34。 </p><p>查找关键字过程：</p><ol><li><p>根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】</p></li><li><p>比较关键字 28 在区间（16,34），找到磁盘块 1 的指针 P2。</p></li><li><p>根据 P2 指针找到磁盘块 3，读入内存。【磁盘 I/O 操作第 2 次】</p></li><li><p>比较关键字 28 在区间（25,31），找到磁盘块 3 的指针 P2。</p></li><li><p>根据 P2 指针找到磁盘块 8，读入内存。【磁盘 I/O 操作第 3 次】</p></li><li><p>在磁盘块 8 中的关键字列表中找到关键字 28。 </p></li></ol><p>但是B树依旧有缺点：</p><ol><li><p>每个节点都有key，同时也包含data，而每个页存储空间是有限的，如果data比较大的话会导致每个节点存储的key数量变小</p></li><li><p>当存储的数据量很大的时候会导致深度较大，增大查询时磁盘io次数，进而影响查询性能</p></li></ol><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+ Tree 是基于B Tree 和<strong>叶子节点顺序</strong>访问进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。此外，B+ 树不在非叶子节点存储数据，只存储Key值，使得B+ Tree每个节点可以包含更多的节点。</p><p>B+Tree是在B Tree的基础之上做的一种优化，变化如下：</p><ol><li>非叶子节点存储key，叶子节点存储key和数据</li><li>B+ Tree每个节点可以包含更多的节点，这个做的原因有两个，第一个原因是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快</li><li>叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高</li></ol><p>如图：<br><img src="/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/B+shu.png" alt="B+shu"></p><p>注意：在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。<strong>因此B+Tree 支持两种查找运算：一种是对于主键的范围查找和分页查找（解决Hash表缺点），另一种是从根节点开始，进行随机查找。</strong></p><h4 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h4><p>借助索引查找时，现在B+树根节点进行二分查找，找到所查找项对应区间的结点之后继续递归的查找，直到在叶子节点找出Key所对应的data。<br>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。这也是索引共同的缺点。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>B+树能显著减少IO次数，提高效率</li><li>B+树的查询效率更加稳定，因为数据放在叶子节点</li><li>B+树能提高范围查询的效率，因为叶子节点指向下一个叶子节点</li><li>B+树采取顺序读</li></ol><p>看了下面的解释，我们会更深入的了解B+ 树高效的原因</p><h4 id="为什么B-树有更高的性能？"><a href="#为什么B-树有更高的性能？" class="headerlink" title="为什么B+ 树有更高的性能？"></a>为什么B+ 树有更高的性能？</h4><p>我们先看一下数据库数据从查找到传递在磁盘上经历哪些步骤：</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页（数据页16KB，6384字节），内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><p><img src="/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/cipan.png" alt="cipan"><br>如图，磁盘结构包括：盘片，磁头，主轴，集成电路板。</p><p><strong>磁盘上有一条条磁道，数据存于磁盘的磁道上，要查找并读取一个存储的数据，磁头从不存储数据的着陆区移动到磁道上，经过磁盘旋转找到对应数据，在将数据传送的内存。</strong></p><p>那么我们就可以发现：</p><p><strong>单次的IO时间 =   寻道时间 + 旋转延迟 + 传送时间</strong></p><p>此时我们再来看B+ 树的数据结构为什么能更高效：</p><ol><li>B+ 树有更低的树高</li></ol><p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。 因为B+ Tree 的非叶子节点不存放数据，只存储Key，B+ Tree 的出度一般都非常大（红黑树的出度为 2），所以 B+ Tree 的树高比较低，而从B+ 树一层层查找的过程我们可以推理出，每一层（每次查询）都要在磁盘进行搜索（寻道），<strong>更低的树高可以有效的减少寻道时间</strong>。</p><ol start="2"><li>磁盘预读特性</li></ol><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。<strong>B+ 树叶子节点相连的特性恰恰迎合了磁盘的顺序读，减少了旋转延迟</strong>。</p><p>总结：B+ 树除了数据结构本身的高效，还迎合了磁盘的I/O机制，所以能更高效。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;聊一下索引的底层数据结构，着重介绍现在用的比较广泛的B树与B+树。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="MySQL索引" scheme="http://example.com/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL performance schema简述</title>
    <link href="http://example.com/2022/05/16/MySQL-performance-schema%E7%AE%80%E8%BF%B0/"/>
    <id>http://example.com/2022/05/16/MySQL-performance-schema%E7%AE%80%E8%BF%B0/</id>
    <published>2022-05-16T15:14:03.000Z</published>
    <updated>2022-05-17T11:57:39.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="performance-schema的介绍"><a href="#performance-schema的介绍" class="headerlink" title="performance_schema的介绍"></a>performance_schema的介绍</h2><p><strong>MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况</strong>。</p><span id="more"></span><h3 id="performance-schema特点"><a href="#performance-schema特点" class="headerlink" title="performance_schema特点"></a>performance_schema特点</h3><ul><li><strong>它提供了一种在数据库运行时实时检查server的内部执行情况的方法</strong>。performance_schema 数据库中的表使用performance_schema存储引擎。该数据库主要关注数据库运行过程中的性能相关的数据（information_schema主要关注server运行过程中的元数据信息）。</li><li><strong>performance_schema通过监视server的事件来实现监视server内部运行情况， “事件”就是server内部活动中所做的任何事情以及对应的时间消耗</strong>。利用这些信息来判断server中的相关资源消耗在了哪里？一般来说，事件可以是函数调用、操作系统的等待、SQL语句执行的阶段（如sql语句执行过程中的parsing 或 sorting阶段）或者整个SQL语句与SQL语句集合。事件的采集可以方便的提供server中的相关存储引擎对磁盘文件、表I/O、表锁等资源的同步调用信息。</li><li>performance_schema中的事件记录的是server执行某些活动对某些资源的消耗、耗时、这些活动执行的次数等情况。</li><li>performance_schema中的事件只记录在本地server的performance_schema中，其下的这些表中数据发生变化时不会被写入binlog中，也不会通过复制机制被复制到其他server中。</li><li>当前活跃事件、历史事件和事件摘要相关的表中记录的信息。能提供某个事件的执行次数、使用时长。进而可用于分析某个特定线程、特定对象（如mutex或file）相关联的活动。</li><li>PERFORMANCE_SCHEMA存储引擎使用server源代码中的“检测点”来实现事件数据的收集。对于performance_schema实现机制本身的代码没有相关的单独线程来检测，这与其他功能（如复制或事件计划程序）不同</li><li>收集的事件数据存储在performance_schema数据库的表中。这些表可以使用SELECT语句查询，也可以使用SQL语句更新performance_schema数据库中的表记录</li><li>performance_schema的表中的数据不会持久化存储在磁盘中，而是保存在内存中，一旦服务器重启，这些数据会丢失（包括配置表在内的整个performance_schema下的所有数据）</li><li>MySQL支持的所有平台中事件监控功能都可用，但不同平台中用于统计事件时间开销的计时器类型可能会有所差异。</li></ul><h2 id="performance-schema实践操作"><a href="#performance-schema实践操作" class="headerlink" title="performance_schema实践操作"></a>performance_schema实践操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1、哪类的SQL执行最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--2、哪类SQL的平均响应时间最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,AVG_TIMER_WAIT <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--3、哪类SQL排序记录数最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_SORT_ROWS <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--4、哪类SQL扫描记录数最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_EXAMINED <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--5、哪类SQL使用临时表最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--6、哪类SQL返回结果集最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_SENT <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--7、哪个表物理IO最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE <span class="keyword">FROM</span> file_summary_by_instance <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_NUMBER_OF_BYTES_READ <span class="operator">+</span> SUM_NUMBER_OF_BYTES_WRITE <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--8、哪个表逻辑IO最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT <span class="keyword">FROM</span> table_io_waits_summary_by_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> sum_timer_wait <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--9、哪个索引访问最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE <span class="keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_TIMER_WAIT <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--10、哪个索引从来没有用过？</span></span><br><span class="line"><span class="keyword">SELECT</span> OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME <span class="keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="keyword">WHERE</span> INDEX_NAME <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> COUNT_STAR <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> OBJECT_SCHEMA <span class="operator">&lt;&gt;</span> <span class="string">&#x27;mysql&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> OBJECT_SCHEMA,OBJECT_NAME;</span><br><span class="line"><span class="comment">--11、哪个等待事件消耗时间最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT <span class="keyword">FROM</span> events_waits_summary_global_by_event_name <span class="keyword">WHERE</span> event_name <span class="operator">!=</span> <span class="string">&#x27;idle&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_TIMER_WAIT <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_ID,sql_text <span class="keyword">FROM</span> events_statements_history <span class="keyword">WHERE</span> sql_text <span class="keyword">LIKE</span> <span class="string">&#x27;%count(*)%&#x27;</span>;</span><br><span class="line"><span class="comment">--12-2、查看每个阶段的时间消耗</span></span><br><span class="line"><span class="keyword">SELECT</span> event_id,EVENT_NAME,SOURCE,TIMER_END <span class="operator">-</span> TIMER_START <span class="keyword">FROM</span> events_stages_history_long <span class="keyword">WHERE</span> NESTING_EVENT_ID <span class="operator">=</span> <span class="number">1553</span>;</span><br><span class="line"><span class="comment">--12-3、查看每个阶段的锁等待情况</span></span><br><span class="line"><span class="keyword">SELECT</span> event_id,event_name,source,timer_wait,object_name,index_name,operation,nesting_event_id <span class="keyword">FROM</span> events_waits_history_longWHERE nesting_event_id <span class="operator">=</span> <span class="number">1553</span>;</span><br></pre></td></tr></table></figure><p>​        instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</p><p>​        consumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;performance-schema的介绍&quot;&gt;&lt;a href=&quot;#performance-schema的介绍&quot; class=&quot;headerlink&quot; title=&quot;performance_schema的介绍&quot;&gt;&lt;/a&gt;performance_schema的介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="http://example.com/2022/05/12/synchronized%E6%B5%85%E8%81%8A/"/>
    <id>http://example.com/2022/05/12/synchronized%E6%B5%85%E8%81%8A/</id>
    <published>2022-05-12T01:55:06.000Z</published>
    <updated>2022-05-12T02:11:09.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>模拟银行账户，对业务写方法加锁，对业务读方法不加锁，这样行不行？</p><span id="more"></span><p>不行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">容易产生脏读问题（dirtyRead）</span><br><span class="line">public class Account &#123;</span><br><span class="line">String name;</span><br><span class="line">double balance;</span><br><span class="line"></span><br><span class="line">public synchronized void set(String name, double balance) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">this.balance = balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public /*synchronized*/ double getBalance(String name) &#123;</span><br><span class="line">return this.balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Account a = new Account();</span><br><span class="line">new Thread(()-&gt;a.set(&quot;zhangsan&quot;, 100.0)).start();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(1);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(a.getBalance(&quot;zhangsan&quot;));</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(2);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(a.getBalance(&quot;zhangsan&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized注意事项"><a href="#synchronized注意事项" class="headerlink" title="synchronized注意事项"></a>synchronized注意事项</h3><p>synchronized可重入，不然可能会发生死锁（同一个线程）</p><p>异常跟锁：程序之中如果出现异常，默认情况下，锁会释放</p><p>synchronized锁的是对象，不是代码。synchronized(Object)</p><p>synchronized不能锁String常量，Integer等基础类型</p><p>在竞争不是很激烈的情况下，尽量让锁的粒度细化一些，使性能更快。如果竞争很激烈，可以锁的粒度粗化，也可提升性能。</p><p>锁定某对象o，如果o的属性发生改变，不影响锁的使用，但是如果o变成另外一个对象，则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象。（给引用加final）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class SyncSameObject &#123;</span><br><span class="line">   </span><br><span class="line">   /*final*/ Object o = new Object();</span><br><span class="line"></span><br><span class="line">   void m() &#123;</span><br><span class="line">      synchronized(o) &#123;</span><br><span class="line">         while(true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SyncSameObject t = new SyncSameObject();</span><br><span class="line">      //启动第一个线程</span><br><span class="line">      new Thread(t::m, &quot;t1&quot;).start();</span><br><span class="line">      </span><br><span class="line">      try &#123;</span><br><span class="line">         TimeUnit.SECONDS.sleep(3);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      //创建第二个线程</span><br><span class="line">      Thread t2 = new Thread(t::m, &quot;t2&quot;);</span><br><span class="line">      </span><br><span class="line">      t.o = new Object(); //锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会</span><br><span class="line">      </span><br><span class="line">      t2.start();</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在虚拟机堆中new出对象，对象中首先是8个字节的markword，4个字节的类型指针，4字节成员变量（long类型8个字节），Hotspot要求对象8字节对齐（字节数是8的整数倍），不足对齐。</p><p>在Hotspot中，所谓的上锁就是修改markword。</p><p><img src="/2022/05/12/synchronized%E6%B5%85%E8%81%8A/suo.png" alt="suo"></p><p>如上图，普通对象synchronized修饰加锁，升级为偏向锁，有线程与其竞争时偏向锁升级为轻量级锁（自旋锁，无锁 ），再竞争升级为重量级锁</p><h3 id="上锁的本质"><a href="#上锁的本质" class="headerlink" title="上锁的本质"></a>上锁的本质</h3><p>锁可以升级但不能降级，意味着偏向<a href="https://so.csdn.net/so/search?q=%E9%94%81%E5%8D%87%E7%BA%A7&spm=1001.2101.3001.7020">锁升级</a>成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率.</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p> 偏向锁，顾名思义，它会偏向于第一个访问锁的线程</p></blockquote><ul><li>如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</li><li>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。偏向锁通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致STW(stop the word)操作；</li></ul><blockquote><p>锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p></blockquote><h4 id="轻量级锁（自旋锁）"><a href="#轻量级锁（自旋锁）" class="headerlink" title="轻量级锁（自旋锁）"></a>轻量级锁（自旋锁）</h4><blockquote><p>自旋锁：自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p></blockquote><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起，等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><blockquote><p>重量级锁的特点：其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程。</p></blockquote><h4 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><p>摘自<a href="https://blog.csdn.net/qq_40722827/article/details/105598682">(32条消息) 深入理解Java锁升级：无锁 → 偏向锁 → 轻量级锁 → 重量级锁_carroll18的博客-CSDN博客_无锁,偏向锁</a></p><p>上锁的本质是修改线程的markword，从markword可以看出对象的锁状态，如下，先看后两位：</p><p><img src="/2022/05/12/synchronized%E6%B5%85%E8%81%8A/Hotspot%E4%B8%8B%E7%9A%84%E9%94%81%E7%8A%B6%E6%80%81.png" alt="Hotspot下的锁状态"></p><p>偏向锁，轻量级锁：用户空间锁（用户空间锁：不需要向操作系统申请）</p><p>偏向锁：<strong>把markword线程ID改为自己线程的ID</strong></p><p>StringBuffer加synchronized上的就是偏向锁，前提是没竞争条件下。</p><p><strong>如果有线程竞争，偏向锁撤销，升级为自旋锁：竞争条件下的线程在线程栈内部，生成LR（LockRecord 锁记录）。自旋的方式相互竞争锁，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁，其它锁会CAS的一直监控此锁是否释放（自旋等待），自旋超过10次后，会自动升级为重量级锁</strong></p><p>重量级锁：需要向操作系统申请锁</p><blockquote><p>看操作系统的interpreterRuntime.cpp文件</p></blockquote><p>锁重入</p><p>synchronized  是可重入锁</p><p>重入次数必须记录，因为要解锁几次必须对应</p><p>偏向锁重入次数记录在线程栈的里LR中，每重入一次+1，</p><h3 id="什么时候自旋锁升级为重量级锁？"><a href="#什么时候自旋锁升级为重量级锁？" class="headerlink" title="什么时候自旋锁升级为重量级锁？"></a>什么时候自旋锁升级为重量级锁？</h3><p>竞争加剧：有线程超过10次自旋，-XX:PreBlockSpin，或者自旋线程数超过CPU核数的一半，1.6之后，加入自适应自旋Adapative Self Spinning，JVM自己控制</p><h3 id="为什么有自旋锁还需要有重量级锁？"><a href="#为什么有自旋锁还需要有重量级锁？" class="headerlink" title="为什么有自旋锁还需要有重量级锁？"></a>为什么有自旋锁还需要有重量级锁？</h3><p>自旋消耗资源，如果锁的时间长，数量多，CPU会大量消耗。</p><p>重量级锁：有等待队列</p><p>在自旋锁升级为重量级锁时，自旋的线程都会放到队列（waitSet），不需要消耗资源。</p><h3 id="偏向锁未启动与已启动"><a href="#偏向锁未启动与已启动" class="headerlink" title="偏向锁未启动与已启动"></a>偏向锁未启动与已启动</h3><p>偏向锁是否一定比自旋锁效率高？</p><p>不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁。</p><p>JVM启动时会有多线程竞争，这是默认关闭偏向锁，过一段时间再打开</p><p>偏向锁启动延时</p><p>对象new出来时可能偏向锁就已经启动，此情况叫匿名偏向，偏向锁没有偏向任何一个线程。</p><p><del>这个图已经在文件夹里了，不贴浪费了</del></p><p><img src="/2022/05/12/synchronized%E6%B5%85%E8%81%8A/yinzi.png" alt="yinzi"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h3&gt;&lt;p&gt;模拟银行账户，对业务写方法加锁，对业务读方法不加锁，这样行不行？&lt;/p&gt;</summary>
    
    
    
    <category term="多线程与高并发" scheme="http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与高并发" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程三大特性</title>
    <link href="http://example.com/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</id>
    <published>2022-05-12T01:47:21.000Z</published>
    <updated>2022-05-25T05:05:21.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发编程之可见性"><a href="#并发编程之可见性" class="headerlink" title="并发编程之可见性"></a>并发编程之可见性</h2><p>加入一个线程t1运行时使用一个变量（把这个变量从主存复制下来存到线程内部），这时线程t2修改了这个变量，但是t1线程无法读到修改后的变量值。这就是线程的不可见性。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * volatile 关键字，使一个变量在多个线程间可见</span><br><span class="line"> * A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道</span><br><span class="line"> * 使用volatile关键字，会让所有线程都会读到变量的修改值</span><br><span class="line"> * </span><br><span class="line"> * 在下面的代码中，running是存在于堆内存的t对象中</span><br><span class="line"> * 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去</span><br><span class="line"> * 读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行</span><br><span class="line"> * </span><br><span class="line"> * 使用volatile，将会强制所有线程都去堆内存中读取running的值</span><br><span class="line"> * </span><br><span class="line"> * volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</span><br><span class="line"> *</span><br><span class="line"> * @author mashibing</span><br><span class="line"> */</span><br><span class="line">package com.mashibing.juc.c_001_00_Visibility;</span><br><span class="line"></span><br><span class="line">import com.mashibing.util.SleepHelper;</span><br><span class="line"></span><br><span class="line">public class T01_HelloVolatile &#123;</span><br><span class="line">    private static volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">    private static void m() &#123;</span><br><span class="line">        System.out.println(&quot;m start&quot;);</span><br><span class="line">        while (running) &#123;</span><br><span class="line">            //System.out.println(&quot;hello&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;m end!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(T01_HelloVolatile::m, &quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(1);</span><br><span class="line"></span><br><span class="line">        running = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用volatile，将会强制所有线程都去堆内存中读取running的值</strong></p><p>volatile修饰的代码，字节码解释器会有一个叫lock的前置指令修饰，这个lock指令的作用就是：会等待它之前的所有指令完成，并将所有缓冲的写操作写到内存，根据缓存一致性协议，缓存的副本将会失效，并且禁止该指令与其前后的读写指令进行重排序</p><p><strong>volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</strong></p><blockquote><p>volatile</p><ul><li>保证线程可见性<ul><li>MESI</li><li>缓存一致性协议</li></ul></li><li>禁止指令重排序<ul><li>DCL单例模式双重校验加volatile</li><li>loadfence原语指令（内存屏障CPU原语）</li><li>storefence原语指令（内存屏障CPU原语）</li></ul></li></ul></blockquote><p>在变量中加入volatile修饰可以保证线程的可见性，但变量修改时，会同步进t1线程中。另外在某些语句执行的时候（例如println，因为它源码中被synchronized修饰），会触发本地缓存与主内存之间的同步。</p><p>volatile修饰引用类型（包括数组）只能保证引用本身的可见性，而不能保证内部字段的可见性。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class A&#123;</span><br><span class="line">boolean running = true;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">private volatile static A a = new A();</span><br></pre></td></tr></table></figure><p>能保证a的可见性，而running不能。</p><h3 id="缓存行对齐"><a href="#缓存行对齐" class="headerlink" title="缓存行对齐"></a>缓存行对齐</h3><ul><li>缓存行对齐<br>缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高<br>Disruptor也是类似写法</li><li><strong>认识缓存行对齐的编程技巧：因为空间局部性原理，线程读内存数据时会预读它周围内存的数据，而如果多个线程需要的变量恰好相邻（t1需要x1，t2需要x2，x1，x2相邻，t1，t2会把它们都读入线程内），那么线程修改变量的时候，线程之间必须保证缓存一致性，所以会相互同步变量。这个操作也需要消耗资源，减慢效率。</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class T01_CacheLinePadding &#123;</span><br><span class="line">    public static long COUNT = 10_0000_0000L;</span><br><span class="line"></span><br><span class="line">    private static class T &#123;</span><br><span class="line">        private long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">        public long x = 0L;</span><br><span class="line">        private long p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static T[] arr = new T[2];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        arr[0] = new T();</span><br><span class="line">        arr[1] = new T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        CountDownLatch latch = new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (long i = 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">                arr[0].x = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (long i = 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">                arr[1].x = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        final long start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/100_0000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注：JUC"><a href="#注：JUC" class="headerlink" title="注：JUC"></a>注：JUC</h3><h4 id="tools（工具类）：又叫信号量三组工具类，包含有"><a href="#tools（工具类）：又叫信号量三组工具类，包含有" class="headerlink" title="tools（工具类）：又叫信号量三组工具类，包含有"></a>tools（工具类）：又叫信号量三组工具类，包含有</h4><p>1）CountDownLatch（闭锁） 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待</p><p>2）CyclicBarrier（栅栏） 之所以叫barrier，是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用。</p><p>3）Semaphore（信号量） 是一个计数信号量，它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</p><h4 id="executor-执行者-：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有："><a href="#executor-执行者-：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：" class="headerlink" title="executor(执行者)：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有："></a>executor(执行者)：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：</h4><p>1）ScheduledExecutorService 解决那些需要任务重复执行的问题</p><p>2）ScheduledThreadPoolExecutor 周期性任务调度的类实现</p><h4 id="atomic-原子性包-：是JDK提供的一组原子操作类，"><a href="#atomic-原子性包-：是JDK提供的一组原子操作类，" class="headerlink" title="atomic(原子性包)：是JDK提供的一组原子操作类，"></a>atomic(原子性包)：是JDK提供的一组原子操作类，</h4><p>包含有AtomicBoolean、AtomicInteger、AtomicIntegerArray等原子变量类，他们的实现原理大多是持有它们各自的对应的类型变量value，而且被volatile关键字修饰了。这样来保证每次一个线程要使用它都会拿到最新的值。</p><h4 id="locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有："><a href="#locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有：" class="headerlink" title="locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有："></a>locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有：</h4><p>1）ReentrantLock 它是独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。</p><p>2）ReentrantReadWriteLock 它包括子类ReadLock和WriteLock。ReadLock是共享锁，而WriteLock是独占锁。</p><p>3）LockSupport 它具备阻塞线程和解除阻塞线程的功能，并且不会引发死锁。</p><h4 id="collections-集合类-：主要是提供线程安全的集合，-比如："><a href="#collections-集合类-：主要是提供线程安全的集合，-比如：" class="headerlink" title="collections(集合类)：主要是提供线程安全的集合， 比如："></a>collections(集合类)：主要是提供线程安全的集合， 比如：</h4><p>1）ArrayList对应的高并发类是CopyOnWriteArrayList，</p><p>2）HashSet对应的高并发类是 CopyOnWriteArraySet，</p><p>3）HashMap对应的高并发类是ConcurrentHashMap等等</p><p><a href="https://blog.csdn.net/weixin_43888181/article/details/116546374">(31条消息) java–JUC快速入门（彻底搞懂JUC）_YANG-Π的博客-CSDN博客_java juc</a></p><h3 id="Contended注解"><a href="#Contended注解" class="headerlink" title="Contended注解"></a>Contended注解</h3><p><strong>需要注意，JDK8引入了@sun.misc.Contended注解（只有1.8有），来保证缓存行隔离效果</strong><br>要使用此注解，必须去掉限制参数：-XX:-RestrictContended</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_001_02_FalseSharing;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Contended;</span><br><span class="line"><span class="comment">//注意：运行这个小程序的时候，需要加参数：-XX:-RestrictContended</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T05_Contended</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">COUNT</span> <span class="operator">=</span> <span class="number">10_0000_0000L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">        <span class="meta">@Contended</span>  <span class="comment">//只有1.8起作用 , 保证x位于单独一行中</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并发编程之有序性"><a href="#并发编程之有序性" class="headerlink" title="并发编程之有序性"></a>并发编程之有序性</h2><p>为何会存在乱序：为了提高效率</p><p>乱序存在的条件：</p><ul><li>as - if - serial     看上去像是序列化（单线程）</li><li>不影响单线程的最终一致性</li></ul><h3 id="对象实例化的过程："><a href="#对象实例化的过程：" class="headerlink" title="对象实例化的过程："></a>对象实例化的过程：</h3><ol><li>申请一个内存，成员变量赋默认值（半初始化状态）</li><li>调用构造方法，成员变量赋初始值（初始化完成）</li><li>与引用建立关联</li></ol><p><img src="/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/shilihua.png" alt="shilihua"></p><p><strong>步骤2与步骤3可能会互换顺序，这个现象叫做指令重排，如果在构造方法中new线程同时启动线程，在指令重排的情况下，中间可能this可能会得到值为默认值0的变量，所以不要在构造方法中启动线程。</strong></p><p>美团面试题：</p><ol><li>请解释一下对象的创建过程（半初始化）</li><li>DCL与volatile问题（指令重排）</li><li>对象在内存中的存储布局（对象与数组的存储不同）</li><li>对象头具体包括什么（markword klasspointer  synchronized）</li><li>对象怎么定位（直接 间接）</li><li>对象怎么分配（栈上-线程本地-Eden-Old）</li><li>Object o = new Object() 在内存中占用多少字节？</li></ol><h3 id="使用内存屏障阻止乱序执行"><a href="#使用内存屏障阻止乱序执行" class="headerlink" title="使用内存屏障阻止乱序执行"></a>使用内存屏障阻止乱序执行</h3><p>内存屏障是特殊指令：看到这种指令，前面的必须执行完，后面的才能执行</p><p>intel : lfence sfence mfence(CPU特有指令)</p><h3 id="JVM中的内存屏障"><a href="#JVM中的内存屏障" class="headerlink" title="JVM中的内存屏障"></a>JVM中的内存屏障</h3><p>所有实现JVM规范的虚拟机，必须实现以下四个屏障：</p><p>LoadLoadBarrier LoadStoreBarrier StoreLoadBarrier StoreStorBarriere（Load：读 Store：写）</p><h3 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h3><p>Volatile修饰的变量如下图会建立内存屏障，屏障两边的指令不可以重排！保障有序！</p><p><img src="/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/volatile.png" alt="volatile"></p><p>volatile在hotspot中的底层实现</p><p>orderaccess_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (os::<span class="built_in">is_MP</span>()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AMD64</span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%rsp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>LOCK 用于在多处理器中执行指令时对共享内存的独占使用。<br>它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。</strong><br><strong>另外还提供了有序的指令无法越过这个内存屏障的作用。</strong></p></blockquote><h2 id="并发编程之原子性"><a href="#并发编程之原子性" class="headerlink" title="并发编程之原子性"></a>并发编程之原子性</h2><p>race condition: 竞争条件 ， 指的是多个线程访问共享数据的时候产生竞争。</p><p>在有多线程之间有竞争条件下，可能会导致数据的不一致（unconsistency)，比如多个线程操作的变量在并发访问之下产生的不期望出现的结果。</p><h3 id="如何保障数据一致？"><a href="#如何保障数据一致？" class="headerlink" title="如何保障数据一致？"></a>如何保障数据一致？</h3><p>本质上是线程同步的问题（线程执行的顺序安排好），synchronized可以解决此问题。</p><p>synchronized：保证原子性，可见性</p><p>monitor （管程），如下代码，synchronized (o)中对象o即为monitor 。</p><p>critical section （临界区），如下代码，{}内的部分为临界区。</p><p>如果临界区执行时间长，语句多，叫做 锁的粒度比较粗，反之，就是锁的粒度比较细。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (o) &#123; </span><br><span class="line">              System.out.println(Thread.currentThread().getName() + &quot; start!&quot;);</span><br><span class="line">              SleepHelper.sleepSeconds(2);</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + &quot; end!&quot;);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>在被synchronized修饰的条件下，多线程竞争临界区的操作，必须要等持有锁的线程执行完，释放锁之后才能由下一个线程去执行。所以临界区的代码都具有原子性，synchronized也是用此方法保证可见性的。</p><p>上锁的本质是吧并发编程序列化，上锁的代码这个线程执行完，另一个才能执行。</p><p>锁分为两种：</p><ul><li><p>悲观锁：悲观的认为这个操作会被别的线程打断（悲观锁）如：synchronized</p></li><li><p>乐观锁：乐观的认为这个做不会被别的线程打断（乐观锁 自旋锁 无锁）如：cas操作<br>CAS = Compare And Set/Swap/Exchange</p><p>乐观锁：不行就重来!</p></li></ul><h3 id="CAS的深度剖析"><a href="#CAS的深度剖析" class="headerlink" title="CAS的深度剖析"></a>CAS的深度剖析</h3><p>CAS:Compare And Set/Exchange，比较并且设定</p><p>CAS（V，Expected，NewValue）：</p><p>​    if(V == E)</p><p>​    V = New</p><p>​    otherwise try again or fail</p><p><strong>CPU原语支持CAS操作</strong></p><p><img src="/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/CAS.png" alt="CAS"></p><p>CAS的ABA问题解决方案 - Version</p><p>因为CAS判断的过程不能被打断，所以要求CAS本身必须是原子性的</p><p>操作系统底层本身也支持CAS</p><h4 id="从AtomicInteger入手深入源码剖析CAS"><a href="#从AtomicInteger入手深入源码剖析CAS" class="headerlink" title="从AtomicInteger入手深入源码剖析CAS"></a>从AtomicInteger入手深入源码剖析CAS</h4><p>AtomicInteger:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Unsafe:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br></pre></td></tr></table></figure><p>运用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T02_TestUnsafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">T02_TestUnsafe</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T02_TestUnsafe</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> T02_TestUnsafe.class.getDeclaredField(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: unsafe.cpp:</p><p>cmpxchg = compare and exchange set swap</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></p><p>is_MP = Multi Processors  （CPU多核）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: os.hpp is_MP()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_IF_MP(mp) <span class="string">&quot;cmp $0, &quot;</span> #mp <span class="string">&quot;; je 1f; lock; 1: &quot;</span></span></span><br></pre></td></tr></table></figure><p>最终实现：</p><p>cmpxchg = cas修改变量值</p><p><strong>cmpxchg 在汇编语句上不是原子性的，所以加上了lock</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure><p>硬件：</p><p>lock指令在执行的时候视情况采用缓存锁或者总线锁，如上lock cmpxchg 指令，某个CPU在改动内存的值的时候，会把总线（或其他什么东西）锁上，等CPU改动完并返回之后再解开锁。所以CAS说是乐观锁，但在底层的实现还是很像悲观锁。</p><p>乐观锁效率不一定比悲观锁高，</p><p>如果临界区执行时间比较长，等的线程又很多 -&gt; 重量级</p><p>时间短，等的线程少 -&gt; 自旋锁</p><h3 id="synchronized如何保障可见性？"><a href="#synchronized如何保障可见性？" class="headerlink" title="synchronized如何保障可见性？"></a>synchronized如何保障可见性？</h3><p>解锁之后，要把内存的状态与本地的缓存做一次刷新对比，之后下个线程才会继续</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;并发编程之可见性&quot;&gt;&lt;a href=&quot;#并发编程之可见性&quot; class=&quot;headerlink&quot; title=&quot;并发编程之可见性&quot;&gt;&lt;/a&gt;并发编程之可见性&lt;/h2&gt;&lt;p&gt;加入一个线程t1运行时使用一个变量（把这个变量从主存复制下来存到线程内部），这时线程t2修改了这个变量，但是t1线程无法读到修改后的变量值。这就是线程的不可见性。&lt;/p&gt;</summary>
    
    
    
    <category term="多线程与高并发" scheme="http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与高并发" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程基础</title>
    <link href="http://example.com/2022/05/12/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/05/12/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-12T01:10:11.000Z</published>
    <updated>2022-05-12T01:46:22.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>程序是操作系统能运行的文件</strong></p><p>进程是运行的程序</p><p>一个程序可以有多个进程</p><p><strong>进程：进程是操作系统进行资源分配的基本单位</strong></p><span id="more"></span><p>多进程并行处理：把程序写在不同的内存位置上来回切换</p><p>多线程并行处理：一个程序内部不同任务的来回切换</p><p>通俗来讲：</p><ul><li><p>线程：程序里不同的执行路径</p></li><li><p>mian方法开启的线程叫做主线程</p></li></ul><p><strong>线程：调度执行的基本单位</strong></p><ul><li>一个程序执行的时候，内存会先找到它的主线程，推送给CPU执行，主线程执行时可能会开启其他线程，这时就涉及到线程之间的切换</li></ul><p><strong>线程切换也是需要资源的</strong></p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li><p>单核CPU设定多线程是否有意义？</p><p>有意义</p><p>CPU密集型：计算多，IO密集型：输入输出多</p></li><li><p>工作线程数是不是设置的越大越好</p><p>不是，线程切换也需要消耗资源</p></li><li><p>工作线程数（线程池中线程数）设为多少最合适？</p><p>N = N（CPU）+ U（CPU）* （1 + W / C）</p><p>N（CPU）是处理器核的数目</p><p>U（CPU）是期望的CPU利用率（0 - 1）</p><p>W / C 是等待时间与计算时间的比率</p></li></ol><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>创建线程的5种方法</p><ol><li><p>new MyThread().start()  MyThread扩展了Thread类，重写run方法</p></li><li><p>new Thread(new r()).start()  r继承了Runnable接口，重写run方法</p></li><li><p>new Thread(lamda).start()  使用lamda表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(&quot;Hello Lambda&quot;);</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure></li><li><p>ThreadPool 线程池  Executors.newCachedThrad</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">service.execute(()-&gt;&#123;</span><br><span class="line">System.out.println(&quot;Hello ThreadPool&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Future Callable and FutureTask</p><p>Callable  与 Runnable很类似，但继承Callable时，可以通过泛型指定返回类型，在通过线程池得到，用Future<T> 接收</T></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; f = service.submit(new MyCall());</span><br><span class="line">String s = f.get();</span><br></pre></td></tr></table></figure><p>FutureTask类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new MyCall());</span><br><span class="line">Thread t = new Thread(task);</span><br><span class="line">s.start();</span><br><span class="line">System.out.println(task.get());</span><br></pre></td></tr></table></figure></li></ol><h2 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h2><p>sleep():当前线程暂停一段时间。</p><p>yield():退出CPU，进入等待队列（返回就绪状态）</p><p>join():t2线程里使用t1.join()，t1线程加入t2线程中，等t2执行完，再执行t1。经常用来等待另一个线程结束</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态*"></a>线程的状态*</h2><p><strong>小节说明：</strong></p><ul><li>本节重要程度：中 （帮助理解线程问题，保障知识完整性，面试很少考）  </li><li>本节难度：低</li></ul><p>Java线程的6种状态：</p><p><img src="/2022/05/12/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/zhuangtai.png" alt="zhuangtai"></p><ol><li>NEW：线程刚刚被创建还没有启动</li><li>RANNABLE：可运行状态</li><li>WAITING：等待被唤醒</li><li>TIMED WAITING：隔一段时间后自动唤醒</li><li>BLOCKED：被阻塞，正在等待锁</li><li>TERMINATED：线程结束</li></ol><p>每个线程只能start一次</p><p><strong>lock方法用的是JUC的CAS上锁，忙等待</strong>，不会陷入BLOCKED状态，而是WAITING</p><h2 id="线程的打断"><a href="#线程的打断" class="headerlink" title="线程的打断*"></a>线程的打断*</h2><ul><li>interrupt()：实例方法，设置线程的中断标志位，线程自己决定是否中断</li><li>isInterrupted()：实例方法，有没有人打扰我？</li><li>interrupted()：静态方法，有没有人打扰我（当前线程）？复位！</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Thread.java  </span><br><span class="line">public void interrupt()            //t.interrupt() 打断t线程（设置t线程某给标志位f=true，并不是打断线程的运行）</span><br><span class="line">public boolean isInterrupted()     //t.isInterrupted() 查询打断标志位是否被设置（是不是曾经被打断过）</span><br><span class="line">public static boolean interrupted()//Thread.interrupted() 查看“当前”线程是否被打断，如果被打断，恢复标志位</span><br></pre></td></tr></table></figure><p>线程使用sleep(),wait(),jion()这些方法时，会设置中断标志位，同时，也会抛出interruptedException异常，在抛出这个异常的时候，可以做某些操作，同时也会重置标志位。</p><p>interrupt()不能打断正在竞争锁的线程synchronized()和lock()</p><p>如果想打断正在竞争锁的线程，使用ReentrantLock的lockInterruptibly()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * interrupt与lockInterruptibly()</span><br><span class="line"> */</span><br><span class="line">public class T11_Interrupt_and_lockInterruptibly &#123;</span><br><span class="line"></span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(()-&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                SleepHelper.sleepSeconds(10);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;t1 end!&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(()-&gt; &#123;</span><br><span class="line">            System.out.println(&quot;t2 start!&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;t2 end!&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(1);</span><br><span class="line">        </span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的结束"><a href="#线程的结束" class="headerlink" title="线程的结束"></a>线程的结束</h2><p>面试题：</p><p>如何优雅的结束一个线程？</p><p>e.g.上传一个大文件，正在处理费时的计算，如何优雅的结束这个线程？</p><p>结束线程的方法：</p><ol><li>自然结束（能自然结束就尽量自然结束）</li><li>stop() suspend() resume()，现在已经不推荐用了，可能会导致数据的不一致</li><li>volatile标志<ol><li>不适合某些场景（比如还没有同步的时候，线程做了阻塞操作，没有办法循环回去）</li><li>打断时间也不是特别精确，比如一个阻塞容器，容量为5的时候结束生产者，<br>但是，由于volatile同步线程标志位的时间控制不是很精确，有可能生产者还继续生产一段儿时间</li></ol></li><li>interrupt() and isInterrupted（比较优雅）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">while(!Thread.interrupted())&#123;</span><br><span class="line">//sleep wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;t1 end!&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">SleepHelper.sleepSeconds(1);</span><br><span class="line"></span><br><span class="line">t.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;程序是操作系统能运行的文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程是运行的程序&lt;/p&gt;
&lt;p&gt;一个程序可以有多个进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程：进程是操作系统进行资源分配的基本单位&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="多线程与高并发" scheme="http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与高并发" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/05/11/hello-world/"/>
    <id>http://example.com/2022/05/11/hello-world/</id>
    <published>2022-05-11T12:52:19.717Z</published>
    <updated>2021-08-03T01:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://example.com/2021/10/05/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://example.com/2021/10/05/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-10-05T01:43:57.000Z</published>
    <updated>2021-11-29T09:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><span id="more"></span><p>思路绝大多数来自于 <em>代码随想录</em>，只为个人学习与总结</p><h2 id="有效的字母同异位"><a href="#有效的字母同异位" class="headerlink" title="有效的字母同异位"></a>有效的字母同异位</h2><p><a href="https://leetcode-cn.com/problems/valid-anagram/">242.有效的字母同异位</a></p><p>数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//LC242</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        int[] record = new int[26];</span><br><span class="line">        for(char item : s.toCharArray()) &#123;</span><br><span class="line">            record[item - &#x27;a&#x27;] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(char item : t.toCharArray()) &#123;</span><br><span class="line">            record[item - &#x27;a&#x27;] -=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0; i&lt;record.length; i++) &#123;</span><br><span class="line">            if(record[i] != 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找共用字符"><a href="#查找共用字符" class="headerlink" title="查找共用字符"></a>查找共用字符</h2><p><a href="https://leetcode-cn.com/problems/find-common-characters/">1002. 查找共用字符</a></p><p>整体思路就是统计出搜索字符串里26个字母的出现的频率，然后取每个字符频率最小值，最后转成输出格式即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; commonChars(String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(words.length == 0)&#123;return res;&#125;</span><br><span class="line">        int[] hash = new int[26];</span><br><span class="line">        </span><br><span class="line">        for(char c : words[0].toCharArray())&#123;</span><br><span class="line">            hash[c - &#x27;a&#x27;] += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=1; i&lt;words.length; i++)&#123;</span><br><span class="line">            int[] other = new int[26];</span><br><span class="line">            for(char c : words[i].toCharArray())&#123;</span><br><span class="line">                other[c - &#x27;a&#x27;] += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int k = 0; k&lt;26; k++)&#123;</span><br><span class="line">                hash[k] = Math.min(hash[k],other[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 26; i++)&#123;</span><br><span class="line">            while(hash[i] !=0 )&#123;</span><br><span class="line">                char c = (char)(i + &#x27;a&#x27;);</span><br><span class="line">                res.add(String.valueOf(c));</span><br><span class="line">                hash[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a><br>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。<br>上面题目使用数组来做哈希的题目，是因为题目都限制了数值的大小。</p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        </span><br><span class="line">        if((nums1 == null) || (nums1.length == 0) || (nums2 == null) || (nums2.length == 0))&#123;</span><br><span class="line">            return new int[0]; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; res = new HashSet&lt;&gt;();</span><br><span class="line">        for(int item : nums1)&#123;</span><br><span class="line">            set.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int item : nums2)&#123;</span><br><span class="line">            if(set.contains(item))&#123;</span><br><span class="line">                res.add(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] arr = new int[res.size()];</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(int item : res)&#123;</span><br><span class="line">            arr[i++] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p><a href="https://leetcode-cn.com/problems/happy-number/">202.快乐数</a></p><p>快速判断集合里是否有某个数，往往会想到哈希表。下面代码中set.contains(n)正是set的关键功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        while(n!=1 &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            </span><br><span class="line">            set.add(n);n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return n == 1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    private int getNext(int n)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(n != 0)&#123;</span><br><span class="line">            int temp = n%10;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n/10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四数相加-II"><a href="#四数相加-II" class="headerlink" title="四数相加 II"></a>四数相加 II</h2><p><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i : nums1)&#123;</span><br><span class="line">            for(int j : nums2)&#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                if(map.containsKey(temp))&#123;</span><br><span class="line">                    map.put(temp, map.get(temp)+1);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    map.put(temp, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i : nums3)&#123;</span><br><span class="line">            for(int j : nums4)&#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                if(map.containsKey(0 - temp))&#123;</span><br><span class="line">                    res += map.get(0 - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p><a href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信</a></p><p>因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。</p><p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canConstruct(String ransomNote, String magazine) &#123;</span><br><span class="line">        int[] arr = new int[26];</span><br><span class="line">        for(int i=0; i&lt;magazine.length(); i++)&#123;</span><br><span class="line">            int temp = magazine.charAt(i) - &#x27;a&#x27;;</span><br><span class="line">            arr[temp]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i&lt;ransomNote.length(); i++)&#123;</span><br><span class="line">            int temp = ransomNote.charAt(i) - &#x27;a&#x27;;</span><br><span class="line">            if(arr[temp] &gt; 0)&#123;</span><br><span class="line">                arr[temp]--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;一般哈希表都是用来快速判断一个元素是否出现集合里。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="代码" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis基础</title>
    <link href="http://example.com/2021/09/17/MyBatis%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/09/17/MyBatis%E5%9F%BA%E7%A1%80/</id>
    <published>2021-09-16T23:58:27.000Z</published>
    <updated>2021-09-17T00:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis的简介"><a href="#MyBatis的简介" class="headerlink" title="MyBatis的简介"></a>MyBatis的简介</h1><span id="more"></span><h2 id="原始jdbc操作"><a href="#原始jdbc操作" class="headerlink" title="原始jdbc操作"></a>原始jdbc操作</h2><ul><li>查询数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driber&quot;);</span><br><span class="line">//获得连接</span><br><span class="line">Connection connection=DriverManager.getConnection(&quot;jdbc:mysql:///test&quot;,&quot;root&quot;,&quot;mysql&quot;);</span><br><span class="line">//获得statement</span><br><span class="line">PrepareStatement statement=connection.prepareStatement(&quot;select id,username,password from user&quot;);</span><br><span class="line">//执行查询</span><br><span class="line">ResultSet resultSet=statement.executeQuery();</span><br><span class="line">//遍历结果集</span><br><span class="line">while(resultSet.next())&#123;</span><br><span class="line">User user=new User();</span><br><span class="line">user.setid(resultSet.get(&quot;id&quot;));</span><br><span class="line">user.setUsername((resultSet.getString(&quot;username&quot;))</span><br><span class="line">user.setPassword((resultSet.getString(&quot;password&quot;</span><br><span class="line">System.out.println(user);</span><br><span class="line">))</span><br><span class="line">&#125;</span><br><span class="line">//释放资源</span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><ul><li>插入数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="原始jdbc操作的分析"><a href="#原始jdbc操作的分析" class="headerlink" title="原始jdbc操作的分析"></a>原始jdbc操作的分析</h2><ul><li>原始jdbc开发存在的问题如下：<br>  1.数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能<br>  2.sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。<br>  3.查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置</li><li>应对上述问题给出的解决方案：<br>  1.使用数据库连接池初始化连接资源<br>  2.将sql语句抽取到xml配置文件中<br>  3.使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</li></ul><h2 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h2><ul><li>mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li><li>mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</li><li>最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。</li></ul><h1 id="MyBatis的快速入门"><a href="#MyBatis的快速入门" class="headerlink" title="MyBatis的快速入门"></a>MyBatis的快速入门</h1><h2 id="MyBatis开发步骤"><a href="#MyBatis开发步骤" class="headerlink" title="MyBatis开发步骤"></a>MyBatis开发步骤</h2><ul><li>添加MyBatis的坐标</li><li>创建user数据表</li><li>编写User实体类 </li><li>编写映射文件UserMapper.xml</li><li>编写核心文件SqlMapConfig.xml</li><li>编写测试类</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li><p>导入MyBatis的坐标和其他相关坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis坐标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mysql驱动坐标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--单元测试坐标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--日志坐标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建user数据表</p></li><li><p>编写User实体</p></li><li><p>编写UserMapper映射文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;userMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt;</span><br><span class="line">        select * from User</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写MyBatis核心文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;&lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//加载核心配置文件</span><br><span class="line">InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">//获得sqlSession工厂对象</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">//获得sqlSession对象</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">//执行sql语句</span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);</span><br><span class="line">//打印结果</span><br><span class="line">System.out.println(userList);</span><br><span class="line">//释放资源</span><br><span class="line">sqlSession.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="MyBatis的映射文件概述"><a href="#MyBatis的映射文件概述" class="headerlink" title="MyBatis的映射文件概述"></a>MyBatis的映射文件概述</h1><h1 id="MyBatis的增删改查操作"><a href="#MyBatis的增删改查操作" class="headerlink" title="MyBatis的增删改查操作"></a>MyBatis的增删改查操作</h1><h1 id="MyBatis的核心配置文件概述"><a href="#MyBatis的核心配置文件概述" class="headerlink" title="MyBatis的核心配置文件概述"></a>MyBatis的核心配置文件概述</h1><h1 id="MyBatis的相应API"><a href="#MyBatis的相应API" class="headerlink" title="MyBatis的相应API"></a>MyBatis的相应API</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MyBatis的简介&quot;&gt;&lt;a href=&quot;#MyBatis的简介&quot; class=&quot;headerlink&quot; title=&quot;MyBatis的简介&quot;&gt;&lt;/a&gt;MyBatis的简介&lt;/h1&gt;</summary>
    
    
    
    <category term="Java框架" scheme="http://example.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
    <category term="Java框架" scheme="http://example.com/tags/Java%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://example.com/2021/09/15/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/09/15/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-15T01:19:49.000Z</published>
    <updated>2021-09-29T11:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>代码绝大多数来自于 <em>代码随想录</em>，只为个人学习与总结</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠split.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//LC77</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        dfs(n,k,1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int n,int k,int split)&#123;</span><br><span class="line">        //终止条件</span><br><span class="line">        if(path.size()==k)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //n - (k - path.size()) + 1是剪枝条件,原本是写成i&lt;=n。</span><br><span class="line">        //还需要的元素个数为: k - path.size();</span><br><span class="line">        //在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</span><br><span class="line">        //为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</span><br><span class="line">        for(int i=split;i&lt;=n - (k - path.size()) + 1;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            dfs(n,k,i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//LC216</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        dfs(k,n,1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //可以去掉sum，用n-i，最后n==0存储</span><br><span class="line">    public void dfs(int k,int n,int split)&#123;</span><br><span class="line">        //剪枝</span><br><span class="line">        if(n&lt;0)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(path.size()==k)&#123;</span><br><span class="line">            if(n==0)&#123;res.add(new ArrayList&lt;&gt;(path));&#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //剪枝，9-(k-path.size())+1</span><br><span class="line">        for(int i=split;i&lt;=9-(k-path.size())+1;i++)&#123;</span><br><span class="line">            n-=i;</span><br><span class="line">            path.add(i);</span><br><span class="line">            dfs(k,n,i+1);</span><br><span class="line">            //回溯</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">            n+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>这道题的难点如下：<br>1.数字和字母如何映射<br>    这里可以用数组下边与字母一一对应来映射。<br>    String[] numString={“”,””,”abc”,”def”,”ghi”,”jkl”,”mno”,”pqrs”,”tuv”,”wxyz”};</p><p>2.两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来，所以我们要用回溯算法。</p><p>3.输入1 * #按键等等异常情况</p><ul><li><p>就是用str.charAt(i)的码值减去‘0’的码值，得到的值干好就是s中第i个字符的十进制值。</p></li><li><p>StringBuffer<br>  StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。</p></li><li><p>StringBuilder<br>  StringBuilder类也代表可变字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//LC17</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">    String[] numString=&#123;&quot;&quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;;</span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        if(digits == null || digits.length() == 0) &#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(digits,0);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    //每次迭代获取一个字符串，所以会涉及大量的字符串拼接，所以这里选择更为高效的 StringBuild</span><br><span class="line">    StringBuilder temp=new StringBuilder();</span><br><span class="line">    public void dfs(String digits, int num) &#123;</span><br><span class="line">        if(num == digits.length())&#123;</span><br><span class="line">            list.add(temp.toString());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String str = numString[digits.charAt(num)-&#x27;0&#x27;];</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            temp.append(str.charAt(i));</span><br><span class="line">            dfs(digits, num + 1);</span><br><span class="line">            temp.deleteCharAt(temp.length()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>注意这里有个剪枝条件是target - candidates[i] &gt;= 0，它意味着如果不符合此条件，这次for循环会终止，进入下一次for循环，也就是说，这次for循环里的深度遍历不会进行下去，这次for循环中candidates[i]之后的数也不会去进行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//LC39</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates); // 先进行排序</span><br><span class="line">        dfs(candidates, target, 0);</span><br><span class="line">        return res; </span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int[] candidates, int target,int start)&#123;</span><br><span class="line">        // if(target&lt;0)&#123;</span><br><span class="line">        //     return;</span><br><span class="line">        // &#125;</span><br><span class="line">        if(target==0)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = start; i &lt; candidates.length &amp;&amp; target - candidates[i] &gt;= 0; i++)&#123;</span><br><span class="line">            // if (target - candidates[i] &lt; 0) &#123;break;&#125;</span><br><span class="line">            // target -= candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            //注意对target的操作在递归的形参里。</span><br><span class="line">            dfs(candidates,target - candidates[i],i);</span><br><span class="line">            // target += candidates[i];</span><br><span class="line">            path.remove(path.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>LC40与LC39相似，但区别在于：集合（数组candidates）有重复元素，但还不能有重复的组合。用set或者map去重很容易超时。<br>所谓去重，其实就是使用过的元素不能重复选取，都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<br>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。</strong><br>所以此题还需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。</p><p>这个集合去重的重任就是used来完成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//LC40</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">    int sum=0;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        boolean[] flag = new boolean[candidates.length];</span><br><span class="line">        dfs(candidates, target, 0, flag);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] arr, int target, int index, boolean[] flag) &#123;</span><br><span class="line">        if(sum==target)&#123;</span><br><span class="line">            res.add(new ArrayList(deque));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; arr.length &amp;&amp; arr[i] + sum &lt;= target; i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; arr[i] == arr[i-1] &amp;&amp; !flag[i-1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[i] = true;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            deque.push(arr[i]);</span><br><span class="line">            dfs(arr,target, i + 1, flag);</span><br><span class="line">            int temp = deque.pop();</span><br><span class="line">            flag[i] = false;</span><br><span class="line">            sum -= temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分割回文字符串"><a href="#分割回文字符串" class="headerlink" title="分割回文字符串"></a>分割回文字符串</h2><p>这道题的难点是，如何分割字符串，之后在判断是否是回文字符串。判断回文字符串一个函数即可完成，如何全面的分割字符串才是难题。<br>看到题目的第一个思路可能就是用for循环再用双指针去切割，双指针的确是解决本问题的关键。<br>在前面的回溯算法中其实可以发现，回溯算法本质上还是简化循环的算法。那么本题也可以用回溯算法去实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//LC131</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        dfs(s, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //index是分割线</span><br><span class="line">    public void dfs(String s, int index) &#123;</span><br><span class="line">        //终止条件为分割线越过最后一个字符</span><br><span class="line">        if(index &gt;= s.length()) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=index; i&lt;s.length(); i++) &#123;</span><br><span class="line">            if(isbool(s, index, i))&#123;</span><br><span class="line">                path.add(s.substring(index,i+1));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dfs(s, i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isbool(String s, int left, int right) &#123;</span><br><span class="line">        for(int i=left, j=right; i&lt;=j; i++,j--) &#123;</span><br><span class="line">            if(s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line"></span><br><span class="line">        if(s.length()&gt;12)&#123;return res;&#125;//剪枝</span><br><span class="line">        dfs(s,0,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //start: 搜索的起始位置， pointNum:添加逗点的数量</span><br><span class="line">    public void dfs(String s, int start, int pointNum)&#123;</span><br><span class="line">        //终止条件 逗号数为3。要验证一下最后一组数是否符合条件</span><br><span class="line">        if(pointNum==3)&#123;</span><br><span class="line">            if(isValid(s, start, s.length()-1))&#123;</span><br><span class="line">                res.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            return;  </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=start; i&lt;s.length(); i++)&#123;</span><br><span class="line">            if(isValid(s, start, i))&#123;</span><br><span class="line">                s=s.substring(0, i+1)+&quot;.&quot;+s.substring(i+1);</span><br><span class="line">                pointNum++;</span><br><span class="line">                dfs(s, i+2,pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2</span><br><span class="line">                pointNum--; </span><br><span class="line">                s= s.substring(0,i+1)+s.substring(i+2);// 回溯删掉逗点</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean isValid(String s, int l, int r)&#123;</span><br><span class="line">        if(l&gt;r)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //0开头返回false</span><br><span class="line">        if(s.charAt(l)==&#x27;0&#x27; &amp;&amp; l!=r)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int num=0;</span><br><span class="line">        //左闭右闭</span><br><span class="line">        for(int i=l; i&lt;=r; i++)&#123;</span><br><span class="line">            if(s.charAt(i)&gt;&#x27;9&#x27; || s.charAt(i)&lt;&#x27;0&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            num=num*10+(s.charAt(i)-&#x27;0&#x27;);</span><br><span class="line">            if(num&gt;255)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>把回溯算法模拟成树模型的话，组合问题就是收集树的所有叶子节点，而子集问题，就是收集树的所有节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//LC78</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; one=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;());</span><br><span class="line">        dfs(nums,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] nums,int start)&#123;</span><br><span class="line">        if(start&gt;=nums.length)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=start; i&lt;nums.length; i++)&#123;</span><br><span class="line">            one.add(nums[i]);</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(one));</span><br><span class="line">            dfs(nums,i+1);</span><br><span class="line">            one.remove(one.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><p>难点还是去重问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//LC90</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    boolean[] used;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;());</span><br><span class="line">        </span><br><span class="line">        used = new boolean[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] nums, int start)&#123;</span><br><span class="line">        //终止条件</span><br><span class="line">        if(start&gt;=nums.length)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=start; i&lt;nums.length; i++)&#123;</span><br><span class="line">            //如果是同一树层的则continue</span><br><span class="line">            if(i&gt;0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !used[i-1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            used[i]=true;</span><br><span class="line">            dfs(nums, i+1);</span><br><span class="line">            used[i]=false;</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>可以看成是子集问题的变类，也同样需要去重,而本题求自增子序列，是不能对原数组经行排序的，排完序的数组都是自增子序列了。所以不能使用之前的去重逻辑！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//LC491</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        dfs(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] nums,int strat)&#123;</span><br><span class="line">        //这个终止条件不加也可以，不会无限递归</span><br><span class="line">        if(strat&gt;=nums.length)&#123;return;&#125;</span><br><span class="line">        int[] used=new int[201];</span><br><span class="line">        for(int i=strat; i&lt;nums.length; i++)&#123;</span><br><span class="line">            //若下一个数比path中的最后一个数小，或者同层相同（同层去重），结束本次循环</span><br><span class="line">            //used记录本层元素是否重复使用，新的一层used都会重新定义（清空），所以要知道uset只负责本层！</span><br><span class="line">            if(!path.isEmpty() &amp;&amp; nums[i]&lt;path.get(path.size()-1) || used[nums[i]+100]==1)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            if(path.size()&gt;=2)&#123;</span><br><span class="line">                res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            used[nums[i]+100] = 1;</span><br><span class="line">            dfs(nums, i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><em>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//LC46</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    boolean[] used;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        boolean[] used=new boolean[nums.length];</span><br><span class="line">        dfs(nums, used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int[] nums, boolean[] used)&#123;</span><br><span class="line">        //终止条件,此题不加也可以</span><br><span class="line">        if(path.size()==nums.length)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(used[i]==true)&#123;continue;&#125;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            // if(path.size()==nums.length)&#123;</span><br><span class="line">            //     res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            // &#125;</span><br><span class="line">            </span><br><span class="line">            used[i]=true;</span><br><span class="line">            dfs(nums, used);</span><br><span class="line">            used[i]=false;</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列-1"><a href="#全排列-1" class="headerlink" title="全排列"></a>全排列</h2><p><em>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//同树层去重记得要排序</span><br><span class="line">//LC47</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        boolean[] used=new boolean[nums.length];</span><br><span class="line">        dfs(nums,used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] nums, boolean[] used)&#123;</span><br><span class="line">        if(path.size()==nums.length)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            //同树层去重</span><br><span class="line">            if(i&gt;0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; used[i-1]==false)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(used[i]==false)&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i]=true;</span><br><span class="line">                dfs(nums,used);</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">                used[i]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">332.重新安排行程</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//LC332</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private Deque&lt;String&gt; res;</span><br><span class="line">    private Map&lt;String, Map&lt;String, Integer&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    private boolean backTracking(int ticketNum)&#123;</span><br><span class="line">        if(res.size() == ticketNum + 1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        String last = res.getLast();</span><br><span class="line">        if(map.containsKey(last))&#123;//防止出现null</span><br><span class="line">            for(Map.Entry&lt;String, Integer&gt; target : map.get(last).entrySet())&#123;</span><br><span class="line">                int count = target.getValue();</span><br><span class="line">                if(count &gt; 0)&#123;</span><br><span class="line">                    res.add(target.getKey());</span><br><span class="line">                    target.setValue(count - 1);</span><br><span class="line">                    if(backTracking(ticketNum)) return true;</span><br><span class="line">                    res.removeLast();</span><br><span class="line">                    target.setValue(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;</span><br><span class="line">        map = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">        res = new LinkedList&lt;&gt;();</span><br><span class="line">        for(List&lt;String&gt; t : tickets)&#123;</span><br><span class="line">            Map&lt;String, Integer&gt; temp;</span><br><span class="line">            if(map.containsKey(t.get(0)))&#123;</span><br><span class="line">                temp = map.get(t.get(0));</span><br><span class="line">                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp = new TreeMap&lt;&gt;();//升序Map</span><br><span class="line">                temp.put(t.get(1), 1);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(t.get(0), temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        res.add(&quot;JFK&quot;);</span><br><span class="line">        backTracking(tickets.size());</span><br><span class="line">        return new ArrayList&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p><a href="https://leetcode-cn.com/problems/n-queens/">51.N皇后</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//LC51</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        char[][] arr=new char[n][n];</span><br><span class="line">        for(char[] item : arr)&#123;</span><br><span class="line">            Arrays.fill(item,&#x27;.&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(n,0,arr);</span><br><span class="line">        return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void dfs(int n, int row, char[][] arr)&#123;</span><br><span class="line">        if(n==row)&#123;</span><br><span class="line">            res.add(Array2List(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int col = 0;col &lt; n; ++col) &#123;</span><br><span class="line">            if (isVaild (row, col, n, arr)) &#123;</span><br><span class="line">                arr[row][col] = &#x27;Q&#x27;;</span><br><span class="line">                dfs(n, row+1, arr);</span><br><span class="line">                arr[row][col] = &#x27;.&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List Array2List(char[][] chessboard) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (char[] c : chessboard) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isVaild(int row, int col, int n, char[][] arr)&#123;</span><br><span class="line">        //同列</span><br><span class="line">        for(int i=0; i&lt;row; i++)&#123;</span><br><span class="line">            if(arr[i][col]==&#x27;Q&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //45度</span><br><span class="line">        for(int i=row-1, j=col-1; i&gt;=0&amp;&amp;j&gt;=0; i--,j--)&#123;</span><br><span class="line">            if(arr[i][j]==&#x27;Q&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //135度,右上角</span><br><span class="line">        for(int i=row-1, j=col+1; i&gt;=0 &amp;&amp; j&lt;=n-1; i--,j++)&#123;</span><br><span class="line">            if(arr[i][j]==&#x27;Q&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">37.解数独</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void solveSudoku(char[][] board) &#123;</span><br><span class="line">        solveSudokuHelper(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean solveSudokuHelper(char[][] board)&#123;</span><br><span class="line">        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，</span><br><span class="line">        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」</span><br><span class="line">        for (int i = 0; i &lt; 9; i++)&#123; // 遍历行</span><br><span class="line">            for (int j = 0; j &lt; 9; j++)&#123; // 遍历列</span><br><span class="line">                if (board[i][j] != &#x27;.&#x27;)&#123; // 跳过原始数字</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for (char k = &#x27;1&#x27;; k &lt;= &#x27;9&#x27;; k++)&#123; // (i, j) 这个位置放k是否合适</span><br><span class="line">                    if (isValidSudoku(i, j, k, board))&#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        if (solveSudokuHelper(board))&#123; // 如果找到合适一组立刻返回</span><br><span class="line">                            return true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 9个数都试完了，都不行，那么就返回false</span><br><span class="line">                return false;</span><br><span class="line">                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！</span><br><span class="line">                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历完没有返回false，说明找到了合适棋盘位置了</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断棋盘是否合法有如下三个维度:</span><br><span class="line">     *     同行是否重复</span><br><span class="line">     *     同列是否重复</span><br><span class="line">     *     9宫格里是否重复</span><br><span class="line">     */</span><br><span class="line">    private boolean isValidSudoku(int row, int col, char val, char[][] board)&#123;</span><br><span class="line">        // 同行是否重复</span><br><span class="line">        for (int i = 0; i &lt; 9; i++)&#123;</span><br><span class="line">            if (board[row][i] == val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同列是否重复</span><br><span class="line">        for (int j = 0; j &lt; 9; j++)&#123;</span><br><span class="line">            if (board[j][col] == val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 9宫格里是否重复</span><br><span class="line">        int startRow = (row / 3) * 3;</span><br><span class="line">        int startCol = (col / 3) * 3;</span><br><span class="line">        for (int i = startRow; i &lt; startRow + 3; i++)&#123;</span><br><span class="line">            for (int j = startCol; j &lt; startCol + 3; j++)&#123;</span><br><span class="line">                if (board[i][j] == val)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;回溯算法模板&quot;&gt;&lt;a href=&quot;#回溯算法模板&quot; class=&quot;headerlink&quot; title=&quot;回溯算法模板&quot;&gt;&lt;/a&gt;回溯算法模板&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void backtracking(参数) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (终止条件) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        存放结果;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        处理节点;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        backtracking(路径，选择列表); // 递归&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        回溯，撤销处理结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="代码" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="回溯算法" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP&amp;request&amp;response</title>
    <link href="http://example.com/2021/08/29/HTTP-request-response/"/>
    <id>http://example.com/2021/08/29/HTTP-request-response/</id>
    <published>2021-08-29T01:55:12.000Z</published>
    <updated>2021-08-29T02:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h1><h2 id="概念：Hyper-Text-Transfer-Protocol-超文本传输协议"><a href="#概念：Hyper-Text-Transfer-Protocol-超文本传输协议" class="headerlink" title="概念：Hyper Text Transfer Protocol 超文本传输协议"></a>概念：Hyper Text Transfer Protocol 超文本传输协议</h2><span id="more"></span><pre><code>    * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式    * 特点：        1. 基于TCP/IP的高级协议        2. 默认端口号:80        3. 基于请求/响应模型的:一次请求对应一次响应        4. 无状态的：每次请求之间相互独立，不能交互数据    * 历史版本：        * 1.0：每一次请求响应都会建立新的连接        * 1.1：复用连接</code></pre><h2 id="请求消息：客户端发送给服务器端的数据"><a href="#请求消息：客户端发送给服务器端的数据" class="headerlink" title="请求消息：客户端发送给服务器端的数据"></a>请求消息：客户端发送给服务器端的数据</h2><pre><code>* 数据格式：    1. 请求行        请求方式 请求url 请求协议/版本        GET /login.html    HTTP/1.1        * 请求方式：            * HTTP协议有7中请求方式，常用的有2种                * GET：                    1. 请求参数在请求行中，在url后。                    2. 请求的url长度有限制的                    3. 不太安全                * POST：                    1. 请求参数在请求体中                    2. 请求的url长度没有限制的                    3. 相对安全    2. 请求头：客户端浏览器告诉服务器一些信息        请求头名称: 请求头值        * 常见的请求头：            1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息                * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题            2. Referer：http://localhost/login.html                * 告诉服务器，我(当前请求)从哪里来？                    * 作用：                        1. 防盗链：                        2. 统计工作：    3. 请求空行        空行，就是用于分割POST请求的请求头，和请求体的。    4. 请求体(正文)：        * 封装POST请求消息的请求参数的    * 字符串格式：        POST /login.html    HTTP/1.1        Host: localhost        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8        Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2        Accept-Encoding: gzip, deflate        Referer: http://localhost/login.html        Connection: keep-alive        Upgrade-Insecure-Requests: 1                username=zhangsan    </code></pre><h2 id="响应消息：服务器端发送给客户端的数据"><a href="#响应消息：服务器端发送给客户端的数据" class="headerlink" title="响应消息：服务器端发送给客户端的数据"></a>响应消息：服务器端发送给客户端的数据</h2><pre><code>    * 数据格式：        1. 响应行            1. 组成：协议/版本 响应状态码 状态码描述            2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。                1. 状态码都是3位数字                 2. 分类：                    1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码                    2. 2xx：成功。代表：200                    3. 3xx：重定向。代表：302(重定向)，304(访问缓存)                    4. 4xx：客户端错误。                        * 代表：                            * 404（请求路径没有对应的资源）                             * 405：请求方式没有对应的doXxx方法                    5. 5xx：服务器端错误。代表：500(服务器内部出现异常)                                                2. 响应头：            1. 格式：头名称： 值            2. 常见的响应头：                1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式                2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据                    * 值：                        * in-line:默认值,在当前页面内打开                        * attachment;filename=xxx：以附件形式打开响应体。文件下载        3. 响应空行        4. 响应体:传输的数据    * 响应字符串格式        HTTP/1.1 200 OK        Content-Type: text/html;charset=UTF-8        Content-Length: 101        Date: Wed, 06 Jun 2018 07:08:42 GMT        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;$Title$&lt;/title&gt;          &lt;/head&gt;          &lt;body&gt;          hello , response          &lt;/body&gt;        &lt;/html&gt;</code></pre><h1 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h1><h2 id="request对象和response对象的原理"><a href="#request对象和response对象的原理" class="headerlink" title="request对象和response对象的原理"></a>request对象和response对象的原理</h2><pre><code>    1. request和response对象是由服务器创建的。我们来使用它们    2. request对象是来获取请求消息，response对象是来设置响应消息</code></pre><h2 id="request对象继承体系结构："><a href="#request对象继承体系结构：" class="headerlink" title="request对象继承体系结构："></a>request对象继承体系结构：</h2><pre><code>    ServletRequest        --    接口        |    继承    HttpServletRequest    -- 接口        |    实现    org.apache.catalina.connector.RequestFacade 类(tomcat)</code></pre><h2 id="request功能："><a href="#request功能：" class="headerlink" title="request功能："></a>request功能：</h2><pre><code>    1. 获取请求消息数据        1. 获取请求行数据            * GET /day14/demo1?name=zhangsan HTTP/1.1            * 方法：                1. 获取请求方式 ：GET                    * String getMethod()                  2. (*)获取虚拟目录：/day14                    * String getContextPath()                3. 获取Servlet路径: /demo1                    * String getServletPath()                4. 获取get方式请求参数：name=zhangsan                    * String getQueryString()                5. (*)获取请求URI：/day14/demo1                    * String getRequestURI():        /day14/demo1                    * StringBuffer getRequestURL()  :http://localhost/day14/demo1                    * URL:统一资源定位符 ： http://localhost/day14/demo1    中华人民共和国                    * URI：统一资源标识符 : /day14/demo1                    共和国                                6. 获取协议及版本：HTTP/1.1                    * String getProtocol()                7. 获取客户机的IP地址：                    * String getRemoteAddr()                        2. 获取请求头数据            * 方法：                * (*)String getHeader(String name):通过请求头的名称获取请求头的值                * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称                    3. 获取请求体数据:            * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数            * 步骤：                1. 获取流对象                    *  BufferedReader getReader()：获取字符输入流，只能操作字符数据                    *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据                        * 在文件上传知识点后讲解                2. 再从流对象中拿数据                        </code></pre><h2 id="其他功能："><a href="#其他功能：" class="headerlink" title="其他功能："></a>其他功能：</h2><pre><code>        1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数            1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123            2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game            3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称            4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合            * 中文乱码问题：                * get方式：tomcat 8 已经将get方式乱码问题解决了                * post方式：会乱码                    * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);                                2. 请求转发：一种在服务器内部的资源跳转方式            1. 步骤：                1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)                2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)             2. 特点：                1. 浏览器地址栏路径不发生变化                2. 只能转发到当前服务器内部资源中。                3. 转发是一次请求        3. 共享数据：            * 域对象：一个有作用范围的对象，可以在范围内共享数据            * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据            * 方法：                1. void setAttribute(String name,Object obj):存储数据                2. Object getAttitude(String name):通过键获取值                3. void removeAttribute(String name):通过键移除键值对        4. 获取ServletContext：            * ServletContext getServletContext()        </code></pre><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><h2 id="功能：设置响应消息"><a href="#功能：设置响应消息" class="headerlink" title="功能：设置响应消息"></a>功能：设置响应消息</h2><pre><code>    1. 设置响应行        1. 格式：HTTP/1.1 200 ok        2. 设置状态码：setStatus(int sc)     2. 设置响应头：setHeader(String name, String value)             3. 设置响应体：        * 使用步骤：            1. 获取输出流                * 字符输出流：PrintWriter getWriter()                * 字节输出流：ServletOutputStream getOutputStream()            2. 使用输出流，将数据输出到客户端浏览器</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><h3 id="完成重定向"><a href="#完成重定向" class="headerlink" title="完成重定向"></a>完成重定向</h3><pre><code>        * 重定向：资源跳转的方式        * 代码实现：            //1. 设置状态码为302            response.setStatus(302);            //2.设置响应头location            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);            //简单的重定向方法            response.sendRedirect(&quot;/day15/responseDemo2&quot;);        * 重定向的特点:redirect            1. 地址栏发生变化            2. 重定向可以访问其他站点(服务器)的资源            3. 重定向是两次请求。不能使用request对象来共享数据        * 转发的特点：forward            1. 转发地址栏路径不变            2. 转发只能访问当前服务器下的资源            3. 转发是一次请求，可以使用request对象来共享数据                * forward 和  redirect 区别                    * 路径写法：            1. 路径分类                1. 相对路径：通过相对路径不可以确定唯一资源                    * 如：./index.html                    * 不以/开头，以.开头路径                    * 规则：找到当前资源和目标资源之间的相对位置关系                        * ./：当前目录                        * ../:后退一级目录                2. 绝对路径：通过绝对路径可以确定唯一资源                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2                    * 以/开头的路径                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)                            * 建议虚拟目录动态获取：request.getContextPath()                            * &lt;a&gt; , &lt;form&gt; 重定向...                        * 给服务器使用：不需要加虚拟目录                            * 转发路径                                                                    </code></pre><h3 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h3><pre><code>        * 步骤：            1. 获取字符输出流            2. 输出数据        * 注意：            * 乱码问题：                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1                2. 设置该流的默认编码                3. 告诉浏览器响应体使用的编码                //简单的形式，设置编码，是在获取流之前设置                response.setContentType(&quot;text/html;charset=utf-8&quot;);    3. 服务器输出字节数据到浏览器        * 步骤：            1. 获取字节输出流            2. 输出数据    4. 验证码        1. 本质：图片        2. 目的：防止恶意表单注册</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HTTP：&quot;&gt;&lt;a href=&quot;#HTTP：&quot; class=&quot;headerlink&quot; title=&quot;HTTP：&quot;&gt;&lt;/a&gt;HTTP：&lt;/h1&gt;&lt;h2 id=&quot;概念：Hyper-Text-Transfer-Protocol-超文本传输协议&quot;&gt;&lt;a href=&quot;#概念：Hyper-Text-Transfer-Protocol-超文本传输协议&quot; class=&quot;headerlink&quot; title=&quot;概念：Hyper Text Transfer Protocol 超文本传输协议&quot;&gt;&lt;/a&gt;概念：Hyper Text Transfer Protocol 超文本传输协议&lt;/h2&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://example.com/2021/08/16/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/08/16/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-08-16T14:13:46.000Z</published>
    <updated>2021-09-15T01:28:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归算法模板"><a href="#递归算法模板" class="headerlink" title="递归算法模板"></a>递归算法模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 dfs(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return 返回值类型;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    每层递归的逻辑</span><br><span class="line">    dfs(下层递归的参数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>以下代码绝大多数来自于 <em>代码随想录</em>，代码只为个人学习与总结</p><h1 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h1> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line">  TreeNode() &#123;&#125;</span><br><span class="line">  TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">  TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">    this.left = left;</span><br><span class="line">    this.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC144</span><br><span class="line">class Solution &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; preOrderReverse(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void preOrder(TreeNode root, ArrayList&lt;Integer&gt; result) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val); </span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC94</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val); </span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC145</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h2><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC144</span><br><span class="line">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.right != null)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left != null)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC94</span><br><span class="line">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        while (cur != null || !stack.isEmpty())&#123;</span><br><span class="line">           if (cur != null)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC145</span><br><span class="line">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.left != null)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一遍历"><a href="#统一遍历" class="headerlink" title="统一遍历"></a>统一遍历</h2><p>迭代法前中后序遍历的统一模板，逻辑相似，只需要修改代码的顺序。</p><h3 id="前序遍历-2"><a href="#前序遍历-2" class="headerlink" title="前序遍历"></a>前序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC144</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode node = st.peek();</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br><span class="line">                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）</span><br><span class="line">                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）</span><br><span class="line">                st.push(node);                          // 添加中节点</span><br><span class="line">                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集</span><br><span class="line">                st.pop();           // 将空节点弹出</span><br><span class="line">                node = st.peek();    // 重新取出栈中元素</span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); // 加入到结果集</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC94</span><br><span class="line">class Solution &#123;</span><br><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();</span><br><span class="line">    if (root != null) st.push(root);</span><br><span class="line">    while (!st.empty()) &#123;</span><br><span class="line">        TreeNode node = st.peek();</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br><span class="line">            if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）</span><br><span class="line">            st.push(node);                          // 添加中节点</span><br><span class="line">            st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><span class="line"></span><br><span class="line">            if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）</span><br><span class="line">        &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集</span><br><span class="line">            st.pop();           // 将空节点弹出</span><br><span class="line">            node = st.peek();    // 重新取出栈中元素</span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); // 加入到结果集</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历-2"><a href="#后序遍历-2" class="headerlink" title="后序遍历"></a>后序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC145</span><br><span class="line">class Solution &#123;</span><br><span class="line">   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode node = st.peek();</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br><span class="line">                st.push(node);                          // 添加中节点</span><br><span class="line">                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><span class="line">                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）</span><br><span class="line">                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）         </span><br><span class="line">                               </span><br><span class="line">            &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集</span><br><span class="line">                st.pop();           // 将空节点弹出</span><br><span class="line">                node = st.peek();    // 重新取出栈中元素</span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); // 加入到结果集</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>层序遍历模板<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 102.二叉树的层序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        //checkFun01(root,0);</span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        return resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //DFS--递归方式</span><br><span class="line">    public void checkFun01(TreeNode node, Integer deep) &#123;</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        if (resList.size() &lt; deep) &#123;</span><br><span class="line">            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span><br><span class="line">            List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - 1).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //BFS--迭代方式--借助队列</span><br><span class="line">    public void checkFun02(TreeNode node) &#123;</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        while (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            int len = que.size();</span><br><span class="line"></span><br><span class="line">            while (len &gt; 0) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                if (tmpNode.left != null) que.offer(tmpNode.left);</span><br><span class="line">                if (tmpNode.right != null) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//DFS递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">   /**</span><br><span class="line">     * 前后序遍历都可以</span><br><span class="line">     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）</span><br><span class="line">     */</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        swapChildren(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swapChildren(TreeNode root) &#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;return null;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        while (!deque.isEmpty()) &#123;</span><br><span class="line">            int size = deque.size();</span><br><span class="line">            while (size-- &gt; 0) &#123;</span><br><span class="line">                TreeNode node = deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                if (node.left != null) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                if (node.right != null) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swap(TreeNode root) &#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p>以二叉树的遍历为基础，只是处理节点的顺序从两侧外开始逐渐靠内。主要难点在于确定所有不对称的条件。</p><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        return compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean compare(TreeNode left,TreeNode right)&#123;</span><br><span class="line">        //循环终止条件为两节点不对称以及两节点为空</span><br><span class="line">        if(left==null&amp;&amp;right==null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left==null &amp;&amp; right!=null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left!=null &amp;&amp; right==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left.val!=right.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        boolean outside= compare(left.left,right.right);</span><br><span class="line">        boolean inside= compare(left.right,right.left);</span><br><span class="line">        //外侧内侧皆相同即true</span><br><span class="line">        return outside &amp;&amp; inside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>与层序遍历不同，判断对称并不需要确定节点属于哪一层，只要按一定顺序将它们输入队列即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; que=new LinkedList&lt;&gt;();</span><br><span class="line">        que.offer(root.left);</span><br><span class="line">        que.offer(root.right);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            TreeNode left=que.poll();</span><br><span class="line">            TreeNode right=que.poll();</span><br><span class="line">            if(left==null &amp;&amp; right==null)&#123;//左右节点为空时对称</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //左右节点只有一个为0，或者左右节点值不相同则不对称</span><br><span class="line">            if(left==null || right==null || left.val!=right.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            que.offer(left.left);</span><br><span class="line">            que.offer(right.right);</span><br><span class="line">            que.offer(left.right);</span><br><span class="line">            que.offer(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><h2 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//前序遍历 递归求深度</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;return 0;&#125;</span><br><span class="line">        int left=maxDepth(root.left);</span><br><span class="line">        int right=maxDepth(root.right);</span><br><span class="line">        return Math.max(left,right)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">       if(root==null)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; que=new LinkedList&lt;&gt;();</span><br><span class="line">       que.offer(root);</span><br><span class="line">       int depth=0;</span><br><span class="line">       while(!que.isEmpty())&#123;</span><br><span class="line">           int size=que.size();</span><br><span class="line">           depth++;</span><br><span class="line">           while(size&gt;0)&#123;</span><br><span class="line">               TreeNode poll=que.poll();</span><br><span class="line">               if(poll.left!=null)&#123;</span><br><span class="line">                   que.offer(poll.left);</span><br><span class="line">               &#125;</span><br><span class="line">               if(poll.right!=null)&#123;</span><br><span class="line">                   que.offer(poll.right);</span><br><span class="line">               &#125;</span><br><span class="line">               size--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><h2 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h2><p>与最大深度类似，但要注意最小深度是从根节点到最近叶子节点的最短路径上的节点数量。没有子节点才是叶子节点，遍历到某个只有一个子节点的节点可能会错误判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//为了找到没有子节点的节点，这里对只有一个子节点的节点进行判断</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=minDepth(root.left);</span><br><span class="line">        int right=minDepth(root.right);</span><br><span class="line">        if(root.left==null)&#123;return right+1;&#125;</span><br><span class="line">        if(root.right==null)&#123;return left+1;&#125;</span><br><span class="line">        return Math.min(left,right)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//深度理解为层序遍历的层数</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">       if(root==null)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; que=new LinkedList&lt;&gt;();</span><br><span class="line">       que.offer(root);</span><br><span class="line">       int depth=0;</span><br><span class="line">       while(!que.isEmpty())&#123;</span><br><span class="line">           int size=que.size();</span><br><span class="line">           depth++;</span><br><span class="line">           while(size&gt;0)&#123;</span><br><span class="line">               TreeNode poll=que.poll();</span><br><span class="line">//poll为叶子节点则返回深度</span><br><span class="line">               if(poll.left==null &amp;&amp; poll.right==null)&#123;</span><br><span class="line">                   return depth;</span><br><span class="line">               &#125;</span><br><span class="line">               if(poll.left!=null)&#123;</span><br><span class="line">                   que.offer(poll.left);</span><br><span class="line">               &#125;</span><br><span class="line">               if(poll.right!=null)&#123;</span><br><span class="line">                   que.offer(poll.right);</span><br><span class="line">               &#125;</span><br><span class="line">               size--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全二叉树的最小个数"><a href="#完全二叉树的最小个数" class="headerlink" title="完全二叉树的最小个数"></a>完全二叉树的最小个数</h1><h2 id="递归法-3"><a href="#递归法-3" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=countNodes(root.left);</span><br><span class="line">        int right=countNodes(root.right);</span><br><span class="line">        return left+right+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全二叉树的做法"><a href="#完全二叉树的做法" class="headerlink" title="完全二叉树的做法"></a>完全二叉树的做法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 满二叉树的结点数为：2^depth - 1</span><br><span class="line">     */</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftDepth = getDepth(root.left);</span><br><span class="line">        int rightDepth = getDepth(root.right);</span><br><span class="line">        if (leftDepth == rightDepth) &#123;// 左子树是满二叉树</span><br><span class="line">            // 2^leftDepth其实是 （2^leftDepth - 1） + 1 ，左子树 + 根结点</span><br><span class="line">            return (1 &lt;&lt; leftDepth) + countNodes(root.right);</span><br><span class="line">        &#125; else &#123;// 右子树是满二叉树</span><br><span class="line">            return (1 &lt;&lt; rightDepth) + countNodes(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getDepth(TreeNode root) &#123;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        while (root != null) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="判断是否为平衡二叉树"><a href="#判断是否为平衡二叉树" class="headerlink" title="判断是否为平衡二叉树"></a>判断是否为平衡二叉树</h1><h2 id="递归法-4"><a href="#递归法-4" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        return getDepth(root)!=-1;</span><br><span class="line">    &#125;</span><br><span class="line">//不为平衡二叉树返回-1</span><br><span class="line">    public int getDepth(TreeNode node)&#123;</span><br><span class="line">        if(node==null)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=getDepth(node.left);</span><br><span class="line">        if(left==-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int right=getDepth(node.right);</span><br><span class="line">        if(right==-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(Math.abs(left-right)&gt;1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return Math.max(left,right)+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找二叉树的所有路径"><a href="#查找二叉树的所有路径" class="headerlink" title="查找二叉树的所有路径"></a>查找二叉树的所有路径</h1><h2 id="递归法-5"><a href="#递归法-5" class="headerlink" title="递归法"></a>递归法</h2><p>思路是递归回溯，每一次回溯之后删除末尾节点有些像全排列的感觉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        List&lt;String&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">        if(res==null)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path =new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,path,res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode node,List&lt;Integer&gt; path ,List&lt;String&gt; res)&#123;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        StringBuilder sb=new StringBuilder();</span><br><span class="line">        if(node.left==null &amp;&amp; node.right==null)&#123;</span><br><span class="line">            for(int i=0;i&lt;path.size()-1;i++)&#123;</span><br><span class="line">                sb.append(path.get(i)).append(&quot;-&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(path.get(path.size()-1));</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.left!=null)&#123;</span><br><span class="line">            dfs(node.left,path,res);</span><br><span class="line">            path.remove(path.size()-1);//删除末位节点</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right!=null)&#123;</span><br><span class="line">            dfs(node.right,path,res);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的左叶子节点之和"><a href="#二叉树的左叶子节点之和" class="headerlink" title="二叉树的左叶子节点之和"></a>二叉树的左叶子节点之和</h1><h2 id="递归法-6"><a href="#递归法-6" class="headerlink" title="递归法"></a>递归法</h2><p>左叶子节点的判断方法是，该节点是父节点的左节点，且该节点没有子节点。<br>根据二叉树的特点，指针指在子节点时是无法回到父节点判断自己是否为左子节点，所以要从父节点就开始判断它的左子节点是否为叶子节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=sumOfLeftLeaves(root.left);</span><br><span class="line">        int right=sumOfLeftLeaves(root.right);</span><br><span class="line"></span><br><span class="line">        int count=0;</span><br><span class="line">        if(root.left!=null &amp;&amp; root.left.left==null &amp;&amp; root.left.right==null)&#123;</span><br><span class="line">            count=root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        return left+right+count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; st=new Stack&lt;&gt;();</span><br><span class="line">        st.add(root);</span><br><span class="line">        int sum=0;</span><br><span class="line">        while(!st.isEmpty())&#123;</span><br><span class="line">            TreeNode node=st.pop();</span><br><span class="line">            if(node.left!=null &amp;&amp; node.left.left==null &amp;&amp; node.left.right==null)&#123;</span><br><span class="line">                sum+=node.left.val;   </span><br><span class="line">            &#125;</span><br><span class="line">            if(node.left!=null)&#123;st.add(node.left);&#125;</span><br><span class="line">            if(node.right!=null)&#123;st.add(node.right);&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h1><h2 id="迭代法-4"><a href="#迭代法-4" class="headerlink" title="迭代法"></a>迭代法</h2><p>设法找到最后一层的第一个节点，修改一下层序遍历即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; que=new LinkedList&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        int first=0;</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int size=que.size();</span><br><span class="line">            for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode node=que.poll();</span><br><span class="line">                if(i==0)&#123;first=node.val;&#125;</span><br><span class="line">                if(node.left!=null)&#123;que.offer(node.left);&#125;</span><br><span class="line">                if(node.right!=null)&#123;que.offer(node.right);&#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的路径总和"><a href="#二叉树的路径总和" class="headerlink" title="二叉树的路径总和"></a>二叉树的路径总和</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        targetSum-=root.val;</span><br><span class="line">        if(root.left==null &amp;&amp; root.right==null)&#123;</span><br><span class="line">            if(targetSum==0)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.left!=null)&#123;</span><br><span class="line">            boolean left=hasPathSum(root.left,targetSum);</span><br><span class="line">            if(left)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(root.right!=null)&#123;</span><br><span class="line">            boolean right=hasPathSum(root.right,targetSum);</span><br><span class="line">            if(right)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;return res;&#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; path=new LinkedList&lt;&gt;();</span><br><span class="line">        dfs(root,targetSum,res,path);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root,int targetSum,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path)&#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        if(root.left==null &amp;&amp; root.right==null &amp;&amp; targetSum==root.val)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        </span><br><span class="line">        return ;//和不为targetSum,返回</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.left!=null)&#123;</span><br><span class="line">        dfs(root.left,targetSum-root.val,res,path);</span><br><span class="line">        path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.right!=null)&#123;</span><br><span class="line">            dfs(root.right,targetSum-root.val,res,path);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h1><p>通过后序序列的最后一个节点值得到根节点，之后通过它在中序遍历中切割左右子树的中序与后序遍历，在通过递归再次找子树的结构。<br>易错点是，左右子树的区间的端点控制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        return buildTree1(inorder,0,inorder.length,postorder,0,postorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode buildTree1(int[] inorder,int inLeft,int inRight,int[] postorder, int postLeft,int postRight)&#123;</span><br><span class="line">                                    if(inRight-inLeft&lt;1)&#123;</span><br><span class="line">                                        return null;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    if(inRight-inLeft==1)&#123;</span><br><span class="line">                                        return new TreeNode(inorder[inLeft]);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    int rootVal=postorder[postRight-1];</span><br><span class="line">                                    TreeNode root=new TreeNode(rootVal);</span><br><span class="line"></span><br><span class="line">                                    int rootIndex=0;</span><br><span class="line">                                    for(rootIndex=inLeft;rootIndex&lt;inRight;rootIndex++)&#123;</span><br><span class="line">                                        if(inorder[rootIndex]==rootVal)&#123;</span><br><span class="line">                                            break;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    root.left=buildTree1(inorder,inLeft,rootIndex,postorder,postLeft,postLeft+(rootIndex-inLeft));</span><br><span class="line"></span><br><span class="line">                                    root.right=buildTree1(inorder,rootIndex+1,inRight,postorder,postLeft+(rootIndex-inLeft),postRight-1);</span><br><span class="line">                                    return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h1><p>留意区间边界</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//LC654</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;</span><br><span class="line">        return dfs(nums,0,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public TreeNode dfs(int[] nums,int l,int r)&#123;</span><br><span class="line">        if(r-l&lt;1)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(r-l==1)&#123;</span><br><span class="line">            TreeNode node=new TreeNode(nums[l]);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxIndex=l;</span><br><span class="line">        int maxVal=nums[l];</span><br><span class="line">        for(int i=l+1;i&lt;r;i++)&#123;</span><br><span class="line">            if(nums[i]&gt;maxVal)&#123;</span><br><span class="line">                maxVal=nums[i];</span><br><span class="line">                maxIndex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=new TreeNode(maxVal);</span><br><span class="line"></span><br><span class="line">        root.left=dfs(nums,l,maxIndex);</span><br><span class="line">        root.right=dfs(nums,maxIndex+1,r);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><h2 id="迭代法-5"><a href="#迭代法-5" class="headerlink" title="迭代法"></a>迭代法</h2><p>就像迭代法遍历树，这次同时遍历两个树，注意这次的递归终止条件，因为要合并树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if(root1==null)&#123;return root2;&#125;</span><br><span class="line">        if(root2==null)&#123;return root1;&#125;</span><br><span class="line"></span><br><span class="line">        root1.val+=root2.val;</span><br><span class="line">        root1.left=mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right=mergeTrees(root1.right,root2.right);</span><br><span class="line">        return root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索二叉搜索树"><a href="#搜索二叉搜索树" class="headerlink" title="搜索二叉搜索树"></a>搜索二叉搜索树</h1><h2 id="递归法-7"><a href="#递归法-7" class="headerlink" title="递归法"></a>递归法</h2><p>二叉搜索树是一个有序树：</p><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>它的左、右子树也分别为二叉搜索树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//CL700</span><br><span class="line">class Solution &#123;</span><br><span class="line">public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        if(root==null || root.val==val)&#123;return root;&#125;</span><br><span class="line"></span><br><span class="line">        if(val &lt; root.val)&#123;</span><br><span class="line">            return searchBST(root.left,val);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return searchBST(root.right,val);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-6"><a href="#迭代法-6" class="headerlink" title="迭代法"></a>迭代法</h2><p>由于搜索树的特点，搜索时有了方向，不要用栈把所有节点遍历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        while(root!=null)&#123;</span><br><span class="line">            if(val&lt;root.val)&#123;</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;else if(val&gt;root.val)&#123;</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p>这里注意不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。<br><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。</strong></p><h2 id="递归法-8"><a href="#递归法-8" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode max;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        if(root==null)return true;</span><br><span class="line"></span><br><span class="line">        boolean left=isValidBST(root.left);</span><br><span class="line">        if(!left)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //max不为空时，它的值是此次递归的根节点的左子节点，也是上次递归的根节点</span><br><span class="line">        if(max!=null &amp;&amp; root.val&lt;=max.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max=root;</span><br><span class="line"></span><br><span class="line">        boolean right=isValidBST(root.right);</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h1><h2 id="递归法-9"><a href="#递归法-9" class="headerlink" title="递归法"></a>递归法</h2><p>由于二叉搜索树的性质，本质上还是中序遍历，同样迭代法也是在中序遍历的迭代版本，这里就不写了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> //LC530</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int res=Integer.MAX_VALUE;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">        if(root.left!=null)&#123;</span><br><span class="line">            getMinimumDifference(root.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(pre!=null)&#123;</span><br><span class="line">            res=Math.min(res,root.val-pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line"></span><br><span class="line">        if(root.right!=null)&#123;</span><br><span class="line">            getMinimumDifference(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的众数"><a href="#二叉搜索树的众数" class="headerlink" title="二叉搜索树的众数"></a>二叉搜索树的众数</h1><h2 id="递归法-10"><a href="#递归法-10" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> //LC501</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">    int maxcount=0;</span><br><span class="line">    int count=0;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    public int[] findMode(TreeNode root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        int[] res=new int[list.size()];</span><br><span class="line">        //注意i要在循环外声明</span><br><span class="line">        int i=0;</span><br><span class="line">        for(int item:list)&#123;</span><br><span class="line">            res[i++]=item;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        //中序遍历时，都要考虑pre节点是否为空。</span><br><span class="line">        if(pre==null || pre.val!=root.val)&#123;</span><br><span class="line">            count=1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新maxcount，如果count较大说明之前录入的不为众数。之前的数据要清空</span><br><span class="line">        if(count&gt;maxcount)&#123;</span><br><span class="line">            maxcount=count;</span><br><span class="line">            list.clear();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;else if(count==maxcount)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="普通二叉树求众数"><a href="#普通二叉树求众数" class="headerlink" title="普通二叉树求众数"></a>普通二叉树求众数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public int[] findMode(FindModeInBinarySearchTree.TreeNode root) &#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">if (root == null) return list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">// 获得频率 Map</span><br><span class="line">searchBST(root, map);</span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()</span><br><span class="line">.sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line">list.add(mapList.get(0).getKey());</span><br><span class="line">// 把频率最高的加入 list</span><br><span class="line">for (int i = 1; i &lt; mapList.size(); i++) &#123;</span><br><span class="line">if (mapList.get(i).getValue() == mapList.get(i - 1).getValue()) &#123;</span><br><span class="line">list.add(mapList.get(i).getKey());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void searchBST(FindModeInBinarySearchTree.TreeNode curr, Map&lt;Integer, Integer&gt; map) &#123;</span><br><span class="line">if (curr == null) return;</span><br><span class="line">map.put(curr.val, map.getOrDefault(curr.val, 0) + 1);</span><br><span class="line">searchBST(curr.left, map);</span><br><span class="line">searchBST(curr.right, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求二叉树的最近公共祖先"><a href="#求二叉树的最近公共祖先" class="headerlink" title="求二叉树的最近公共祖先"></a>求二叉树的最近公共祖先</h1><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>需要注意的是：</p><ul><li><p>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。</p></li><li><p>在回溯的过程中，必然要遍历整颗二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</p></li><li><p>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//LC236</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        return dfs(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode dfs(TreeNode root,TreeNode p,TreeNode q)&#123;</span><br><span class="line">        //如果某条路线没有找到p或q，到叶子节点后就会向上返回null</span><br><span class="line">        if(root==null || root==p || root==q)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        //后序遍历</span><br><span class="line">        TreeNode left=dfs(root.left,p,q);</span><br><span class="line">        TreeNode right=dfs(root.right,p,q);</span><br><span class="line">        //不为null就为目标结点，此时的root就为公共祖先</span><br><span class="line">        if(left!=null &amp;&amp; right!=null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        //也有可能目标节点都在目前根节点的右子树，当然此次回溯的节点必不为所求得公共祖先了，反之亦然。</span><br><span class="line">        if(left==null)&#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉搜索树的公共祖先"><a href="#二叉搜索树的公共祖先" class="headerlink" title="二叉搜索树的公共祖先"></a>二叉搜索树的公共祖先</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//LC235</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(root.val&gt;p.val &amp;&amp; root.val&gt;q.val)&#123;</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;else if(root.val&lt;p.val &amp;&amp; root.val&lt;q.val)&#123;</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在二叉搜索树中插入节点"><a href="#在二叉搜索树中插入节点" class="headerlink" title="在二叉搜索树中插入节点"></a>在二叉搜索树中插入节点</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> //LC701</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode insertIntoBST(TreeNode root, int val) &#123;</span><br><span class="line">        //为空节点时插入</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            TreeNode node=new TreeNode(val);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //通过回溯阶段完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root.left或者root.right将其接住。</span><br><span class="line">        if(val&lt;root.val)&#123;root.left=insertIntoBST(root.left,val);&#125;</span><br><span class="line">        if(val&gt;root.val)&#123;root.right=insertIntoBST(root.right,val);&#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除二树的特定节点"><a href="#删除二树的特定节点" class="headerlink" title="删除二树的特定节点"></a>删除二树的特定节点</h1><h2 id="删除二叉搜索树的特定节点"><a href="#删除二叉搜索树的特定节点" class="headerlink" title="删除二叉搜索树的特定节点"></a>删除二叉搜索树的特定节点</h2><p>删除特定节点必须要改变二叉树结构，有以下五种情况：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<br>  ** 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点<br>  ** 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点<br>  ** 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点<br>  ** 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> //LC450</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">        //没有找到节点</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到了目标节点</span><br><span class="line">        if(root.val==key)&#123;</span><br><span class="line">            if(root.right==null)&#123;return root.left;&#125;</span><br><span class="line">            else if(root.left==null)&#123;return root.right;&#125;</span><br><span class="line">            //目标节点左右节点都不为空</span><br><span class="line">            else&#123;</span><br><span class="line">                //找到目标节点的右子树的最左侧叶子节点，其最小</span><br><span class="line">                TreeNode temp=root.right;</span><br><span class="line">                while(temp.left!=null)&#123;</span><br><span class="line">                    temp=temp.left;</span><br><span class="line">                &#125;</span><br><span class="line">                //最左侧叶子节点指向目标节点的左子树，则仍然为二叉搜索树</span><br><span class="line">                temp.left=root.left;</span><br><span class="line">                //删除目标节点</span><br><span class="line">                root=root.right;</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root.left!=null)&#123;root.left=deleteNode(root.left,key);&#125;</span><br><span class="line">        if(root.right!=null)&#123;root.right=deleteNode(root.right,key);&#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="删除二叉树的特定节点"><a href="#删除二叉树的特定节点" class="headerlink" title="删除二叉树的特定节点"></a>删除二叉树的特定节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//C++代码</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if (root == nullptr) return root;</span><br><span class="line">        if (root-&gt;val == key) &#123;</span><br><span class="line">            if (root-&gt;right == nullptr) &#123; // 这里第二次操作目标值：最终删除的作用</span><br><span class="line">                return root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *cur = root-&gt;right;</span><br><span class="line">            while (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(root-&gt;val, cur-&gt;val); // 这里第一次操作目标值：交换目标值其右子树最左面节点。</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> //LC669</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode trimBST(TreeNode root, int low, int high) &#123;</span><br><span class="line">        if(root==null)&#123;return root;&#125;</span><br><span class="line"></span><br><span class="line">        if(root.val&lt;low)&#123;//此时没有必要遍历左子树了</span><br><span class="line">            //新建一个节点来存root的右子树，之后返回这个节点，这个过程中，root被架空了</span><br><span class="line">            TreeNode right=trimBST(root.right,low,high);</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(root.val&gt;high)&#123;//此时没有必要遍历右子树了</span><br><span class="line">            TreeNode left=trimBST(root.left,low,high);</span><br><span class="line">            return left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(root.left!=null)&#123;root.left=trimBST(root.left,low,high);&#125;</span><br><span class="line">        if(root.right!=null)&#123;root.right=trimBST(root.right,low,high);&#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> //LC108</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</span><br><span class="line">        return dfs(nums,0,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode dfs(int[] nums,int left,int right)&#123;</span><br><span class="line">        if(left&gt;=right)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(right-left==1)&#123;</span><br><span class="line">            return new TreeNode(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        int mid=left+(right-left)/2;</span><br><span class="line">        TreeNode root=new TreeNode(nums[mid]);</span><br><span class="line">        root.left=dfs(nums,left,mid);</span><br><span class="line">        root.right=dfs(nums,mid+1,right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将二叉搜索树转化为累加树"><a href="#将二叉搜索树转化为累加树" class="headerlink" title="将二叉搜索树转化为累加树"></a>将二叉搜索树转化为累加树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> //LC538</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int pre=0;</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;return;&#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        root.val+=pre;</span><br><span class="line">        pre=root.val;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;递归算法模板&quot;&gt;&lt;a href=&quot;#递归算法模板&quot; class=&quot;headerlink&quot; title=&quot;递归算法模板&quot;&gt;&lt;/a&gt;递归算法模板&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;返回值类型 dfs(参数) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (终止条件) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        存放结果;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 返回值类型;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    每层递归的逻辑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dfs(下层递归的参数);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="代码" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>关于如何让大脑保持清醒</title>
    <link href="http://example.com/2021/08/16/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%A7%E8%84%91%E4%BF%9D%E6%8C%81%E6%B8%85%E9%86%92/"/>
    <id>http://example.com/2021/08/16/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%A7%E8%84%91%E4%BF%9D%E6%8C%81%E6%B8%85%E9%86%92/</id>
    <published>2021-08-16T13:29:44.000Z</published>
    <updated>2021-08-16T13:35:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循序渐进的接受刺激"><a href="#循序渐进的接受刺激" class="headerlink" title="循序渐进的接受刺激"></a>循序渐进的接受刺激</h2><span id="more"></span><p><strong>循序渐进的接受刺激可以让我们更容易去做困难或者无趣的事情。每天里我们认为更无趣，更艰难的事，先去完成它。</strong></p><p>这并不是让我们不去娱乐，而是推迟我们娱乐的时间段。随着时间流逝，我们的意志力逐渐消沉时，这时就可以尽情的放松。</p><p>过多的刺激会让我们的大脑变得不清醒，比如我们刷朋友圈，看短视频等等，它让我们轻而易举的获得愉悦的感觉，让我们的大脑分泌多巴胺，肾上腺素，这时，大脑就会关闭我们大脑控制理智的一部分，去专心沉浸在预约之中。而此时，我们也就更难去做更无趣也更为慢节奏的事情了。</p><p>如果我们先在游戏或者视频中得到较高的刺激，之后我们再去做更无趣的事时，我们会难以开始或者坚持，宁愿什么也不干也不愿去做。</p><h2 id="清空大脑"><a href="#清空大脑" class="headerlink" title="清空大脑"></a>清空大脑</h2><p><strong>每一件可能的小事，每一件你必须要做的事，每一件你必须承担责任的事，每一件你必须记住的事，去把它们写下来。</strong></p><p>当我们忽然想到一些事情（不论任何事情，不管是要做的事，还是脑洞大开忽然想到的事），之后去撇开思绪，专注于眼前时，我们很可能并没有真正忘记那些事情，而是推给我们的潜意识。</p><p>当我们对需要注意的事，生活中的琐事等等事情处处留意时，我们很可能把它们都推给了潜意识，事情如果太多，我们便无法更好的专注于当下，甚至让我们产生焦虑。</p><p>把事情写下，就是把推给潜意识的思绪，转移到纸上，从而清空大脑，使大脑减负并且更清醒。</p><h2 id="艾森豪威尔法则"><a href="#艾森豪威尔法则" class="headerlink" title="艾森豪威尔法则"></a>艾森豪威尔法则</h2><p><strong>用事情重要与否，紧迫与否来衡量事情完成顺序的规则。</strong></p><p>既重要有紧迫的事，最先完成</p><p>紧迫但不重要的事，委托给别人或者稍后再做</p><p>重要但不紧迫的事，可以对这些事做些计划，在合适的时间好好解决它。</p><p>不重要同时不紧迫的事，放弃它们，不要去做。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;循序渐进的接受刺激&quot;&gt;&lt;a href=&quot;#循序渐进的接受刺激&quot; class=&quot;headerlink&quot; title=&quot;循序渐进的接受刺激&quot;&gt;&lt;/a&gt;循序渐进的接受刺激&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="个人提高" scheme="http://example.com/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E9%AB%98/"/>
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="http://example.com/2021/08/14/Servlet/"/>
    <id>http://example.com/2021/08/14/Servlet/</id>
    <published>2021-08-14T13:13:22.000Z</published>
    <updated>2021-08-16T08:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h1><h2 id="概念：运行在服务器端的小程序"><a href="#概念：运行在服务器端的小程序" class="headerlink" title="概念：运行在服务器端的小程序"></a>概念：运行在服务器端的小程序</h2><pre><code>    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。    * 将来我们自定义一个类，实现Servlet接口，复写方法。</code></pre><span id="more"></span><h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><pre><code>    1. 创建JavaEE项目    2. 定义一个类，实现Servlet接口        * public class ServletDemo1 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet         在web.xml中配置：        &lt;!--配置Servlet --&gt;        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;            &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;</code></pre><h2 id="执行原理："><a href="#执行原理：" class="headerlink" title="执行原理："></a>执行原理：</h2><pre><code>    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内存，并且创建其对象    5. 调用其方法</code></pre><h2 id="Servlet中的生命周期方法："><a href="#Servlet中的生命周期方法：" class="headerlink" title="Servlet中的生命周期方法："></a>Servlet中的生命周期方法：</h2><pre><code>    1. 被创建：执行init方法，只执行一次        * Servlet什么时候被创建？            * 默认情况下，第一次被访问时，Servlet被创建            * 可以配置执行Servlet的创建时机。                * 在&lt;servlet&gt;标签下配置                    1. 第一次被访问时，创建                        * &lt;load-on-startup&gt;的值为负数                    2. 在服务器启动时，创建                        * &lt;load-on-startup&gt;的值为0或正整数        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的            * 多个用户同时访问时，可能存在线程安全问题。            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值    2. 提供服务：执行service方法，执行多次        * 每次访问Servlet时，Service方法都会被调用一次。    3. 被销毁：执行destroy方法，只执行一次        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁        * 只有服务器正常关闭时，才会执行destroy方法。        * destroy方法在Servlet被销毁之前执行，一般用于释放资源</code></pre><h2 id="Servlet3-0："><a href="#Servlet3-0：" class="headerlink" title="Servlet3.0："></a>Servlet3.0：</h2><pre><code>    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置            * @WebServlet(&quot;资源路径&quot;)            @Target(&#123;ElementType.TYPE&#125;)            @Retention(RetentionPolicy.RUNTIME)            @Documented            public @interface WebServlet &#123;                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;                            String[] value() default &#123;&#125;;//代表urlPatterns()属性配置                            String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt;                            int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;                            WebInitParam[] initParams() default &#123;&#125;;                            boolean asyncSupported() default false;                            String smallIcon() default &quot;&quot;;                            String largeIcon() default &quot;&quot;;                            String description() default &quot;&quot;;                            String displayName() default &quot;&quot;;            &#125;</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;2. 工作空间项目    和     tomcat部署的web项目    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源    * WEB-INF目录下的资源不能被浏览器直接访问。3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre><h2 id="Servlet的体系结构"><a href="#Servlet的体系结构" class="headerlink" title="Servlet的体系结构"></a>Servlet的体系结构</h2><pre><code>    Servlet -- 接口        |    GenericServlet -- 抽象类        |    HttpServlet  -- 抽象类    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对http协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost方法</code></pre><h2 id="Servlet相关配置"><a href="#Servlet相关配置" class="headerlink" title="Servlet相关配置"></a>Servlet相关配置</h2><pre><code>    1. urlpartten:Servlet访问路径        1. 一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;&#125;)        2. 路径定义规则：            1. /xxx：路径匹配            2. /xxx/xxx:多层路径，目录结构            3. *.do：扩展名匹配</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Servlet：-server-applet&quot;&gt;&lt;a href=&quot;#Servlet：-server-applet&quot; class=&quot;headerlink&quot; title=&quot;Servlet：  server applet&quot;&gt;&lt;/a&gt;Servlet：  server applet&lt;/h1&gt;&lt;h2 id=&quot;概念：运行在服务器端的小程序&quot;&gt;&lt;a href=&quot;#概念：运行在服务器端的小程序&quot; class=&quot;headerlink&quot; title=&quot;概念：运行在服务器端的小程序&quot;&gt;&lt;/a&gt;概念：运行在服务器端的小程序&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。
    * 将来我们自定义一个类，实现Servlet接口，复写方法。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Servlet" scheme="http://example.com/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>XML与Tomcat</title>
    <link href="http://example.com/2021/08/12/XML%E4%B8%8ETomcat/"/>
    <id>http://example.com/2021/08/12/XML%E4%B8%8ETomcat/</id>
    <published>2021-08-12T14:27:31.000Z</published>
    <updated>2021-08-12T14:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h1><h2 id="概念：Extensible-Markup-Language-可扩展标记语言"><a href="#概念：Extensible-Markup-Language-可扩展标记语言" class="headerlink" title="概念：Extensible Markup Language 可扩展标记语言"></a>概念：Extensible Markup Language 可扩展标记语言</h2><pre><code>    * 可扩展：标签都是自定义的。 &lt;user&gt;  &lt;student&gt;</code></pre><span id="more"></span><pre><code>    * 功能        * 存储数据            1. 配置文件            2. 在网络中传输    * xml与html的区别        1. xml标签都是自定义的，html标签是预定义。        2. xml的语法严格，html语法松散        3. xml是存储数据的，html是展示数据    * w3c:万维网联盟</code></pre><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><pre><code>    * 基本语法：        1. xml文档的后缀名 .xml        2. xml第一行必须定义为文档声明        3. xml文档中有且仅有一个根标签        4. 属性值必须使用引号(单双都可)引起来        5. 标签必须正确关闭        6. xml标签名称区分大小写    * 快速入门：        &lt;?xml version=&#39;1.0&#39; ?&gt;        &lt;users&gt;            &lt;user id=&#39;1&#39;&gt;                &lt;name&gt;zhangsan&lt;/name&gt;                &lt;age&gt;23&lt;/age&gt;                &lt;gender&gt;male&lt;/gender&gt;                &lt;br/&gt;            &lt;/user&gt;                        &lt;user id=&#39;2&#39;&gt;                &lt;name&gt;lisi&lt;/name&gt;                &lt;age&gt;24&lt;/age&gt;                &lt;gender&gt;female&lt;/gender&gt;            &lt;/user&gt;        &lt;/users&gt;            * 组成部分：        1. 文档声明            1. 格式：&lt;?xml 属性列表 ?&gt;            2. 属性列表：                * version：版本号，必须的属性                * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1                * standalone：是否独立                    * 取值：                        * yes：不依赖其他文件                        * no：依赖其他文件        2. 指令(了解)：结合css的            * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;        3. 标签：标签名称自定义的            * 规则：                * 名称可以包含字母、数字以及其他的字符                 * 名称不能以数字或者标点符号开始                 * 名称不能以字母 xml（或者 XML、Xml 等等）开始                 * 名称不能包含空格         4. 属性：            id属性值唯一        5. 文本：            * CDATA区：在该区域中的数据会被原样展示                * 格式：  &lt;![CDATA[ 数据 ]]&gt;    * 约束：规定xml文档的书写规则        * 作为框架的使用者(程序员)：            1. 能够在xml中引入约束文档            2. 能够简单的读懂约束文档                * 分类：            1. DTD:一种简单的约束技术            2. Schema:一种复杂的约束技术        * DTD：            * 引入dtd文档到xml文档中                * 内部dtd：将约束规则定义在xml文档中                * 外部dtd：将约束的规则定义在外部的dtd文件中                    * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;                    * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;        * Schema:            * 引入：                1.填写xml文档的根元素                2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;                3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;                4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot;             &lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;                xmlns=&quot;http://www.itcast.cn/xml&quot;                xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;</code></pre><h2 id="解析：操作xml文档，将文档中的数据读取到内存中"><a href="#解析：操作xml文档，将文档中的数据读取到内存中" class="headerlink" title="解析：操作xml文档，将文档中的数据读取到内存中"></a>解析：操作xml文档，将文档中的数据读取到内存中</h2><pre><code>    * 操作xml文档        1. 解析(读取)：将文档中的数据读取到内存中        2. 写入：将内存中的数据保存到xml文档中。持久化的存储    * 解析xml的方式：        1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树            * 优点：操作方便，可以对文档进行CRUD的所有操作            * 缺点：占内存        2. SAX：逐行读取，基于事件驱动的。            * 优点：不占内存。            * 缺点：只能读取，不能增删改        * xml常见的解析器：        1. JAXP：sun公司提供的解析器，支持dom和sax两种思想        2. DOM4J：一款非常优秀的解析器        3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。        4. PULL：Android操作系统内置的解析器，sax方式的。    * Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。        * 快速入门：            * 步骤：                1. 导入jar包                2. 获取Document对象                3. 获取对应的标签Element对象                4. 获取数据        * 代码：             //2.1获取student.xml的path            String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();            //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document            Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);            //3.获取元素对象 Element            Elements elements = document.getElementsByTag(&quot;name&quot;);                System.out.println(elements.size());            //3.1获取第一个name的Element对象            Element element = elements.get(0);            //3.2获取数据            String name = element.text();            System.out.println(name);    * 对象的使用：        1. Jsoup：工具类，可以解析html或xml文档，返回Document            * parse：解析html或xml文档，返回Document                * parse​(File in, String charsetName)：解析xml或html文件的。                * parse​(String html)：解析xml或html字符串                * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象        2. Document：文档对象。代表内存中的dom树            * 获取Element对象                * getElementById​(String id)：根据id属性值获取唯一的element对象                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合        3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用        4. Element：元素对象            1. 获取子元素对象                * getElementById​(String id)：根据id属性值获取唯一的element对象                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合            2. 获取属性值                * String attr(String key)：根据属性名称获取属性值            3. 获取文本内容                * String text():获取文本内容                * String html():获取标签体的所有内容(包括字标签的字符串内容)        5. Node：节点对象            * 是Document和Element的父类            * 快捷查询方式：        1. selector:选择器            * 使用的方法：Elements    select​(String cssQuery)                * 语法：参考Selector类中定义的语法        2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言            * 使用Jsoup的Xpath需要额外导入jar包。            * 查询w3cshool参考手册，使用xpath的语法完成查询            * 代码：                //1.获取student.xml的path                String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();                //2.获取Document对象                Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);                        //3.根据document对象，创建JXDocument对象                JXDocument jxDocument = new JXDocument(document);                        //4.结合xpath语法查询                //4.1查询所有student标签                List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);                for (JXNode jxNode : jxNodes) &#123;                    System.out.println(jxNode);                &#125;                        System.out.println(&quot;--------------------&quot;);                        //4.2查询所有student标签下的name标签                List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);                for (JXNode jxNode : jxNodes2) &#123;                    System.out.println(jxNode);                &#125;                        System.out.println(&quot;--------------------&quot;);                        //4.3查询student标签下带有id属性的name标签                List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);                for (JXNode jxNode : jxNodes3) &#123;                    System.out.println(jxNode);                &#125;                System.out.println(&quot;--------------------&quot;);                //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast                        List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&#39;itcast&#39;]&quot;);                for (JXNode jxNode : jxNodes4) &#123;                    System.out.println(jxNode);                &#125;</code></pre><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析        * 如： html,css,JavaScript    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器        * 如：servlet/jsp,php,asp....        3. 网络通信三要素    1. IP：电子设备(计算机)在网络中的唯一标识。    2. 端口：应用程序在计算机中的唯一标识。 0~65536    3. 传输协议：规定了数据传输的规则        1. 基础协议：            1. tcp:安全协议，三次握手。 速度稍慢            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应。    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范* Tomcat：web服务器软件    1. 下载：http://tomcat.apache.org/    2. 安装：解压压缩包即可。        * 注意：安装目录建议不要有中文和空格    3. 卸载：删除目录就行了    4. 启动：        * bin/startup.bat ,双击运行该文件即可        * 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人                * 可能遇到的问题：            1. 黑窗口一闪而过：                * 原因： 没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -ano                2. 温柔：修改自身的端口号                    * conf/server.xml                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。                        * 好处：在访问时，就不用输入端口号    5. 关闭：        1. 正常关闭：            * bin/shutdown.bat            * ctrl+c        2. 强制关闭：            * 点击启动窗口的×    6. 配置:        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;                * docBase:项目存放的路径                * path：虚拟目录            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=&quot;D:\hello&quot; /&gt;                * 虚拟目录：xml文件的名称                * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- classes目录：放置字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;XML：&quot;&gt;&lt;a href=&quot;#XML：&quot; class=&quot;headerlink&quot; title=&quot;XML：&quot;&gt;&lt;/a&gt;XML：&lt;/h1&gt;&lt;h2 id=&quot;概念：Extensible-Markup-Language-可扩展标记语言&quot;&gt;&lt;a href=&quot;#概念：Extensible-Markup-Language-可扩展标记语言&quot; class=&quot;headerlink&quot; title=&quot;概念：Extensible Markup Language 可扩展标记语言&quot;&gt;&lt;/a&gt;概念：Extensible Markup Language 可扩展标记语言&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    * 可扩展：标签都是自定义的。 &amp;lt;user&amp;gt;  &amp;lt;student&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    <category term="XML" scheme="http://example.com/tags/XML/"/>
    
    <category term="Tomcat" scheme="http://example.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>HTML与CSS</title>
    <link href="http://example.com/2021/08/06/HTML%E4%B8%8ECSS/"/>
    <id>http://example.com/2021/08/06/HTML%E4%B8%8ECSS/</id>
    <published>2021-08-06T05:22:47.000Z</published>
    <updated>2021-08-06T05:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h1><h2 id="JavaWeb："><a href="#JavaWeb：" class="headerlink" title="JavaWeb："></a>JavaWeb：</h2><pre><code>    * 使用Java语言开发基于互联网的项目</code></pre><span id="more"></span><h2 id="软件架构："><a href="#软件架构：" class="headerlink" title="软件架构："></a>软件架构：</h2><pre><code>    1. C/S: Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装，部署，维护 麻烦    2. B/S: Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序        * 优点：            1. 开发、安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高</code></pre><h2 id="B-S架构详解"><a href="#B-S架构详解" class="headerlink" title="B/S架构详解"></a>B/S架构详解</h2><pre><code>    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样。                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="概念：是最基础的网页开发语言"><a href="#概念：是最基础的网页开发语言" class="headerlink" title="概念：是最基础的网页开发语言"></a>概念：是最基础的网页开发语言</h2><pre><code>    * Hyper Text Markup Language 超文本标记语言        * 超文本:            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.        * 标记语言:            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml            * 标记语言不是编程语言</code></pre><h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><pre><code>    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，但是建议使用小写。</code></pre><h2 id="标签学习："><a href="#标签学习：" class="headerlink" title="标签学习："></a>标签学习：</h2><h3 id="文件标签：构成html最基本的标签"><a href="#文件标签：构成html最基本的标签" class="headerlink" title="文件标签：构成html最基本的标签"></a>文件标签：构成html最基本的标签</h3><pre><code>        * html:html文档的根标签        * head：头标签。用于指定html文档的一些属性。引入外部的资源        * title：标题标签。        * body：体标签        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档</code></pre><h3 id="文本标签：和文本有关的标签"><a href="#文本标签：和文本有关的标签" class="headerlink" title="文本标签：和文本有关的标签"></a>文本标签：和文本有关的标签</h3><pre><code>        * 注释：&lt;!-- 注释内容 --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6:字体大小逐渐递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对其方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;:字体标签        * &lt;center&gt;:文本居中            * 属性：                * color：颜色                * size：大小                * face：字体        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF            * width：                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)                2. 数值%：占比相对于父元素的比例</code></pre><h3 id="图片标签："><a href="#图片标签：" class="headerlink" title="图片标签："></a>图片标签：</h3><pre><code>        * img：展示图片            * 属性：                * src：指定图片的位置        * 代码：             &lt;!--展示一张图片 img--&gt;            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;                    &lt;!--                相对路径                    * 以.开头的路径                        * ./：代表当前目录  ./image/1.jpg                        * ../:代表上一级目录             --&gt;                    &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;                    &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;</code></pre><h3 id="列表标签："><a href="#列表标签：" class="headerlink" title="列表标签："></a>列表标签：</h3><pre><code>        * 有序列表：            * ol:            * li:        * 无序列表：            * ul:            * li:</code></pre><h3 id="链接标签："><a href="#链接标签：" class="headerlink" title="链接标签："></a>链接标签：</h3><pre><code>        * a:定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self:默认值，在当前页面打开                    * _blank：在空白页面打开        * 代码：             &lt;!--超链接  a--&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;                    &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;                    &lt;br&gt;                    &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;                    &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;</code></pre><h3 id="div和span："><a href="#div和span：" class="headerlink" title="div和span："></a>div和span：</h3><pre><code>        * div:每一个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签 内联标签</code></pre><h3 id="语义化标签：html5中为了提高程序的可读性，提供了一些标签。"><a href="#语义化标签：html5中为了提高程序的可读性，提供了一些标签。" class="headerlink" title="语义化标签：html5中为了提高程序的可读性，提供了一些标签。"></a>语义化标签：html5中为了提高程序的可读性，提供了一些标签。</h3><pre><code>        1. &lt;header&gt;：页眉        2. &lt;footer&gt;：页脚</code></pre><h3 id="表格标签："><a href="#表格标签：" class="headerlink" title="表格标签："></a>表格标签：</h3><pre><code>        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并列            * rowspan：合并行        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分            </code></pre><h3 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h3><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围        * 属性：            * action：指定提交数据的URL            * method:指定提交方式                * 分类：一共7种，2种比较常用                   * get：                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。                        2. 请求参数大小是有限制的。                        3. 不太安全。                   * post：                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制。                        3. 较为安全。        * 表单项中的数据要想被提交：必须指定其name属性        * 表单项标签：        * input：可以通过type属性值，改变元素展示的样式            * type属性：                * text：文本输入框，默认值                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息                    * password：密码输入框                * radio:单选框                    * 注意：                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        3. checked属性，可以指定默认值                * checkbox：复选框                    * 注意：                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        2. checked属性，可以指定默认值                * file：文件选择框                * hidden：隐藏域，用于提交一些信息。                * 按钮：                    * submit：提交按钮。可以提交表单                    * button：普通按钮                    * image：图片提交按钮                        * src属性指定图片的路径               * label：指定输入项的文字描述信息               * 注意：                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。        * select: 下拉列表            * 子元素：option，指定列表项                    * textarea：文本域            * cols：指定列数，每一行有多少个字符            * rows：默认多少行。</code></pre><h1 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h1><h2 id="概念：-Cascading-Style-Sheets-层叠样式表"><a href="#概念：-Cascading-Style-Sheets-层叠样式表" class="headerlink" title="概念： Cascading Style Sheets 层叠样式表"></a>概念： Cascading Style Sheets 层叠样式表</h2><pre><code>    * 层叠：多个样式可以作用在同一个html的元素上，同时生效</code></pre><h2 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h2><pre><code>    1. 功能强大    2. 将内容展示和样式控制分离        * 降低耦合度。解耦        * 让分工协作更容易        * 提高开发效率</code></pre><h2 id="CSS的使用：CSS与html结合方式"><a href="#CSS的使用：CSS与html结合方式" class="headerlink" title="CSS的使用：CSS与html结合方式"></a>CSS的使用：CSS与html结合方式</h2><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><pre><code>         * 在标签内使用style属性指定css代码         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;</code></pre><h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><pre><code>        * 在head标签内，定义style标签，style标签的标签体内容就是css代码        * 如：            &lt;style&gt;                div&#123;                    color:blue;                &#125;                    &lt;/style&gt;            &lt;div&gt;hello css&lt;/div&gt;</code></pre><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><pre><code>        1. 定义css资源文件。        2. 在head标签内，定义link标签，引入外部的资源文件        * 如：            * a.css文件：                div&#123;                    color:green;                &#125;            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;            &lt;div&gt;hello css&lt;/div&gt;            &lt;div&gt;hello css&lt;/div&gt;    * 注意：        * 1,2,3种方式 css作用范围越来越大        * 1方式不常用，后期常用2,3        * 3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;</code></pre><h3 id="css语法："><a href="#css语法：" class="headerlink" title="css语法："></a>css语法：</h3><pre><code>    * 格式：        选择器 &#123;            属性名1:属性值1;            属性名2:属性值2;            ...        &#125;    * 选择器:筛选具有相似特征的元素    * 注意：        * 每一对属性需要使用；隔开，最后一对属性可以不加；</code></pre><h3 id="选择器：筛选具有相似特征的元素"><a href="#选择器：筛选具有相似特征的元素" class="headerlink" title="选择器：筛选具有相似特征的元素"></a>选择器：筛选具有相似特征的元素</h3><pre><code>    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一                * 语法：#id属性值&#123;&#125;            2. 元素选择器：选择具有相同标签名称的元素                * 语法： 标签名称&#123;&#125;                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性值的元素。                * 语法：.class属性值&#123;&#125;                * 注意：类选择器选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素：                * 语法： *&#123;&#125;            2. 并集选择器：                * 选择器1,选择器2&#123;&#125;                        3. 子选择器：筛选选择器1元素下的选择器2元素                * 语法：  选择器1 选择器2&#123;&#125;            4. 父选择器：筛选选择器2的父元素选择器1                * 语法：  选择器1 &gt; 选择器2&#123;&#125;            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;            6. 伪类选择器：选择一些元素具有的状态                * 语法： 元素:状态&#123;&#125;                * 如： &lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-align：对其方式        * line-height：行高     2. 背景        * background：    3. 边框        * border：设置边框，符合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小        * float：浮动            * left            * right        </code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;web概念概述&quot;&gt;&lt;a href=&quot;#web概念概述&quot; class=&quot;headerlink&quot; title=&quot;web概念概述&quot;&gt;&lt;/a&gt;web概念概述&lt;/h1&gt;&lt;h2 id=&quot;JavaWeb：&quot;&gt;&lt;a href=&quot;#JavaWeb：&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb：&quot;&gt;&lt;/a&gt;JavaWeb：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    * 使用Java语言开发基于互联网的项目
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>
