<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TheSeasonSun</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-17T12:04:04.117Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TheSeasonSun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL索引数据结构浅聊</title>
    <link href="http://example.com/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/"/>
    <id>http://example.com/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/</id>
    <published>2022-05-17T11:06:19.000Z</published>
    <updated>2022-05-17T12:04:04.117Z</updated>
    
    <content type="html"><![CDATA[<p>聊一下索引的底层数据结构，着重介绍现在用的比较广泛的B树与B+树。</p><span id="more"></span><h3 id="hash-表"><a href="#hash-表" class="headerlink" title="hash 表"></a>hash 表</h3><p>hash表的数据结构在此就不多赘述了，直接说hash表的缺点：</p><ul><li>需要大量内存空间，因为每次使用hash表的时候都需要将全量的数据加载到内存中。（memory存储引擎使用hash索引）</li><li>使用hash表时需要设计优秀的hash算法，否则会导致数据分布不均匀，浪费存储空间，查询效率低下。</li><li>hash表只能支持等值搜索，不能范围或区间搜索。比如要查询id &lt; 500的人，hash表只能从1到499依次查出来。这是hash表比较致命的缺点。</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>使用二叉搜索树可以使用二分查找方式查找数据，但是如果插入的数据是递增的，二叉树就会退化成链表，树的深度也很大，而<strong>树的深度与查找次数成正比</strong>（下面会解释，<strong>减少树的深度正是提高索引效率的核心思路之一</strong>）。因此单纯的二叉搜索树效率可能会低下。</p><p>那么使用二叉平衡树（AVL树）呢？<br>二叉平衡树要求左右子树高度差不大于1，这避免了上面数据退化成链表的情况，提高了搜索效率，但是在插入数据时，二叉平衡树为了保证平衡性，插入时要进行旋转，而这降低了插入效率。此外，在数据量大的情况下，二叉平衡树还是无法避免深度大的情况。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>为了解决二叉树插入效率低的情况，在看看红黑树，他也是二叉平衡树，但它只要求最长子树的深度不超过最短子树的二倍，而且还添加了变色的行为来保证树的平衡性。</p><p>可是这还是无法避免深度大的情况，接下来的思路大家应该也想到了，就是增加树的的分支来减少树的深度，这就是B树。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树最大的特点是每个节点可以包含多个Key值，B树中有一个叫degree概念，表示每个节点最多可以存储N-1个节点。</p><p>B树特点：</p><ol><li>所有键值分布在整颗树中</li><li>搜索有可能在非叶子结点结束，在关键字全集内做一次查找,性能逼近二分查找</li><li>每个节点最多拥有m个子树</li><li>根节点至少有2个子树</li><li>分支节点至少拥有m/2颗子树（除根节点和叶子节点外都是分支节点）</li><li>所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</li></ol><p>下面看一个实例：</p><p><img src="/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/Bshu.png" alt="Bshu"></p><p>实例图说明：</p><p>每个节点占用一个磁盘块，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为 16 和 34，P1 指针指向的子树的数据范围为小于 16，P2 指针指向的子树的数据范围为 16~34，P3 指针指向的子树的数据范围为大于 34。 </p><p>查找关键字过程：</p><ol><li><p>根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】</p></li><li><p>比较关键字 28 在区间（16,34），找到磁盘块 1 的指针 P2。</p></li><li><p>根据 P2 指针找到磁盘块 3，读入内存。【磁盘 I/O 操作第 2 次】</p></li><li><p>比较关键字 28 在区间（25,31），找到磁盘块 3 的指针 P2。</p></li><li><p>根据 P2 指针找到磁盘块 8，读入内存。【磁盘 I/O 操作第 3 次】</p></li><li><p>在磁盘块 8 中的关键字列表中找到关键字 28。 </p></li></ol><p>但是B树依旧有缺点：</p><ol><li><p>每个节点都有key，同时也包含data，而每个页存储空间是有限的，如果data比较大的话会导致每个节点存储的key数量变小</p></li><li><p>当存储的数据量很大的时候会导致深度较大，增大查询时磁盘io次数，进而影响查询性能</p></li></ol><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+ Tree 是基于B Tree 和<strong>叶子节点顺序</strong>访问进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。此外，B+ 树不在非叶子节点存储数据，只存储Key值，使得B+ Tree每个节点可以包含更多的节点。</p><p>B+Tree是在B Tree的基础之上做的一种优化，变化如下：</p><ol><li>非叶子节点存储key，叶子节点存储key和数据</li><li>B+ Tree每个节点可以包含更多的节点，这个做的原因有两个，第一个原因是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快</li><li>叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高</li></ol><p>如图：<br><img src="/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/B+shu.png" alt="B+shu"></p><p>注意：在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。<strong>因此B+Tree 支持两种查找运算：一种是对于主键的范围查找和分页查找（解决Hash表缺点），另一种是从根节点开始，进行随机查找。</strong></p><h4 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h4><p>借助索引查找时，现在B+树根节点进行二分查找，找到所查找项对应区间的结点之后继续递归的查找，直到在叶子节点找出Key所对应的data。<br>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。这也是索引共同的缺点。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>B+树能显著减少IO次数，提高效率</li><li>B+树的查询效率更加稳定，因为数据放在叶子节点</li><li>B+树能提高范围查询的效率，因为叶子节点指向下一个叶子节点</li><li>B+树采取顺序读</li></ol><p>看了下面的解释，我们会更深入的了解B+ 树高效的原因</p><h4 id="为什么B-树有更高的性能？"><a href="#为什么B-树有更高的性能？" class="headerlink" title="为什么B+ 树有更高的性能？"></a>为什么B+ 树有更高的性能？</h4><p>我们先看一下数据库数据从查找到传递在磁盘上经历哪些步骤：</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页（数据页16KB，6384字节），内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p><p><img src="/2022/05/17/MySQL%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%85%E8%81%8A/cipan.png" alt="cipan"><br>如图，磁盘结构包括：盘片，磁头，主轴，集成电路板。</p><p><strong>磁盘上有一条条磁道，数据存于磁盘的磁道上，要查找并读取一个存储的数据，磁头从不存储数据的着陆区移动到磁道上，经过磁盘旋转找到对应数据，在将数据传送的内存。</strong></p><p>那么我们就可以发现：</p><p><strong>单次的IO时间 =   寻道时间 + 旋转延迟 + 传送时间</strong></p><p>此时我们再来看B+ 树的数据结构为什么能更高效：</p><ol><li>B+ 树有更低的树高</li></ol><p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。 因为B+ Tree 的非叶子节点不存放数据，只存储Key，B+ Tree 的出度一般都非常大（红黑树的出度为 2），所以 B+ Tree 的树高比较低，而从B+ 树一层层查找的过程我们可以推理出，每一层（每次查询）都要在磁盘进行搜索（寻道），<strong>更低的树高可以有效的减少寻道时间</strong>。</p><ol start="2"><li>磁盘预读特性</li></ol><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。<strong>B+ 树叶子节点相连的特性恰恰迎合了磁盘的顺序读，减少了旋转延迟</strong>。</p><p>总结：B+ 树除了数据结构本身的高效，还迎合了磁盘的I/O机制，所以能更高效。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;聊一下索引的底层数据结构，着重介绍现在用的比较广泛的B树与B+树。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="MySQL索引" scheme="http://example.com/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL performance schema简述</title>
    <link href="http://example.com/2022/05/16/MySQL-performance-schema%E7%AE%80%E8%BF%B0/"/>
    <id>http://example.com/2022/05/16/MySQL-performance-schema%E7%AE%80%E8%BF%B0/</id>
    <published>2022-05-16T15:14:03.000Z</published>
    <updated>2022-05-17T11:57:39.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="performance-schema的介绍"><a href="#performance-schema的介绍" class="headerlink" title="performance_schema的介绍"></a>performance_schema的介绍</h2><p><strong>MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况</strong>。</p><span id="more"></span><h3 id="performance-schema特点"><a href="#performance-schema特点" class="headerlink" title="performance_schema特点"></a>performance_schema特点</h3><ul><li><strong>它提供了一种在数据库运行时实时检查server的内部执行情况的方法</strong>。performance_schema 数据库中的表使用performance_schema存储引擎。该数据库主要关注数据库运行过程中的性能相关的数据（information_schema主要关注server运行过程中的元数据信息）。</li><li><strong>performance_schema通过监视server的事件来实现监视server内部运行情况， “事件”就是server内部活动中所做的任何事情以及对应的时间消耗</strong>。利用这些信息来判断server中的相关资源消耗在了哪里？一般来说，事件可以是函数调用、操作系统的等待、SQL语句执行的阶段（如sql语句执行过程中的parsing 或 sorting阶段）或者整个SQL语句与SQL语句集合。事件的采集可以方便的提供server中的相关存储引擎对磁盘文件、表I/O、表锁等资源的同步调用信息。</li><li>performance_schema中的事件记录的是server执行某些活动对某些资源的消耗、耗时、这些活动执行的次数等情况。</li><li>performance_schema中的事件只记录在本地server的performance_schema中，其下的这些表中数据发生变化时不会被写入binlog中，也不会通过复制机制被复制到其他server中。</li><li>当前活跃事件、历史事件和事件摘要相关的表中记录的信息。能提供某个事件的执行次数、使用时长。进而可用于分析某个特定线程、特定对象（如mutex或file）相关联的活动。</li><li>PERFORMANCE_SCHEMA存储引擎使用server源代码中的“检测点”来实现事件数据的收集。对于performance_schema实现机制本身的代码没有相关的单独线程来检测，这与其他功能（如复制或事件计划程序）不同</li><li>收集的事件数据存储在performance_schema数据库的表中。这些表可以使用SELECT语句查询，也可以使用SQL语句更新performance_schema数据库中的表记录</li><li>performance_schema的表中的数据不会持久化存储在磁盘中，而是保存在内存中，一旦服务器重启，这些数据会丢失（包括配置表在内的整个performance_schema下的所有数据）</li><li>MySQL支持的所有平台中事件监控功能都可用，但不同平台中用于统计事件时间开销的计时器类型可能会有所差异。</li></ul><h2 id="performance-schema实践操作"><a href="#performance-schema实践操作" class="headerlink" title="performance_schema实践操作"></a>performance_schema实践操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1、哪类的SQL执行最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--2、哪类SQL的平均响应时间最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,AVG_TIMER_WAIT <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--3、哪类SQL排序记录数最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_SORT_ROWS <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--4、哪类SQL扫描记录数最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_EXAMINED <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--5、哪类SQL使用临时表最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--6、哪类SQL返回结果集最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> DIGEST_TEXT,SUM_ROWS_SENT <span class="keyword">FROM</span> events_statements_summary_by_digest <span class="keyword">ORDER</span> <span class="keyword">BY</span> COUNT_STAR <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--7、哪个表物理IO最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE <span class="keyword">FROM</span> file_summary_by_instance <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_NUMBER_OF_BYTES_READ <span class="operator">+</span> SUM_NUMBER_OF_BYTES_WRITE <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--8、哪个表逻辑IO最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT <span class="keyword">FROM</span> table_io_waits_summary_by_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> sum_timer_wait <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--9、哪个索引访问最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE <span class="keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_TIMER_WAIT <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--10、哪个索引从来没有用过？</span></span><br><span class="line"><span class="keyword">SELECT</span> OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME <span class="keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="keyword">WHERE</span> INDEX_NAME <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> COUNT_STAR <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> OBJECT_SCHEMA <span class="operator">&lt;&gt;</span> <span class="string">&#x27;mysql&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> OBJECT_SCHEMA,OBJECT_NAME;</span><br><span class="line"><span class="comment">--11、哪个等待事件消耗时间最多？</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT <span class="keyword">FROM</span> events_waits_summary_global_by_event_name <span class="keyword">WHERE</span> event_name <span class="operator">!=</span> <span class="string">&#x27;idle&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> SUM_TIMER_WAIT <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">--12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息</span></span><br><span class="line"><span class="keyword">SELECT</span> EVENT_ID,sql_text <span class="keyword">FROM</span> events_statements_history <span class="keyword">WHERE</span> sql_text <span class="keyword">LIKE</span> <span class="string">&#x27;%count(*)%&#x27;</span>;</span><br><span class="line"><span class="comment">--12-2、查看每个阶段的时间消耗</span></span><br><span class="line"><span class="keyword">SELECT</span> event_id,EVENT_NAME,SOURCE,TIMER_END <span class="operator">-</span> TIMER_START <span class="keyword">FROM</span> events_stages_history_long <span class="keyword">WHERE</span> NESTING_EVENT_ID <span class="operator">=</span> <span class="number">1553</span>;</span><br><span class="line"><span class="comment">--12-3、查看每个阶段的锁等待情况</span></span><br><span class="line"><span class="keyword">SELECT</span> event_id,event_name,source,timer_wait,object_name,index_name,operation,nesting_event_id <span class="keyword">FROM</span> events_waits_history_longWHERE nesting_event_id <span class="operator">=</span> <span class="number">1553</span>;</span><br></pre></td></tr></table></figure><p>​        instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</p><p>​        consumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;performance-schema的介绍&quot;&gt;&lt;a href=&quot;#performance-schema的介绍&quot; class=&quot;headerlink&quot; title=&quot;performance_schema的介绍&quot;&gt;&lt;/a&gt;performance_schema的介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>synchronized</title>
    <link href="http://example.com/2022/05/12/synchronized%E6%B5%85%E8%81%8A/"/>
    <id>http://example.com/2022/05/12/synchronized%E6%B5%85%E8%81%8A/</id>
    <published>2022-05-12T01:55:06.000Z</published>
    <updated>2022-05-12T02:11:09.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>模拟银行账户，对业务写方法加锁，对业务读方法不加锁，这样行不行？</p><span id="more"></span><p>不行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">容易产生脏读问题（dirtyRead）</span><br><span class="line">public class Account &#123;</span><br><span class="line">String name;</span><br><span class="line">double balance;</span><br><span class="line"></span><br><span class="line">public synchronized void set(String name, double balance) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">this.balance = balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public /*synchronized*/ double getBalance(String name) &#123;</span><br><span class="line">return this.balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Account a = new Account();</span><br><span class="line">new Thread(()-&gt;a.set(&quot;zhangsan&quot;, 100.0)).start();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(1);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(a.getBalance(&quot;zhangsan&quot;));</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">TimeUnit.SECONDS.sleep(2);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(a.getBalance(&quot;zhangsan&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="synchronized注意事项"><a href="#synchronized注意事项" class="headerlink" title="synchronized注意事项"></a>synchronized注意事项</h3><p>synchronized可重入，不然可能会发生死锁（同一个线程）</p><p>异常跟锁：程序之中如果出现异常，默认情况下，锁会释放</p><p>synchronized锁的是对象，不是代码。synchronized(Object)</p><p>synchronized不能锁String常量，Integer等基础类型</p><p>在竞争不是很激烈的情况下，尽量让锁的粒度细化一些，使性能更快。如果竞争很激烈，可以锁的粒度粗化，也可提升性能。</p><p>锁定某对象o，如果o的属性发生改变，不影响锁的使用，但是如果o变成另外一个对象，则锁定的对象发生改变，应该避免将锁定对象的引用变成另外的对象。（给引用加final）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class SyncSameObject &#123;</span><br><span class="line">   </span><br><span class="line">   /*final*/ Object o = new Object();</span><br><span class="line"></span><br><span class="line">   void m() &#123;</span><br><span class="line">      synchronized(o) &#123;</span><br><span class="line">         while(true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SyncSameObject t = new SyncSameObject();</span><br><span class="line">      //启动第一个线程</span><br><span class="line">      new Thread(t::m, &quot;t1&quot;).start();</span><br><span class="line">      </span><br><span class="line">      try &#123;</span><br><span class="line">         TimeUnit.SECONDS.sleep(3);</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      //创建第二个线程</span><br><span class="line">      Thread t2 = new Thread(t::m, &quot;t2&quot;);</span><br><span class="line">      </span><br><span class="line">      t.o = new Object(); //锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会</span><br><span class="line">      </span><br><span class="line">      t2.start();</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在虚拟机堆中new出对象，对象中首先是8个字节的markword，4个字节的类型指针，4字节成员变量（long类型8个字节），Hotspot要求对象8字节对齐（字节数是8的整数倍），不足对齐。</p><p>在Hotspot中，所谓的上锁就是修改markword。</p><p><img src="/2022/05/12/synchronized%E6%B5%85%E8%81%8A/suo.png" alt="suo"></p><p>如上图，普通对象synchronized修饰加锁，升级为偏向锁，有线程与其竞争时偏向锁升级为轻量级锁（自旋锁，无锁 ），再竞争升级为重量级锁</p><h3 id="上锁的本质"><a href="#上锁的本质" class="headerlink" title="上锁的本质"></a>上锁的本质</h3><p>锁可以升级但不能降级，意味着偏向<a href="https://so.csdn.net/so/search?q=%E9%94%81%E5%8D%87%E7%BA%A7&spm=1001.2101.3001.7020">锁升级</a>成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率.</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p> 偏向锁，顾名思义，它会偏向于第一个访问锁的线程</p></blockquote><ul><li>如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</li><li>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。偏向锁通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）。升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致STW(stop the word)操作；</li></ul><blockquote><p>锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p></blockquote><h4 id="轻量级锁（自旋锁）"><a href="#轻量级锁（自旋锁）" class="headerlink" title="轻量级锁（自旋锁）"></a>轻量级锁（自旋锁）</h4><blockquote><p>自旋锁：自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p></blockquote><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起，等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><blockquote><p>重量级锁的特点：其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程。</p></blockquote><h4 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行速度较长。</td></tr></tbody></table><p>摘自<a href="https://blog.csdn.net/qq_40722827/article/details/105598682">(32条消息) 深入理解Java锁升级：无锁 → 偏向锁 → 轻量级锁 → 重量级锁_carroll18的博客-CSDN博客_无锁,偏向锁</a></p><p>上锁的本质是修改线程的markword，从markword可以看出对象的锁状态，如下，先看后两位：</p><p><img src="/2022/05/12/synchronized%E6%B5%85%E8%81%8A/Hotspot%E4%B8%8B%E7%9A%84%E9%94%81%E7%8A%B6%E6%80%81.png" alt="Hotspot下的锁状态"></p><p>偏向锁，轻量级锁：用户空间锁（用户空间锁：不需要向操作系统申请）</p><p>偏向锁：<strong>把markword线程ID改为自己线程的ID</strong></p><p>StringBuffer加synchronized上的就是偏向锁，前提是没竞争条件下。</p><p><strong>如果有线程竞争，偏向锁撤销，升级为自旋锁：竞争条件下的线程在线程栈内部，生成LR（LockRecord 锁记录）。自旋的方式相互竞争锁，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁，其它锁会CAS的一直监控此锁是否释放（自旋等待），自旋超过10次后，会自动升级为重量级锁</strong></p><p>重量级锁：需要向操作系统申请锁</p><blockquote><p>看操作系统的interpreterRuntime.cpp文件</p></blockquote><p>锁重入</p><p>synchronized  是可重入锁</p><p>重入次数必须记录，因为要解锁几次必须对应</p><p>偏向锁重入次数记录在线程栈的里LR中，每重入一次+1，</p><h3 id="什么时候自旋锁升级为重量级锁？"><a href="#什么时候自旋锁升级为重量级锁？" class="headerlink" title="什么时候自旋锁升级为重量级锁？"></a>什么时候自旋锁升级为重量级锁？</h3><p>竞争加剧：有线程超过10次自旋，-XX:PreBlockSpin，或者自旋线程数超过CPU核数的一半，1.6之后，加入自适应自旋Adapative Self Spinning，JVM自己控制</p><h3 id="为什么有自旋锁还需要有重量级锁？"><a href="#为什么有自旋锁还需要有重量级锁？" class="headerlink" title="为什么有自旋锁还需要有重量级锁？"></a>为什么有自旋锁还需要有重量级锁？</h3><p>自旋消耗资源，如果锁的时间长，数量多，CPU会大量消耗。</p><p>重量级锁：有等待队列</p><p>在自旋锁升级为重量级锁时，自旋的线程都会放到队列（waitSet），不需要消耗资源。</p><h3 id="偏向锁未启动与已启动"><a href="#偏向锁未启动与已启动" class="headerlink" title="偏向锁未启动与已启动"></a>偏向锁未启动与已启动</h3><p>偏向锁是否一定比自旋锁效率高？</p><p>不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁。</p><p>JVM启动时会有多线程竞争，这是默认关闭偏向锁，过一段时间再打开</p><p>偏向锁启动延时</p><p>对象new出来时可能偏向锁就已经启动，此情况叫匿名偏向，偏向锁没有偏向任何一个线程。</p><p><del>这个图已经在文件夹里了，不贴浪费了</del></p><p><img src="/2022/05/12/synchronized%E6%B5%85%E8%81%8A/yinzi.png" alt="yinzi"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h3&gt;&lt;p&gt;模拟银行账户，对业务写方法加锁，对业务读方法不加锁，这样行不行？&lt;/p&gt;</summary>
    
    
    
    <category term="多线程与高并发" scheme="http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与高并发" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程三大特性</title>
    <link href="http://example.com/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</id>
    <published>2022-05-12T01:47:21.000Z</published>
    <updated>2022-05-12T01:53:12.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发编程之可见性"><a href="#并发编程之可见性" class="headerlink" title="并发编程之可见性"></a>并发编程之可见性</h2><p>加入一个线程t1运行时使用一个变量（把这个变量从主存复制下来存到线程内部），这时线程t2修改了这个变量，但是t1线程无法读到修改后的变量值。这就是线程的不可见性。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * volatile 关键字，使一个变量在多个线程间可见</span><br><span class="line"> * A B线程都用到一个变量，java默认是A线程中保留一份copy，这样如果B线程修改了该变量，则A线程未必知道</span><br><span class="line"> * 使用volatile关键字，会让所有线程都会读到变量的修改值</span><br><span class="line"> * </span><br><span class="line"> * 在下面的代码中，running是存在于堆内存的t对象中</span><br><span class="line"> * 当线程t1开始运行的时候，会把running值从内存中读到t1线程的工作区，在运行过程中直接使用这个copy，并不会每次都去</span><br><span class="line"> * 读取堆内存，这样，当主线程修改running的值之后，t1线程感知不到，所以不会停止运行</span><br><span class="line"> * </span><br><span class="line"> * 使用volatile，将会强制所有线程都去堆内存中读取running的值</span><br><span class="line"> * </span><br><span class="line"> * volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</span><br><span class="line"> *</span><br><span class="line"> * @author mashibing</span><br><span class="line"> */</span><br><span class="line">package com.mashibing.juc.c_001_00_Visibility;</span><br><span class="line"></span><br><span class="line">import com.mashibing.util.SleepHelper;</span><br><span class="line"></span><br><span class="line">public class T01_HelloVolatile &#123;</span><br><span class="line">    private static volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">    private static void m() &#123;</span><br><span class="line">        System.out.println(&quot;m start&quot;);</span><br><span class="line">        while (running) &#123;</span><br><span class="line">            //System.out.println(&quot;hello&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;m end!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new Thread(T01_HelloVolatile::m, &quot;t1&quot;).start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(1);</span><br><span class="line"></span><br><span class="line">        running = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用volatile，将会强制所有线程都去堆内存中读取running的值</strong></p><p>volatile修饰的代码，字节码解释器会有一个叫lock的前置指令修饰，这个lock指令的作用就是：会等待它之前的所有指令完成，并将所有缓冲的写操作写到内存，根据缓存一致性协议，缓存的副本将会失效，并且禁止该指令与其前后的读写指令进行重排序</p><p><strong>volatile并不能保证多个线程共同修改running变量时所带来的不一致问题，也就是说volatile不能替代synchronized</strong></p><blockquote><p>volatile</p><ul><li>保证线程可见性<ul><li>MESI</li><li>缓存一致性协议</li></ul></li><li>禁止指令重排序<ul><li>DCL单例模式双重校验加volatile</li><li>loadfence原语指令（内存屏障CPU原语）</li><li>storefence原语指令（内存屏障CPU原语）</li></ul></li></ul></blockquote><p>在变量中加入volatile修饰可以保证线程的可见性，但变量修改时，会同步进t1线程中。另外在某些语句执行的时候（例如println，因为它源码中被synchronized修饰），会触发本地缓存与主内存之间的同步。</p><p>volatile修饰引用类型（包括数组）只能保证引用本身的可见性，而不能保证内部字段的可见性。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class A&#123;</span><br><span class="line">boolean running = true;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">private volatile static A a = new A();</span><br></pre></td></tr></table></figure><p>能保证a的可见性，而running不能。</p><h3 id="缓存行对齐"><a href="#缓存行对齐" class="headerlink" title="缓存行对齐"></a>缓存行对齐</h3><ul><li>缓存行对齐<br>缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高<br>Disruptor也是类似写法</li><li><strong>认识缓存行对齐的编程技巧：因为空间局部性原理，线程读内存数据时会预读它周围内存的数据，而如果多个线程需要的变量恰好相邻（t1需要x1，t2需要x2，x1，x2相邻，t1，t2会把它们都读入线程内），那么线程修改变量的时候，线程之间必须保证缓存一致性，所以会相互同步变量。这个操作也需要消耗资源，减慢效率。</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class T01_CacheLinePadding &#123;</span><br><span class="line">    public static long COUNT = 10_0000_0000L;</span><br><span class="line"></span><br><span class="line">    private static class T &#123;</span><br><span class="line">        private long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">        public long x = 0L;</span><br><span class="line">        private long p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static T[] arr = new T[2];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        arr[0] = new T();</span><br><span class="line">        arr[1] = new T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        CountDownLatch latch = new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (long i = 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">                arr[0].x = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (long i = 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">                arr[1].x = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        final long start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/100_0000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注：JUC"><a href="#注：JUC" class="headerlink" title="注：JUC"></a>注：JUC</h3><h4 id="tools（工具类）：又叫信号量三组工具类，包含有"><a href="#tools（工具类）：又叫信号量三组工具类，包含有" class="headerlink" title="tools（工具类）：又叫信号量三组工具类，包含有"></a>tools（工具类）：又叫信号量三组工具类，包含有</h4><p>1）CountDownLatch（闭锁） 是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待</p><p>2）CyclicBarrier（栅栏） 之所以叫barrier，是因为是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 ，并且在释放等待线程后可以重用。</p><p>3）Semaphore（信号量） 是一个计数信号量，它的本质是一个“共享锁“。信号量维护了一个信号量许可集。线程可以通过调用 acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。</p><h4 id="executor-执行者-：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有："><a href="#executor-执行者-：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：" class="headerlink" title="executor(执行者)：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有："></a>executor(执行者)：是Java里面线程池的顶级接口，但它只是一个执行线程的工具，真正的线程池接口是ExecutorService，里面包含的类有：</h4><p>1）ScheduledExecutorService 解决那些需要任务重复执行的问题</p><p>2）ScheduledThreadPoolExecutor 周期性任务调度的类实现</p><h4 id="atomic-原子性包-：是JDK提供的一组原子操作类，"><a href="#atomic-原子性包-：是JDK提供的一组原子操作类，" class="headerlink" title="atomic(原子性包)：是JDK提供的一组原子操作类，"></a>atomic(原子性包)：是JDK提供的一组原子操作类，</h4><p>包含有AtomicBoolean、AtomicInteger、AtomicIntegerArray等原子变量类，他们的实现原理大多是持有它们各自的对应的类型变量value，而且被volatile关键字修饰了。这样来保证每次一个线程要使用它都会拿到最新的值。</p><h4 id="locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有："><a href="#locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有：" class="headerlink" title="locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有："></a>locks（锁包）：是JDK提供的锁机制，相比synchronized关键字来进行同步锁，功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁包含的实现类有：</h4><p>1）ReentrantLock 它是独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。</p><p>2）ReentrantReadWriteLock 它包括子类ReadLock和WriteLock。ReadLock是共享锁，而WriteLock是独占锁。</p><p>3）LockSupport 它具备阻塞线程和解除阻塞线程的功能，并且不会引发死锁。</p><h4 id="collections-集合类-：主要是提供线程安全的集合，-比如："><a href="#collections-集合类-：主要是提供线程安全的集合，-比如：" class="headerlink" title="collections(集合类)：主要是提供线程安全的集合， 比如："></a>collections(集合类)：主要是提供线程安全的集合， 比如：</h4><p>1）ArrayList对应的高并发类是CopyOnWriteArrayList，</p><p>2）HashSet对应的高并发类是 CopyOnWriteArraySet，</p><p>3）HashMap对应的高并发类是ConcurrentHashMap等等</p><p><a href="https://blog.csdn.net/weixin_43888181/article/details/116546374">(31条消息) java–JUC快速入门（彻底搞懂JUC）_YANG-Π的博客-CSDN博客_java juc</a></p><h3 id="Contended注解"><a href="#Contended注解" class="headerlink" title="Contended注解"></a>Contended注解</h3><p><strong>需要注意，JDK8引入了@sun.misc.Contended注解（只有1.8有），来保证缓存行隔离效果</strong><br>要使用此注解，必须去掉限制参数：-XX:-RestrictContended</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_001_02_FalseSharing;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Contended;</span><br><span class="line"><span class="comment">//注意：运行这个小程序的时候，需要加参数：-XX:-RestrictContended</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T05_Contended</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">COUNT</span> <span class="operator">=</span> <span class="number">10_0000_0000L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">        <span class="meta">@Contended</span>  <span class="comment">//只有1.8起作用 , 保证x位于单独一行中</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="并发编程之有序性"><a href="#并发编程之有序性" class="headerlink" title="并发编程之有序性"></a>并发编程之有序性</h2><p>为何会存在乱序：为了提高效率</p><p>乱序存在的条件：</p><ul><li>as - if - serial     看上去像是序列化（单线程）</li><li>不影响单线程的最终一致性</li></ul><h3 id="对象实例化的过程："><a href="#对象实例化的过程：" class="headerlink" title="对象实例化的过程："></a>对象实例化的过程：</h3><ol><li>申请一个内存，成员变量赋默认值（半初始化状态）</li><li>调用构造方法，成员变量赋初始值（初始化完成）</li><li>与引用建立关联</li></ol><p><img src="/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/Users\Sunny\AppData\Roaming\Typora\typora-user-images\image-20220427205346934.png" alt="image-20220427205346934"></p><p><strong>步骤2与步骤3可能会互换顺序，这个现象叫做指令重排，如果在构造方法中new线程同时启动线程，在指令重排的情况下，中间可能this可能会得到值为默认值0的变量，所以不要在构造方法中启动线程。</strong></p><p>美团面试题：</p><ol><li>请解释一下对象的创建过程（半初始化）</li><li>DCL与volatile问题（指令重排）</li><li>对象在内存中的存储布局（对象与数组的存储不同）</li><li>对象头具体包括什么（markword klasspointer  synchronized）</li><li>对象怎么定位（直接 间接）</li><li>对象怎么分配（栈上-线程本地-Eden-Old）</li><li>Object o = new Object() 在内存中占用多少字节？</li></ol><h3 id="使用内存屏障阻止乱序执行"><a href="#使用内存屏障阻止乱序执行" class="headerlink" title="使用内存屏障阻止乱序执行"></a>使用内存屏障阻止乱序执行</h3><p>内存屏障是特殊指令：看到这种指令，前面的必须执行完，后面的才能执行</p><p>intel : lfence sfence mfence(CPU特有指令)</p><h3 id="JVM中的内存屏障"><a href="#JVM中的内存屏障" class="headerlink" title="JVM中的内存屏障"></a>JVM中的内存屏障</h3><p>所有实现JVM规范的虚拟机，必须实现以下四个屏障：</p><p>LoadLoadBarrier LoadStoreBarrier StoreLoadBarrier StoreStorBarriere（Load：读 Store：写）</p><h3 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h3><p>Volatile修饰的变量如下图会建立内存屏障，屏障两边的指令不可以重排！保障有序！</p><p><img src="/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/Users\Sunny\AppData\Roaming\Typora\typora-user-images\image-20220428231755226.png" alt="image-20220428231755226"></p><p>volatile在hotspot中的底层实现</p><p>orderaccess_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (os::<span class="built_in">is_MP</span>()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AMD64</span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%rsp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>LOCK 用于在多处理器中执行指令时对共享内存的独占使用。<br>它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。</strong><br><strong>另外还提供了有序的指令无法越过这个内存屏障的作用。</strong></p></blockquote><h2 id="并发编程之原子性"><a href="#并发编程之原子性" class="headerlink" title="并发编程之原子性"></a>并发编程之原子性</h2><p>race condition: 竞争条件 ， 指的是多个线程访问共享数据的时候产生竞争。</p><p>在有多线程之间有竞争条件下，可能会导致数据的不一致（unconsistency)，比如多个线程操作的变量在并发访问之下产生的不期望出现的结果。</p><h3 id="如何保障数据一致？"><a href="#如何保障数据一致？" class="headerlink" title="如何保障数据一致？"></a>如何保障数据一致？</h3><p>本质上是线程同步的问题（线程执行的顺序安排好），synchronized可以解决此问题。</p><p>synchronized：保证原子性，可见性</p><p>monitor （管程），如下代码，synchronized (o)中对象o即为monitor 。</p><p>critical section （临界区），如下代码，{}内的部分为临界区。</p><p>如果临界区执行时间长，语句多，叫做 锁的粒度比较粗，反之，就是锁的粒度比较细。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (o) &#123; </span><br><span class="line">              System.out.println(Thread.currentThread().getName() + &quot; start!&quot;);</span><br><span class="line">              SleepHelper.sleepSeconds(2);</span><br><span class="line">              System.out.println(Thread.currentThread().getName() + &quot; end!&quot;);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>在被synchronized修饰的条件下，多线程竞争临界区的操作，必须要等持有锁的线程执行完，释放锁之后才能由下一个线程去执行。所以临界区的代码都具有原子性，synchronized也是用此方法保证可见性的。</p><p>上锁的本质是吧并发编程序列化，上锁的代码这个线程执行完，另一个才能执行。</p><p>锁分为两种：</p><ul><li><p>悲观锁：悲观的认为这个操作会被别的线程打断（悲观锁）如：synchronized</p></li><li><p>乐观锁：乐观的认为这个做不会被别的线程打断（乐观锁 自旋锁 无锁）如：cas操作<br>CAS = Compare And Set/Swap/Exchange</p><p>乐观锁：不行就重来!</p></li></ul><h3 id="CAS的深度剖析"><a href="#CAS的深度剖析" class="headerlink" title="CAS的深度剖析"></a>CAS的深度剖析</h3><p>CAS:Compare And Set/Exchange，比较并且设定</p><p>CAS（V，Expected，NewValue）：</p><p>​    if(V == E)</p><p>​    V = New</p><p>​    otherwise try again or fail</p><p><strong>CPU原语支持CAS操作</strong></p><p><img src="/2022/05/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/CAS.png" alt="CAS"></p><p>CAS的ABA问题解决方案 - Version</p><p>因为CAS判断的过程不能被打断，所以要求CAS本身必须是原子性的</p><p>操作系统底层本身也支持CAS</p><h4 id="从AtomicInteger入手深入源码剖析CAS"><a href="#从AtomicInteger入手深入源码剖析CAS" class="headerlink" title="从AtomicInteger入手深入源码剖析CAS"></a>从AtomicInteger入手深入源码剖析CAS</h4><p>AtomicInteger:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Unsafe:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br></pre></td></tr></table></figure><p>运用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">T02_TestUnsafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">T02_TestUnsafe</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T02_TestUnsafe</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> T02_TestUnsafe.class.getDeclaredField(<span class="string">&quot;i&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: unsafe.cpp:</p><p>cmpxchg = compare and exchange set swap</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNSAFE_ENTRY</span>(jboolean, <span class="built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  <span class="built_in">UnsafeWrapper</span>(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line">  oop p = JNIHandles::<span class="built_in">resolve</span>(obj);</span><br><span class="line">  jint* addr = (jint *) <span class="built_in">index_oop_from_field_offset_long</span>(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::<span class="built_in">cmpxchg</span>(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></p><p>is_MP = Multi Processors  （CPU多核）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: os.hpp is_MP()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_IF_MP(mp) <span class="string">&quot;cmp $0, &quot;</span> #mp <span class="string">&quot;; je 1f; lock; 1: &quot;</span></span></span><br></pre></td></tr></table></figure><p>最终实现：</p><p>cmpxchg = cas修改变量值</p><p><strong>cmpxchg 在汇编语句上不是原子性的，所以加上了lock</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure><p>硬件：</p><p>lock指令在执行的时候视情况采用缓存锁或者总线锁，如上lock cmpxchg 指令，某个CPU在改动内存的值的时候，会把总线（或其他什么东西）锁上，等CPU改动完并返回之后再解开锁。所以CAS说是乐观锁，但在底层的实现还是很像悲观锁。</p><p>乐观锁效率不一定比悲观锁高，</p><p>如果临界区执行时间比较长，等的线程又很多 -&gt; 重量级</p><p>时间短，等的线程少 -&gt; 自旋锁</p><h3 id="synchronized如何保障可见性？"><a href="#synchronized如何保障可见性？" class="headerlink" title="synchronized如何保障可见性？"></a>synchronized如何保障可见性？</h3><p>解锁之后，要把内存的状态与本地的缓存做一次刷新对比，之后下个线程才会继续</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;并发编程之可见性&quot;&gt;&lt;a href=&quot;#并发编程之可见性&quot; class=&quot;headerlink&quot; title=&quot;并发编程之可见性&quot;&gt;&lt;/a&gt;并发编程之可见性&lt;/h2&gt;&lt;p&gt;加入一个线程t1运行时使用一个变量（把这个变量从主存复制下来存到线程内部），这时线程t2修改了这个变量，但是t1线程无法读到修改后的变量值。这就是线程的不可见性。&lt;/p&gt;</summary>
    
    
    
    <category term="多线程与高并发" scheme="http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与高并发" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程基础</title>
    <link href="http://example.com/2022/05/12/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/05/12/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-12T01:10:11.000Z</published>
    <updated>2022-05-12T01:46:22.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>程序是操作系统能运行的文件</strong></p><p>进程是运行的程序</p><p>一个程序可以有多个进程</p><p><strong>进程：进程是操作系统进行资源分配的基本单位</strong></p><span id="more"></span><p>多进程并行处理：把程序写在不同的内存位置上来回切换</p><p>多线程并行处理：一个程序内部不同任务的来回切换</p><p>通俗来讲：</p><ul><li><p>线程：程序里不同的执行路径</p></li><li><p>mian方法开启的线程叫做主线程</p></li></ul><p><strong>线程：调度执行的基本单位</strong></p><ul><li>一个程序执行的时候，内存会先找到它的主线程，推送给CPU执行，主线程执行时可能会开启其他线程，这时就涉及到线程之间的切换</li></ul><p><strong>线程切换也是需要资源的</strong></p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li><p>单核CPU设定多线程是否有意义？</p><p>有意义</p><p>CPU密集型：计算多，IO密集型：输入输出多</p></li><li><p>工作线程数是不是设置的越大越好</p><p>不是，线程切换也需要消耗资源</p></li><li><p>工作线程数（线程池中线程数）设为多少最合适？</p><p>N = N（CPU）+ U（CPU）* （1 + W / C）</p><p>N（CPU）是处理器核的数目</p><p>U（CPU）是期望的CPU利用率（0 - 1）</p><p>W / C 是等待时间与计算时间的比率</p></li></ol><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>创建线程的5种方法</p><ol><li><p>new MyThread().start()  MyThread扩展了Thread类，重写run方法</p></li><li><p>new Thread(new r()).start()  r继承了Runnable接口，重写run方法</p></li><li><p>new Thread(lamda).start()  使用lamda表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Thread(()-&gt;&#123;</span><br><span class="line">System.out.println(&quot;Hello Lambda&quot;);</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure></li><li><p>ThreadPool 线程池  Executors.newCachedThrad</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">service.execute(()-&gt;&#123;</span><br><span class="line">System.out.println(&quot;Hello ThreadPool&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Future Callable and FutureTask</p><p>Callable  与 Runnable很类似，但继承Callable时，可以通过泛型指定返回类型，在通过线程池得到，用Future<T> 接收</T></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; f = service.submit(new MyCall());</span><br><span class="line">String s = f.get();</span><br></pre></td></tr></table></figure><p>FutureTask类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new MyCall());</span><br><span class="line">Thread t = new Thread(task);</span><br><span class="line">s.start();</span><br><span class="line">System.out.println(task.get());</span><br></pre></td></tr></table></figure></li></ol><h2 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h2><p>sleep():当前线程暂停一段时间。</p><p>yield():退出CPU，进入等待队列（返回就绪状态）</p><p>join():t2线程里使用t1.join()，t1线程加入t2线程中，等t2执行完，再执行t1。经常用来等待另一个线程结束</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态*"></a>线程的状态*</h2><p><strong>小节说明：</strong></p><ul><li>本节重要程度：中 （帮助理解线程问题，保障知识完整性，面试很少考）  </li><li>本节难度：低</li></ul><p>Java线程的6种状态：</p><p><img src="/2022/05/12/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/zhuangtai.png" alt="zhuangtai"></p><ol><li>NEW：线程刚刚被创建还没有启动</li><li>RANNABLE：可运行状态</li><li>WAITING：等待被唤醒</li><li>TIMED WAITING：隔一段时间后自动唤醒</li><li>BLOCKED：被阻塞，正在等待锁</li><li>TERMINATED：线程结束</li></ol><p>每个线程只能start一次</p><p><strong>lock方法用的是JUC的CAS上锁，忙等待</strong>，不会陷入BLOCKED状态，而是WAITING</p><h2 id="线程的打断"><a href="#线程的打断" class="headerlink" title="线程的打断*"></a>线程的打断*</h2><ul><li>interrupt()：实例方法，设置线程的中断标志位，线程自己决定是否中断</li><li>isInterrupted()：实例方法，有没有人打扰我？</li><li>interrupted()：静态方法，有没有人打扰我（当前线程）？复位！</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Thread.java  </span><br><span class="line">public void interrupt()            //t.interrupt() 打断t线程（设置t线程某给标志位f=true，并不是打断线程的运行）</span><br><span class="line">public boolean isInterrupted()     //t.isInterrupted() 查询打断标志位是否被设置（是不是曾经被打断过）</span><br><span class="line">public static boolean interrupted()//Thread.interrupted() 查看“当前”线程是否被打断，如果被打断，恢复标志位</span><br></pre></td></tr></table></figure><p>线程使用sleep(),wait(),jion()这些方法时，会设置中断标志位，同时，也会抛出interruptedException异常，在抛出这个异常的时候，可以做某些操作，同时也会重置标志位。</p><p>interrupt()不能打断正在竞争锁的线程synchronized()和lock()</p><p>如果想打断正在竞争锁的线程，使用ReentrantLock的lockInterruptibly()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * interrupt与lockInterruptibly()</span><br><span class="line"> */</span><br><span class="line">public class T11_Interrupt_and_lockInterruptibly &#123;</span><br><span class="line"></span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t1 = new Thread(()-&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                SleepHelper.sleepSeconds(10);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;t1 end!&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(()-&gt; &#123;</span><br><span class="line">            System.out.println(&quot;t2 start!&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lockInterruptibly();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;t2 end!&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        SleepHelper.sleepSeconds(1);</span><br><span class="line">        </span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的结束"><a href="#线程的结束" class="headerlink" title="线程的结束"></a>线程的结束</h2><p>面试题：</p><p>如何优雅的结束一个线程？</p><p>e.g.上传一个大文件，正在处理费时的计算，如何优雅的结束这个线程？</p><p>结束线程的方法：</p><ol><li>自然结束（能自然结束就尽量自然结束）</li><li>stop() suspend() resume()，现在已经不推荐用了，可能会导致数据的不一致</li><li>volatile标志<ol><li>不适合某些场景（比如还没有同步的时候，线程做了阻塞操作，没有办法循环回去）</li><li>打断时间也不是特别精确，比如一个阻塞容器，容量为5的时候结束生产者，<br>但是，由于volatile同步线程标志位的时间控制不是很精确，有可能生产者还继续生产一段儿时间</li></ol></li><li>interrupt() and isInterrupted（比较优雅）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">while(!Thread.interrupted())&#123;</span><br><span class="line">//sleep wait</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;t1 end!&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">SleepHelper.sleepSeconds(1);</span><br><span class="line"></span><br><span class="line">t.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;程序是操作系统能运行的文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程是运行的程序&lt;/p&gt;
&lt;p&gt;一个程序可以有多个进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程：进程是操作系统进行资源分配的基本单位&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="多线程与高并发" scheme="http://example.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="多线程与高并发" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/05/11/hello-world/"/>
    <id>http://example.com/2022/05/11/hello-world/</id>
    <published>2022-05-11T12:52:19.717Z</published>
    <updated>2021-08-03T01:55:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://example.com/2021/10/05/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://example.com/2021/10/05/%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2021-10-05T01:43:57.000Z</published>
    <updated>2021-11-29T09:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><span id="more"></span><p>思路绝大多数来自于 <em>代码随想录</em>，只为个人学习与总结</p><h2 id="有效的字母同异位"><a href="#有效的字母同异位" class="headerlink" title="有效的字母同异位"></a>有效的字母同异位</h2><p><a href="https://leetcode-cn.com/problems/valid-anagram/">242.有效的字母同异位</a></p><p>数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//LC242</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        int[] record = new int[26];</span><br><span class="line">        for(char item : s.toCharArray()) &#123;</span><br><span class="line">            record[item - &#x27;a&#x27;] += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(char item : t.toCharArray()) &#123;</span><br><span class="line">            record[item - &#x27;a&#x27;] -=1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0; i&lt;record.length; i++) &#123;</span><br><span class="line">            if(record[i] != 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找共用字符"><a href="#查找共用字符" class="headerlink" title="查找共用字符"></a>查找共用字符</h2><p><a href="https://leetcode-cn.com/problems/find-common-characters/">1002. 查找共用字符</a></p><p>整体思路就是统计出搜索字符串里26个字母的出现的频率，然后取每个字符频率最小值，最后转成输出格式即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; commonChars(String[] words) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if(words.length == 0)&#123;return res;&#125;</span><br><span class="line">        int[] hash = new int[26];</span><br><span class="line">        </span><br><span class="line">        for(char c : words[0].toCharArray())&#123;</span><br><span class="line">            hash[c - &#x27;a&#x27;] += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=1; i&lt;words.length; i++)&#123;</span><br><span class="line">            int[] other = new int[26];</span><br><span class="line">            for(char c : words[i].toCharArray())&#123;</span><br><span class="line">                other[c - &#x27;a&#x27;] += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int k = 0; k&lt;26; k++)&#123;</span><br><span class="line">                hash[k] = Math.min(hash[k],other[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 26; i++)&#123;</span><br><span class="line">            while(hash[i] !=0 )&#123;</span><br><span class="line">                char c = (char)(i + &#x27;a&#x27;);</span><br><span class="line">                res.add(String.valueOf(c));</span><br><span class="line">                hash[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a><br>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。<br>上面题目使用数组来做哈希的题目，是因为题目都限制了数值的大小。</p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        </span><br><span class="line">        if((nums1 == null) || (nums1.length == 0) || (nums2 == null) || (nums2.length == 0))&#123;</span><br><span class="line">            return new int[0]; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; res = new HashSet&lt;&gt;();</span><br><span class="line">        for(int item : nums1)&#123;</span><br><span class="line">            set.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int item : nums2)&#123;</span><br><span class="line">            if(set.contains(item))&#123;</span><br><span class="line">                res.add(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] arr = new int[res.size()];</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(int item : res)&#123;</span><br><span class="line">            arr[i++] = item;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p><a href="https://leetcode-cn.com/problems/happy-number/">202.快乐数</a></p><p>快速判断集合里是否有某个数，往往会想到哈希表。下面代码中set.contains(n)正是set的关键功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        while(n!=1 &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            </span><br><span class="line">            set.add(n);n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        return n == 1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    private int getNext(int n)&#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while(n != 0)&#123;</span><br><span class="line">            int temp = n%10;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            n = n/10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四数相加-II"><a href="#四数相加-II" class="headerlink" title="四数相加 II"></a>四数相加 II</h2><p><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i : nums1)&#123;</span><br><span class="line">            for(int j : nums2)&#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                if(map.containsKey(temp))&#123;</span><br><span class="line">                    map.put(temp, map.get(temp)+1);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    map.put(temp, 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i : nums3)&#123;</span><br><span class="line">            for(int j : nums4)&#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                if(map.containsKey(0 - temp))&#123;</span><br><span class="line">                    res += map.get(0 - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p><a href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信</a></p><p>因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。</p><p>然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canConstruct(String ransomNote, String magazine) &#123;</span><br><span class="line">        int[] arr = new int[26];</span><br><span class="line">        for(int i=0; i&lt;magazine.length(); i++)&#123;</span><br><span class="line">            int temp = magazine.charAt(i) - &#x27;a&#x27;;</span><br><span class="line">            arr[temp]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i&lt;ransomNote.length(); i++)&#123;</span><br><span class="line">            int temp = ransomNote.charAt(i) - &#x27;a&#x27;;</span><br><span class="line">            if(arr[temp] &gt; 0)&#123;</span><br><span class="line">                arr[temp]--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;一般哈希表都是用来快速判断一个元素是否出现集合里。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="代码" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis基础</title>
    <link href="http://example.com/2021/09/17/MyBatis%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/09/17/MyBatis%E5%9F%BA%E7%A1%80/</id>
    <published>2021-09-16T23:58:27.000Z</published>
    <updated>2021-09-17T00:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis的简介"><a href="#MyBatis的简介" class="headerlink" title="MyBatis的简介"></a>MyBatis的简介</h1><span id="more"></span><h2 id="原始jdbc操作"><a href="#原始jdbc操作" class="headerlink" title="原始jdbc操作"></a>原始jdbc操作</h2><ul><li>查询数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driber&quot;);</span><br><span class="line">//获得连接</span><br><span class="line">Connection connection=DriverManager.getConnection(&quot;jdbc:mysql:///test&quot;,&quot;root&quot;,&quot;mysql&quot;);</span><br><span class="line">//获得statement</span><br><span class="line">PrepareStatement statement=connection.prepareStatement(&quot;select id,username,password from user&quot;);</span><br><span class="line">//执行查询</span><br><span class="line">ResultSet resultSet=statement.executeQuery();</span><br><span class="line">//遍历结果集</span><br><span class="line">while(resultSet.next())&#123;</span><br><span class="line">User user=new User();</span><br><span class="line">user.setid(resultSet.get(&quot;id&quot;));</span><br><span class="line">user.setUsername((resultSet.getString(&quot;username&quot;))</span><br><span class="line">user.setPassword((resultSet.getString(&quot;password&quot;</span><br><span class="line">System.out.println(user);</span><br><span class="line">))</span><br><span class="line">&#125;</span><br><span class="line">//释放资源</span><br><span class="line">resultSet.close();</span><br><span class="line">statement.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><ul><li>插入数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="原始jdbc操作的分析"><a href="#原始jdbc操作的分析" class="headerlink" title="原始jdbc操作的分析"></a>原始jdbc操作的分析</h2><ul><li>原始jdbc开发存在的问题如下：<br>  1.数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能<br>  2.sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。<br>  3.查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置</li><li>应对上述问题给出的解决方案：<br>  1.使用数据库连接池初始化连接资源<br>  2.将sql语句抽取到xml配置文件中<br>  3.使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</li></ul><h2 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h2><ul><li>mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li><li>mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</li><li>最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。</li></ul><h1 id="MyBatis的快速入门"><a href="#MyBatis的快速入门" class="headerlink" title="MyBatis的快速入门"></a>MyBatis的快速入门</h1><h2 id="MyBatis开发步骤"><a href="#MyBatis开发步骤" class="headerlink" title="MyBatis开发步骤"></a>MyBatis开发步骤</h2><ul><li>添加MyBatis的坐标</li><li>创建user数据表</li><li>编写User实体类 </li><li>编写映射文件UserMapper.xml</li><li>编写核心文件SqlMapConfig.xml</li><li>编写测试类</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li><p>导入MyBatis的坐标和其他相关坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis坐标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--mysql驱动坐标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--单元测试坐标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--日志坐标--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建user数据表</p></li><li><p>编写User实体</p></li><li><p>编写UserMapper映射文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;userMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt;</span><br><span class="line">        select * from User</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写MyBatis核心文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;&lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//加载核心配置文件</span><br><span class="line">InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);</span><br><span class="line">//获得sqlSession工厂对象</span><br><span class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">//获得sqlSession对象</span><br><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">//执行sql语句</span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);</span><br><span class="line">//打印结果</span><br><span class="line">System.out.println(userList);</span><br><span class="line">//释放资源</span><br><span class="line">sqlSession.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="MyBatis的映射文件概述"><a href="#MyBatis的映射文件概述" class="headerlink" title="MyBatis的映射文件概述"></a>MyBatis的映射文件概述</h1><h1 id="MyBatis的增删改查操作"><a href="#MyBatis的增删改查操作" class="headerlink" title="MyBatis的增删改查操作"></a>MyBatis的增删改查操作</h1><h1 id="MyBatis的核心配置文件概述"><a href="#MyBatis的核心配置文件概述" class="headerlink" title="MyBatis的核心配置文件概述"></a>MyBatis的核心配置文件概述</h1><h1 id="MyBatis的相应API"><a href="#MyBatis的相应API" class="headerlink" title="MyBatis的相应API"></a>MyBatis的相应API</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MyBatis的简介&quot;&gt;&lt;a href=&quot;#MyBatis的简介&quot; class=&quot;headerlink&quot; title=&quot;MyBatis的简介&quot;&gt;&lt;/a&gt;MyBatis的简介&lt;/h1&gt;</summary>
    
    
    
    <category term="Java框架" scheme="http://example.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
    <category term="Java框架" scheme="http://example.com/tags/Java%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://example.com/2021/09/15/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/09/15/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-15T01:19:49.000Z</published>
    <updated>2021-09-29T11:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法模板"><a href="#回溯算法模板" class="headerlink" title="回溯算法模板"></a>回溯算法模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>代码绝大多数来自于 <em>代码随想录</em>，只为个人学习与总结</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠split.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//LC77</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        dfs(n,k,1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int n,int k,int split)&#123;</span><br><span class="line">        //终止条件</span><br><span class="line">        if(path.size()==k)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //n - (k - path.size()) + 1是剪枝条件,原本是写成i&lt;=n。</span><br><span class="line">        //还需要的元素个数为: k - path.size();</span><br><span class="line">        //在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</span><br><span class="line">        //为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</span><br><span class="line">        for(int i=split;i&lt;=n - (k - path.size()) + 1;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            dfs(n,k,i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//LC216</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        dfs(k,n,1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //可以去掉sum，用n-i，最后n==0存储</span><br><span class="line">    public void dfs(int k,int n,int split)&#123;</span><br><span class="line">        //剪枝</span><br><span class="line">        if(n&lt;0)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(path.size()==k)&#123;</span><br><span class="line">            if(n==0)&#123;res.add(new ArrayList&lt;&gt;(path));&#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //剪枝，9-(k-path.size())+1</span><br><span class="line">        for(int i=split;i&lt;=9-(k-path.size())+1;i++)&#123;</span><br><span class="line">            n-=i;</span><br><span class="line">            path.add(i);</span><br><span class="line">            dfs(k,n,i+1);</span><br><span class="line">            //回溯</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">            n+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p>这道题的难点如下：<br>1.数字和字母如何映射<br>    这里可以用数组下边与字母一一对应来映射。<br>    String[] numString={“”,””,”abc”,”def”,”ghi”,”jkl”,”mno”,”pqrs”,”tuv”,”wxyz”};</p><p>2.两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来，所以我们要用回溯算法。</p><p>3.输入1 * #按键等等异常情况</p><ul><li><p>就是用str.charAt(i)的码值减去‘0’的码值，得到的值干好就是s中第i个字符的十进制值。</p></li><li><p>StringBuffer<br>  StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。</p></li><li><p>StringBuilder<br>  StringBuilder类也代表可变字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//LC17</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">    String[] numString=&#123;&quot;&quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;;</span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        if(digits == null || digits.length() == 0) &#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(digits,0);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    //每次迭代获取一个字符串，所以会涉及大量的字符串拼接，所以这里选择更为高效的 StringBuild</span><br><span class="line">    StringBuilder temp=new StringBuilder();</span><br><span class="line">    public void dfs(String digits, int num) &#123;</span><br><span class="line">        if(num == digits.length())&#123;</span><br><span class="line">            list.add(temp.toString());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String str = numString[digits.charAt(num)-&#x27;0&#x27;];</span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            temp.append(str.charAt(i));</span><br><span class="line">            dfs(digits, num + 1);</span><br><span class="line">            temp.deleteCharAt(temp.length()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><p>注意这里有个剪枝条件是target - candidates[i] &gt;= 0，它意味着如果不符合此条件，这次for循环会终止，进入下一次for循环，也就是说，这次for循环里的深度遍历不会进行下去，这次for循环中candidates[i]之后的数也不会去进行了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//LC39</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates); // 先进行排序</span><br><span class="line">        dfs(candidates, target, 0);</span><br><span class="line">        return res; </span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int[] candidates, int target,int start)&#123;</span><br><span class="line">        // if(target&lt;0)&#123;</span><br><span class="line">        //     return;</span><br><span class="line">        // &#125;</span><br><span class="line">        if(target==0)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = start; i &lt; candidates.length &amp;&amp; target - candidates[i] &gt;= 0; i++)&#123;</span><br><span class="line">            // if (target - candidates[i] &lt; 0) &#123;break;&#125;</span><br><span class="line">            // target -= candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            //注意对target的操作在递归的形参里。</span><br><span class="line">            dfs(candidates,target - candidates[i],i);</span><br><span class="line">            // target += candidates[i];</span><br><span class="line">            path.remove(path.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>LC40与LC39相似，但区别在于：集合（数组candidates）有重复元素，但还不能有重复的组合。用set或者map去重很容易超时。<br>所谓去重，其实就是使用过的元素不能重复选取，都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<br>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。</strong><br>所以此题还需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。</p><p>这个集合去重的重任就是used来完成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//LC40</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">    int sum=0;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        boolean[] flag = new boolean[candidates.length];</span><br><span class="line">        dfs(candidates, target, 0, flag);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] arr, int target, int index, boolean[] flag) &#123;</span><br><span class="line">        if(sum==target)&#123;</span><br><span class="line">            res.add(new ArrayList(deque));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = index; i &lt; arr.length &amp;&amp; arr[i] + sum &lt;= target; i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; arr[i] == arr[i-1] &amp;&amp; !flag[i-1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[i] = true;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            deque.push(arr[i]);</span><br><span class="line">            dfs(arr,target, i + 1, flag);</span><br><span class="line">            int temp = deque.pop();</span><br><span class="line">            flag[i] = false;</span><br><span class="line">            sum -= temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分割回文字符串"><a href="#分割回文字符串" class="headerlink" title="分割回文字符串"></a>分割回文字符串</h2><p>这道题的难点是，如何分割字符串，之后在判断是否是回文字符串。判断回文字符串一个函数即可完成，如何全面的分割字符串才是难题。<br>看到题目的第一个思路可能就是用for循环再用双指针去切割，双指针的确是解决本问题的关键。<br>在前面的回溯算法中其实可以发现，回溯算法本质上还是简化循环的算法。那么本题也可以用回溯算法去实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//LC131</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        dfs(s, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //index是分割线</span><br><span class="line">    public void dfs(String s, int index) &#123;</span><br><span class="line">        //终止条件为分割线越过最后一个字符</span><br><span class="line">        if(index &gt;= s.length()) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=index; i&lt;s.length(); i++) &#123;</span><br><span class="line">            if(isbool(s, index, i))&#123;</span><br><span class="line">                path.add(s.substring(index,i+1));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dfs(s, i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isbool(String s, int left, int right) &#123;</span><br><span class="line">        for(int i=left, j=right; i&lt;=j; i++,j--) &#123;</span><br><span class="line">            if(s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line"></span><br><span class="line">        if(s.length()&gt;12)&#123;return res;&#125;//剪枝</span><br><span class="line">        dfs(s,0,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    //start: 搜索的起始位置， pointNum:添加逗点的数量</span><br><span class="line">    public void dfs(String s, int start, int pointNum)&#123;</span><br><span class="line">        //终止条件 逗号数为3。要验证一下最后一组数是否符合条件</span><br><span class="line">        if(pointNum==3)&#123;</span><br><span class="line">            if(isValid(s, start, s.length()-1))&#123;</span><br><span class="line">                res.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            return;  </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=start; i&lt;s.length(); i++)&#123;</span><br><span class="line">            if(isValid(s, start, i))&#123;</span><br><span class="line">                s=s.substring(0, i+1)+&quot;.&quot;+s.substring(i+1);</span><br><span class="line">                pointNum++;</span><br><span class="line">                dfs(s, i+2,pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2</span><br><span class="line">                pointNum--; </span><br><span class="line">                s= s.substring(0,i+1)+s.substring(i+2);// 回溯删掉逗点</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean isValid(String s, int l, int r)&#123;</span><br><span class="line">        if(l&gt;r)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //0开头返回false</span><br><span class="line">        if(s.charAt(l)==&#x27;0&#x27; &amp;&amp; l!=r)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int num=0;</span><br><span class="line">        //左闭右闭</span><br><span class="line">        for(int i=l; i&lt;=r; i++)&#123;</span><br><span class="line">            if(s.charAt(i)&gt;&#x27;9&#x27; || s.charAt(i)&lt;&#x27;0&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            num=num*10+(s.charAt(i)-&#x27;0&#x27;);</span><br><span class="line">            if(num&gt;255)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>把回溯算法模拟成树模型的话，组合问题就是收集树的所有叶子节点，而子集问题，就是收集树的所有节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//LC78</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; one=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;());</span><br><span class="line">        dfs(nums,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] nums,int start)&#123;</span><br><span class="line">        if(start&gt;=nums.length)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=start; i&lt;nums.length; i++)&#123;</span><br><span class="line">            one.add(nums[i]);</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(one));</span><br><span class="line">            dfs(nums,i+1);</span><br><span class="line">            one.remove(one.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><p>难点还是去重问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//LC90</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    boolean[] used;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;());</span><br><span class="line">        </span><br><span class="line">        used = new boolean[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] nums, int start)&#123;</span><br><span class="line">        //终止条件</span><br><span class="line">        if(start&gt;=nums.length)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=start; i&lt;nums.length; i++)&#123;</span><br><span class="line">            //如果是同一树层的则continue</span><br><span class="line">            if(i&gt;0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !used[i-1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            used[i]=true;</span><br><span class="line">            dfs(nums, i+1);</span><br><span class="line">            used[i]=false;</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>可以看成是子集问题的变类，也同样需要去重,而本题求自增子序列，是不能对原数组经行排序的，排完序的数组都是自增子序列了。所以不能使用之前的去重逻辑！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//LC491</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        dfs(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] nums,int strat)&#123;</span><br><span class="line">        //这个终止条件不加也可以，不会无限递归</span><br><span class="line">        if(strat&gt;=nums.length)&#123;return;&#125;</span><br><span class="line">        int[] used=new int[201];</span><br><span class="line">        for(int i=strat; i&lt;nums.length; i++)&#123;</span><br><span class="line">            //若下一个数比path中的最后一个数小，或者同层相同（同层去重），结束本次循环</span><br><span class="line">            //used记录本层元素是否重复使用，新的一层used都会重新定义（清空），所以要知道uset只负责本层！</span><br><span class="line">            if(!path.isEmpty() &amp;&amp; nums[i]&lt;path.get(path.size()-1) || used[nums[i]+100]==1)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            if(path.size()&gt;=2)&#123;</span><br><span class="line">                res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            used[nums[i]+100] = 1;</span><br><span class="line">            dfs(nums, i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><em>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//LC46</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res= new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    boolean[] used;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        boolean[] used=new boolean[nums.length];</span><br><span class="line">        dfs(nums, used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int[] nums, boolean[] used)&#123;</span><br><span class="line">        //终止条件,此题不加也可以</span><br><span class="line">        if(path.size()==nums.length)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(used[i]==true)&#123;continue;&#125;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            // if(path.size()==nums.length)&#123;</span><br><span class="line">            //     res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            // &#125;</span><br><span class="line">            </span><br><span class="line">            used[i]=true;</span><br><span class="line">            dfs(nums, used);</span><br><span class="line">            used[i]=false;</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全排列-1"><a href="#全排列-1" class="headerlink" title="全排列"></a>全排列</h2><p><em>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//同树层去重记得要排序</span><br><span class="line">//LC47</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        boolean[] used=new boolean[nums.length];</span><br><span class="line">        dfs(nums,used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int[] nums, boolean[] used)&#123;</span><br><span class="line">        if(path.size()==nums.length)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            //同树层去重</span><br><span class="line">            if(i&gt;0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; used[i-1]==false)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(used[i]==false)&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i]=true;</span><br><span class="line">                dfs(nums,used);</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">                used[i]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">332.重新安排行程</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//LC332</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private Deque&lt;String&gt; res;</span><br><span class="line">    private Map&lt;String, Map&lt;String, Integer&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    private boolean backTracking(int ticketNum)&#123;</span><br><span class="line">        if(res.size() == ticketNum + 1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        String last = res.getLast();</span><br><span class="line">        if(map.containsKey(last))&#123;//防止出现null</span><br><span class="line">            for(Map.Entry&lt;String, Integer&gt; target : map.get(last).entrySet())&#123;</span><br><span class="line">                int count = target.getValue();</span><br><span class="line">                if(count &gt; 0)&#123;</span><br><span class="line">                    res.add(target.getKey());</span><br><span class="line">                    target.setValue(count - 1);</span><br><span class="line">                    if(backTracking(ticketNum)) return true;</span><br><span class="line">                    res.removeLast();</span><br><span class="line">                    target.setValue(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;</span><br><span class="line">        map = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">        res = new LinkedList&lt;&gt;();</span><br><span class="line">        for(List&lt;String&gt; t : tickets)&#123;</span><br><span class="line">            Map&lt;String, Integer&gt; temp;</span><br><span class="line">            if(map.containsKey(t.get(0)))&#123;</span><br><span class="line">                temp = map.get(t.get(0));</span><br><span class="line">                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp = new TreeMap&lt;&gt;();//升序Map</span><br><span class="line">                temp.put(t.get(1), 1);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(t.get(0), temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        res.add(&quot;JFK&quot;);</span><br><span class="line">        backTracking(tickets.size());</span><br><span class="line">        return new ArrayList&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p><a href="https://leetcode-cn.com/problems/n-queens/">51.N皇后</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">//LC51</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        char[][] arr=new char[n][n];</span><br><span class="line">        for(char[] item : arr)&#123;</span><br><span class="line">            Arrays.fill(item,&#x27;.&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(n,0,arr);</span><br><span class="line">        return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void dfs(int n, int row, char[][] arr)&#123;</span><br><span class="line">        if(n==row)&#123;</span><br><span class="line">            res.add(Array2List(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int col = 0;col &lt; n; ++col) &#123;</span><br><span class="line">            if (isVaild (row, col, n, arr)) &#123;</span><br><span class="line">                arr[row][col] = &#x27;Q&#x27;;</span><br><span class="line">                dfs(n, row+1, arr);</span><br><span class="line">                arr[row][col] = &#x27;.&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List Array2List(char[][] chessboard) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (char[] c : chessboard) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isVaild(int row, int col, int n, char[][] arr)&#123;</span><br><span class="line">        //同列</span><br><span class="line">        for(int i=0; i&lt;row; i++)&#123;</span><br><span class="line">            if(arr[i][col]==&#x27;Q&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //45度</span><br><span class="line">        for(int i=row-1, j=col-1; i&gt;=0&amp;&amp;j&gt;=0; i--,j--)&#123;</span><br><span class="line">            if(arr[i][j]==&#x27;Q&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //135度,右上角</span><br><span class="line">        for(int i=row-1, j=col+1; i&gt;=0 &amp;&amp; j&lt;=n-1; i--,j++)&#123;</span><br><span class="line">            if(arr[i][j]==&#x27;Q&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">37.解数独</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void solveSudoku(char[][] board) &#123;</span><br><span class="line">        solveSudokuHelper(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean solveSudokuHelper(char[][] board)&#123;</span><br><span class="line">        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，</span><br><span class="line">        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」</span><br><span class="line">        for (int i = 0; i &lt; 9; i++)&#123; // 遍历行</span><br><span class="line">            for (int j = 0; j &lt; 9; j++)&#123; // 遍历列</span><br><span class="line">                if (board[i][j] != &#x27;.&#x27;)&#123; // 跳过原始数字</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for (char k = &#x27;1&#x27;; k &lt;= &#x27;9&#x27;; k++)&#123; // (i, j) 这个位置放k是否合适</span><br><span class="line">                    if (isValidSudoku(i, j, k, board))&#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        if (solveSudokuHelper(board))&#123; // 如果找到合适一组立刻返回</span><br><span class="line">                            return true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        board[i][j] = &#x27;.&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 9个数都试完了，都不行，那么就返回false</span><br><span class="line">                return false;</span><br><span class="line">                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！</span><br><span class="line">                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历完没有返回false，说明找到了合适棋盘位置了</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断棋盘是否合法有如下三个维度:</span><br><span class="line">     *     同行是否重复</span><br><span class="line">     *     同列是否重复</span><br><span class="line">     *     9宫格里是否重复</span><br><span class="line">     */</span><br><span class="line">    private boolean isValidSudoku(int row, int col, char val, char[][] board)&#123;</span><br><span class="line">        // 同行是否重复</span><br><span class="line">        for (int i = 0; i &lt; 9; i++)&#123;</span><br><span class="line">            if (board[row][i] == val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 同列是否重复</span><br><span class="line">        for (int j = 0; j &lt; 9; j++)&#123;</span><br><span class="line">            if (board[j][col] == val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 9宫格里是否重复</span><br><span class="line">        int startRow = (row / 3) * 3;</span><br><span class="line">        int startCol = (col / 3) * 3;</span><br><span class="line">        for (int i = startRow; i &lt; startRow + 3; i++)&#123;</span><br><span class="line">            for (int j = startCol; j &lt; startCol + 3; j++)&#123;</span><br><span class="line">                if (board[i][j] == val)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;回溯算法模板&quot;&gt;&lt;a href=&quot;#回溯算法模板&quot; class=&quot;headerlink&quot; title=&quot;回溯算法模板&quot;&gt;&lt;/a&gt;回溯算法模板&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void backtracking(参数) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (终止条件) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        存放结果;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        处理节点;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        backtracking(路径，选择列表); // 递归&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        回溯，撤销处理结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="代码" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
    <category term="回溯算法" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP&amp;request&amp;response</title>
    <link href="http://example.com/2021/08/29/HTTP-request-response/"/>
    <id>http://example.com/2021/08/29/HTTP-request-response/</id>
    <published>2021-08-29T01:55:12.000Z</published>
    <updated>2021-08-29T02:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h1><h2 id="概念：Hyper-Text-Transfer-Protocol-超文本传输协议"><a href="#概念：Hyper-Text-Transfer-Protocol-超文本传输协议" class="headerlink" title="概念：Hyper Text Transfer Protocol 超文本传输协议"></a>概念：Hyper Text Transfer Protocol 超文本传输协议</h2><span id="more"></span><pre><code>    * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式    * 特点：        1. 基于TCP/IP的高级协议        2. 默认端口号:80        3. 基于请求/响应模型的:一次请求对应一次响应        4. 无状态的：每次请求之间相互独立，不能交互数据    * 历史版本：        * 1.0：每一次请求响应都会建立新的连接        * 1.1：复用连接</code></pre><h2 id="请求消息：客户端发送给服务器端的数据"><a href="#请求消息：客户端发送给服务器端的数据" class="headerlink" title="请求消息：客户端发送给服务器端的数据"></a>请求消息：客户端发送给服务器端的数据</h2><pre><code>* 数据格式：    1. 请求行        请求方式 请求url 请求协议/版本        GET /login.html    HTTP/1.1        * 请求方式：            * HTTP协议有7中请求方式，常用的有2种                * GET：                    1. 请求参数在请求行中，在url后。                    2. 请求的url长度有限制的                    3. 不太安全                * POST：                    1. 请求参数在请求体中                    2. 请求的url长度没有限制的                    3. 相对安全    2. 请求头：客户端浏览器告诉服务器一些信息        请求头名称: 请求头值        * 常见的请求头：            1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息                * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题            2. Referer：http://localhost/login.html                * 告诉服务器，我(当前请求)从哪里来？                    * 作用：                        1. 防盗链：                        2. 统计工作：    3. 请求空行        空行，就是用于分割POST请求的请求头，和请求体的。    4. 请求体(正文)：        * 封装POST请求消息的请求参数的    * 字符串格式：        POST /login.html    HTTP/1.1        Host: localhost        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8        Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2        Accept-Encoding: gzip, deflate        Referer: http://localhost/login.html        Connection: keep-alive        Upgrade-Insecure-Requests: 1                username=zhangsan    </code></pre><h2 id="响应消息：服务器端发送给客户端的数据"><a href="#响应消息：服务器端发送给客户端的数据" class="headerlink" title="响应消息：服务器端发送给客户端的数据"></a>响应消息：服务器端发送给客户端的数据</h2><pre><code>    * 数据格式：        1. 响应行            1. 组成：协议/版本 响应状态码 状态码描述            2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。                1. 状态码都是3位数字                 2. 分类：                    1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码                    2. 2xx：成功。代表：200                    3. 3xx：重定向。代表：302(重定向)，304(访问缓存)                    4. 4xx：客户端错误。                        * 代表：                            * 404（请求路径没有对应的资源）                             * 405：请求方式没有对应的doXxx方法                    5. 5xx：服务器端错误。代表：500(服务器内部出现异常)                                                2. 响应头：            1. 格式：头名称： 值            2. 常见的响应头：                1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式                2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据                    * 值：                        * in-line:默认值,在当前页面内打开                        * attachment;filename=xxx：以附件形式打开响应体。文件下载        3. 响应空行        4. 响应体:传输的数据    * 响应字符串格式        HTTP/1.1 200 OK        Content-Type: text/html;charset=UTF-8        Content-Length: 101        Date: Wed, 06 Jun 2018 07:08:42 GMT        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;$Title$&lt;/title&gt;          &lt;/head&gt;          &lt;body&gt;          hello , response          &lt;/body&gt;        &lt;/html&gt;</code></pre><h1 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h1><h2 id="request对象和response对象的原理"><a href="#request对象和response对象的原理" class="headerlink" title="request对象和response对象的原理"></a>request对象和response对象的原理</h2><pre><code>    1. request和response对象是由服务器创建的。我们来使用它们    2. request对象是来获取请求消息，response对象是来设置响应消息</code></pre><h2 id="request对象继承体系结构："><a href="#request对象继承体系结构：" class="headerlink" title="request对象继承体系结构："></a>request对象继承体系结构：</h2><pre><code>    ServletRequest        --    接口        |    继承    HttpServletRequest    -- 接口        |    实现    org.apache.catalina.connector.RequestFacade 类(tomcat)</code></pre><h2 id="request功能："><a href="#request功能：" class="headerlink" title="request功能："></a>request功能：</h2><pre><code>    1. 获取请求消息数据        1. 获取请求行数据            * GET /day14/demo1?name=zhangsan HTTP/1.1            * 方法：                1. 获取请求方式 ：GET                    * String getMethod()                  2. (*)获取虚拟目录：/day14                    * String getContextPath()                3. 获取Servlet路径: /demo1                    * String getServletPath()                4. 获取get方式请求参数：name=zhangsan                    * String getQueryString()                5. (*)获取请求URI：/day14/demo1                    * String getRequestURI():        /day14/demo1                    * StringBuffer getRequestURL()  :http://localhost/day14/demo1                    * URL:统一资源定位符 ： http://localhost/day14/demo1    中华人民共和国                    * URI：统一资源标识符 : /day14/demo1                    共和国                                6. 获取协议及版本：HTTP/1.1                    * String getProtocol()                7. 获取客户机的IP地址：                    * String getRemoteAddr()                        2. 获取请求头数据            * 方法：                * (*)String getHeader(String name):通过请求头的名称获取请求头的值                * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称                    3. 获取请求体数据:            * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数            * 步骤：                1. 获取流对象                    *  BufferedReader getReader()：获取字符输入流，只能操作字符数据                    *  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据                        * 在文件上传知识点后讲解                2. 再从流对象中拿数据                        </code></pre><h2 id="其他功能："><a href="#其他功能：" class="headerlink" title="其他功能："></a>其他功能：</h2><pre><code>        1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数            1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123            2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game            3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称            4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合            * 中文乱码问题：                * get方式：tomcat 8 已经将get方式乱码问题解决了                * post方式：会乱码                    * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);                                2. 请求转发：一种在服务器内部的资源跳转方式            1. 步骤：                1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)                2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)             2. 特点：                1. 浏览器地址栏路径不发生变化                2. 只能转发到当前服务器内部资源中。                3. 转发是一次请求        3. 共享数据：            * 域对象：一个有作用范围的对象，可以在范围内共享数据            * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据            * 方法：                1. void setAttribute(String name,Object obj):存储数据                2. Object getAttitude(String name):通过键获取值                3. void removeAttribute(String name):通过键移除键值对        4. 获取ServletContext：            * ServletContext getServletContext()        </code></pre><h1 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h1><h2 id="功能：设置响应消息"><a href="#功能：设置响应消息" class="headerlink" title="功能：设置响应消息"></a>功能：设置响应消息</h2><pre><code>    1. 设置响应行        1. 格式：HTTP/1.1 200 ok        2. 设置状态码：setStatus(int sc)     2. 设置响应头：setHeader(String name, String value)             3. 设置响应体：        * 使用步骤：            1. 获取输出流                * 字符输出流：PrintWriter getWriter()                * 字节输出流：ServletOutputStream getOutputStream()            2. 使用输出流，将数据输出到客户端浏览器</code></pre><h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><h3 id="完成重定向"><a href="#完成重定向" class="headerlink" title="完成重定向"></a>完成重定向</h3><pre><code>        * 重定向：资源跳转的方式        * 代码实现：            //1. 设置状态码为302            response.setStatus(302);            //2.设置响应头location            response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);            //简单的重定向方法            response.sendRedirect(&quot;/day15/responseDemo2&quot;);        * 重定向的特点:redirect            1. 地址栏发生变化            2. 重定向可以访问其他站点(服务器)的资源            3. 重定向是两次请求。不能使用request对象来共享数据        * 转发的特点：forward            1. 转发地址栏路径不变            2. 转发只能访问当前服务器下的资源            3. 转发是一次请求，可以使用request对象来共享数据                * forward 和  redirect 区别                    * 路径写法：            1. 路径分类                1. 相对路径：通过相对路径不可以确定唯一资源                    * 如：./index.html                    * 不以/开头，以.开头路径                    * 规则：找到当前资源和目标资源之间的相对位置关系                        * ./：当前目录                        * ../:后退一级目录                2. 绝对路径：通过绝对路径可以确定唯一资源                    * 如：http://localhost/day15/responseDemo2        /day15/responseDemo2                    * 以/开头的路径                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出                        * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)                            * 建议虚拟目录动态获取：request.getContextPath()                            * &lt;a&gt; , &lt;form&gt; 重定向...                        * 给服务器使用：不需要加虚拟目录                            * 转发路径                                                                    </code></pre><h3 id="服务器输出字符数据到浏览器"><a href="#服务器输出字符数据到浏览器" class="headerlink" title="服务器输出字符数据到浏览器"></a>服务器输出字符数据到浏览器</h3><pre><code>        * 步骤：            1. 获取字符输出流            2. 输出数据        * 注意：            * 乱码问题：                1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1                2. 设置该流的默认编码                3. 告诉浏览器响应体使用的编码                //简单的形式，设置编码，是在获取流之前设置                response.setContentType(&quot;text/html;charset=utf-8&quot;);    3. 服务器输出字节数据到浏览器        * 步骤：            1. 获取字节输出流            2. 输出数据    4. 验证码        1. 本质：图片        2. 目的：防止恶意表单注册</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HTTP：&quot;&gt;&lt;a href=&quot;#HTTP：&quot; class=&quot;headerlink&quot; title=&quot;HTTP：&quot;&gt;&lt;/a&gt;HTTP：&lt;/h1&gt;&lt;h2 id=&quot;概念：Hyper-Text-Transfer-Protocol-超文本传输协议&quot;&gt;&lt;a href=&quot;#概念：Hyper-Text-Transfer-Protocol-超文本传输协议&quot; class=&quot;headerlink&quot; title=&quot;概念：Hyper Text Transfer Protocol 超文本传输协议&quot;&gt;&lt;/a&gt;概念：Hyper Text Transfer Protocol 超文本传输协议&lt;/h2&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://example.com/2021/08/16/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/08/16/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-08-16T14:13:46.000Z</published>
    <updated>2021-09-15T01:28:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归算法模板"><a href="#递归算法模板" class="headerlink" title="递归算法模板"></a>递归算法模板</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 dfs(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return 返回值类型;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    每层递归的逻辑</span><br><span class="line">    dfs(下层递归的参数);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>以下代码绝大多数来自于 <em>代码随想录</em>，代码只为个人学习与总结</p><h1 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h1> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line">  TreeNode() &#123;&#125;</span><br><span class="line">  TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line">  TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">    this.left = left;</span><br><span class="line">    this.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC144</span><br><span class="line">class Solution &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; preOrderReverse(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void preOrder(TreeNode root, ArrayList&lt;Integer&gt; result) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val); </span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC94</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val); </span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC145</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h2><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC144</span><br><span class="line">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.right != null)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left != null)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC94</span><br><span class="line">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        while (cur != null || !stack.isEmpty())&#123;</span><br><span class="line">           if (cur != null)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC145</span><br><span class="line">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.left != null)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一遍历"><a href="#统一遍历" class="headerlink" title="统一遍历"></a>统一遍历</h2><p>迭代法前中后序遍历的统一模板，逻辑相似，只需要修改代码的顺序。</p><h3 id="前序遍历-2"><a href="#前序遍历-2" class="headerlink" title="前序遍历"></a>前序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC144</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode node = st.peek();</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br><span class="line">                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）</span><br><span class="line">                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）</span><br><span class="line">                st.push(node);                          // 添加中节点</span><br><span class="line">                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集</span><br><span class="line">                st.pop();           // 将空节点弹出</span><br><span class="line">                node = st.peek();    // 重新取出栈中元素</span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); // 加入到结果集</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC94</span><br><span class="line">class Solution &#123;</span><br><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();</span><br><span class="line">    if (root != null) st.push(root);</span><br><span class="line">    while (!st.empty()) &#123;</span><br><span class="line">        TreeNode node = st.peek();</span><br><span class="line">        if (node != null) &#123;</span><br><span class="line">            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br><span class="line">            if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）</span><br><span class="line">            st.push(node);                          // 添加中节点</span><br><span class="line">            st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><span class="line"></span><br><span class="line">            if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）</span><br><span class="line">        &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集</span><br><span class="line">            st.pop();           // 将空节点弹出</span><br><span class="line">            node = st.peek();    // 重新取出栈中元素</span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); // 加入到结果集</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历-2"><a href="#后序遍历-2" class="headerlink" title="后序遍历"></a>后序遍历</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 递归·LC145</span><br><span class="line">class Solution &#123;</span><br><span class="line">   public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null) st.push(root);</span><br><span class="line">        while (!st.empty()) &#123;</span><br><span class="line">            TreeNode node = st.peek();</span><br><span class="line">            if (node != null) &#123;</span><br><span class="line">                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br><span class="line">                st.push(node);                          // 添加中节点</span><br><span class="line">                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><span class="line">                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）</span><br><span class="line">                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）         </span><br><span class="line">                               </span><br><span class="line">            &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集</span><br><span class="line">                st.pop();           // 将空节点弹出</span><br><span class="line">                node = st.peek();    // 重新取出栈中元素</span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); // 加入到结果集</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>层序遍历模板<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 102.二叉树的层序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        //checkFun01(root,0);</span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        return resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //DFS--递归方式</span><br><span class="line">    public void checkFun01(TreeNode node, Integer deep) &#123;</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        if (resList.size() &lt; deep) &#123;</span><br><span class="line">            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span><br><span class="line">            List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - 1).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //BFS--迭代方式--借助队列</span><br><span class="line">    public void checkFun02(TreeNode node) &#123;</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        while (!que.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            int len = que.size();</span><br><span class="line"></span><br><span class="line">            while (len &gt; 0) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                if (tmpNode.left != null) que.offer(tmpNode.left);</span><br><span class="line">                if (tmpNode.right != null) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//DFS递归</span><br><span class="line">class Solution &#123;</span><br><span class="line">   /**</span><br><span class="line">     * 前后序遍历都可以</span><br><span class="line">     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）</span><br><span class="line">     */</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        swapChildren(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void swapChildren(TreeNode root) &#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;return null;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        while (!deque.isEmpty()) &#123;</span><br><span class="line">            int size = deque.size();</span><br><span class="line">            while (size-- &gt; 0) &#123;</span><br><span class="line">                TreeNode node = deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                if (node.left != null) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                if (node.right != null) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swap(TreeNode root) &#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p>以二叉树的遍历为基础，只是处理节点的顺序从两侧外开始逐渐靠内。主要难点在于确定所有不对称的条件。</p><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        return compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean compare(TreeNode left,TreeNode right)&#123;</span><br><span class="line">        //循环终止条件为两节点不对称以及两节点为空</span><br><span class="line">        if(left==null&amp;&amp;right==null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left==null &amp;&amp; right!=null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left!=null &amp;&amp; right==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left.val!=right.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        boolean outside= compare(left.left,right.right);</span><br><span class="line">        boolean inside= compare(left.right,right.left);</span><br><span class="line">        //外侧内侧皆相同即true</span><br><span class="line">        return outside &amp;&amp; inside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>与层序遍历不同，判断对称并不需要确定节点属于哪一层，只要按一定顺序将它们输入队列即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; que=new LinkedList&lt;&gt;();</span><br><span class="line">        que.offer(root.left);</span><br><span class="line">        que.offer(root.right);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            TreeNode left=que.poll();</span><br><span class="line">            TreeNode right=que.poll();</span><br><span class="line">            if(left==null &amp;&amp; right==null)&#123;//左右节点为空时对称</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //左右节点只有一个为0，或者左右节点值不相同则不对称</span><br><span class="line">            if(left==null || right==null || left.val!=right.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            que.offer(left.left);</span><br><span class="line">            que.offer(right.right);</span><br><span class="line">            que.offer(left.right);</span><br><span class="line">            que.offer(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><h2 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//前序遍历 递归求深度</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;return 0;&#125;</span><br><span class="line">        int left=maxDepth(root.left);</span><br><span class="line">        int right=maxDepth(root.right);</span><br><span class="line">        return Math.max(left,right)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">       if(root==null)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; que=new LinkedList&lt;&gt;();</span><br><span class="line">       que.offer(root);</span><br><span class="line">       int depth=0;</span><br><span class="line">       while(!que.isEmpty())&#123;</span><br><span class="line">           int size=que.size();</span><br><span class="line">           depth++;</span><br><span class="line">           while(size&gt;0)&#123;</span><br><span class="line">               TreeNode poll=que.poll();</span><br><span class="line">               if(poll.left!=null)&#123;</span><br><span class="line">                   que.offer(poll.left);</span><br><span class="line">               &#125;</span><br><span class="line">               if(poll.right!=null)&#123;</span><br><span class="line">                   que.offer(poll.right);</span><br><span class="line">               &#125;</span><br><span class="line">               size--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><h2 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h2><p>与最大深度类似，但要注意最小深度是从根节点到最近叶子节点的最短路径上的节点数量。没有子节点才是叶子节点，遍历到某个只有一个子节点的节点可能会错误判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//为了找到没有子节点的节点，这里对只有一个子节点的节点进行判断</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=minDepth(root.left);</span><br><span class="line">        int right=minDepth(root.right);</span><br><span class="line">        if(root.left==null)&#123;return right+1;&#125;</span><br><span class="line">        if(root.right==null)&#123;return left+1;&#125;</span><br><span class="line">        return Math.min(left,right)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//深度理解为层序遍历的层数</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">       if(root==null)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       Queue&lt;TreeNode&gt; que=new LinkedList&lt;&gt;();</span><br><span class="line">       que.offer(root);</span><br><span class="line">       int depth=0;</span><br><span class="line">       while(!que.isEmpty())&#123;</span><br><span class="line">           int size=que.size();</span><br><span class="line">           depth++;</span><br><span class="line">           while(size&gt;0)&#123;</span><br><span class="line">               TreeNode poll=que.poll();</span><br><span class="line">//poll为叶子节点则返回深度</span><br><span class="line">               if(poll.left==null &amp;&amp; poll.right==null)&#123;</span><br><span class="line">                   return depth;</span><br><span class="line">               &#125;</span><br><span class="line">               if(poll.left!=null)&#123;</span><br><span class="line">                   que.offer(poll.left);</span><br><span class="line">               &#125;</span><br><span class="line">               if(poll.right!=null)&#123;</span><br><span class="line">                   que.offer(poll.right);</span><br><span class="line">               &#125;</span><br><span class="line">               size--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完全二叉树的最小个数"><a href="#完全二叉树的最小个数" class="headerlink" title="完全二叉树的最小个数"></a>完全二叉树的最小个数</h1><h2 id="递归法-3"><a href="#递归法-3" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=countNodes(root.left);</span><br><span class="line">        int right=countNodes(root.right);</span><br><span class="line">        return left+right+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全二叉树的做法"><a href="#完全二叉树的做法" class="headerlink" title="完全二叉树的做法"></a>完全二叉树的做法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 满二叉树的结点数为：2^depth - 1</span><br><span class="line">     */</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftDepth = getDepth(root.left);</span><br><span class="line">        int rightDepth = getDepth(root.right);</span><br><span class="line">        if (leftDepth == rightDepth) &#123;// 左子树是满二叉树</span><br><span class="line">            // 2^leftDepth其实是 （2^leftDepth - 1） + 1 ，左子树 + 根结点</span><br><span class="line">            return (1 &lt;&lt; leftDepth) + countNodes(root.right);</span><br><span class="line">        &#125; else &#123;// 右子树是满二叉树</span><br><span class="line">            return (1 &lt;&lt; rightDepth) + countNodes(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getDepth(TreeNode root) &#123;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        while (root != null) &#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="判断是否为平衡二叉树"><a href="#判断是否为平衡二叉树" class="headerlink" title="判断是否为平衡二叉树"></a>判断是否为平衡二叉树</h1><h2 id="递归法-4"><a href="#递归法-4" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        return getDepth(root)!=-1;</span><br><span class="line">    &#125;</span><br><span class="line">//不为平衡二叉树返回-1</span><br><span class="line">    public int getDepth(TreeNode node)&#123;</span><br><span class="line">        if(node==null)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=getDepth(node.left);</span><br><span class="line">        if(left==-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int right=getDepth(node.right);</span><br><span class="line">        if(right==-1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(Math.abs(left-right)&gt;1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return Math.max(left,right)+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找二叉树的所有路径"><a href="#查找二叉树的所有路径" class="headerlink" title="查找二叉树的所有路径"></a>查找二叉树的所有路径</h1><h2 id="递归法-5"><a href="#递归法-5" class="headerlink" title="递归法"></a>递归法</h2><p>思路是递归回溯，每一次回溯之后删除末尾节点有些像全排列的感觉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        List&lt;String&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">        if(res==null)&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path =new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,path,res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode node,List&lt;Integer&gt; path ,List&lt;String&gt; res)&#123;</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        StringBuilder sb=new StringBuilder();</span><br><span class="line">        if(node.left==null &amp;&amp; node.right==null)&#123;</span><br><span class="line">            for(int i=0;i&lt;path.size()-1;i++)&#123;</span><br><span class="line">                sb.append(path.get(i)).append(&quot;-&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(path.get(path.size()-1));</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.left!=null)&#123;</span><br><span class="line">            dfs(node.left,path,res);</span><br><span class="line">            path.remove(path.size()-1);//删除末位节点</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right!=null)&#123;</span><br><span class="line">            dfs(node.right,path,res);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的左叶子节点之和"><a href="#二叉树的左叶子节点之和" class="headerlink" title="二叉树的左叶子节点之和"></a>二叉树的左叶子节点之和</h1><h2 id="递归法-6"><a href="#递归法-6" class="headerlink" title="递归法"></a>递归法</h2><p>左叶子节点的判断方法是，该节点是父节点的左节点，且该节点没有子节点。<br>根据二叉树的特点，指针指在子节点时是无法回到父节点判断自己是否为左子节点，所以要从父节点就开始判断它的左子节点是否为叶子节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=sumOfLeftLeaves(root.left);</span><br><span class="line">        int right=sumOfLeftLeaves(root.right);</span><br><span class="line"></span><br><span class="line">        int count=0;</span><br><span class="line">        if(root.left!=null &amp;&amp; root.left.left==null &amp;&amp; root.left.right==null)&#123;</span><br><span class="line">            count=root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        return left+right+count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; st=new Stack&lt;&gt;();</span><br><span class="line">        st.add(root);</span><br><span class="line">        int sum=0;</span><br><span class="line">        while(!st.isEmpty())&#123;</span><br><span class="line">            TreeNode node=st.pop();</span><br><span class="line">            if(node.left!=null &amp;&amp; node.left.left==null &amp;&amp; node.left.right==null)&#123;</span><br><span class="line">                sum+=node.left.val;   </span><br><span class="line">            &#125;</span><br><span class="line">            if(node.left!=null)&#123;st.add(node.left);&#125;</span><br><span class="line">            if(node.right!=null)&#123;st.add(node.right);&#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h1><h2 id="迭代法-4"><a href="#迭代法-4" class="headerlink" title="迭代法"></a>迭代法</h2><p>设法找到最后一层的第一个节点，修改一下层序遍历即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; que=new LinkedList&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        int first=0;</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int size=que.size();</span><br><span class="line">            for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode node=que.poll();</span><br><span class="line">                if(i==0)&#123;first=node.val;&#125;</span><br><span class="line">                if(node.left!=null)&#123;que.offer(node.left);&#125;</span><br><span class="line">                if(node.right!=null)&#123;que.offer(node.right);&#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的路径总和"><a href="#二叉树的路径总和" class="headerlink" title="二叉树的路径总和"></a>二叉树的路径总和</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        targetSum-=root.val;</span><br><span class="line">        if(root.left==null &amp;&amp; root.right==null)&#123;</span><br><span class="line">            if(targetSum==0)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.left!=null)&#123;</span><br><span class="line">            boolean left=hasPathSum(root.left,targetSum);</span><br><span class="line">            if(left)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(root.right!=null)&#123;</span><br><span class="line">            boolean right=hasPathSum(root.right,targetSum);</span><br><span class="line">            if(right)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="路径总和II"><a href="#路径总和II" class="headerlink" title="路径总和II"></a>路径总和II</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;return res;&#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; path=new LinkedList&lt;&gt;();</span><br><span class="line">        dfs(root,targetSum,res,path);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root,int targetSum,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path)&#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        if(root.left==null &amp;&amp; root.right==null &amp;&amp; targetSum==root.val)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        </span><br><span class="line">        return ;//和不为targetSum,返回</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.left!=null)&#123;</span><br><span class="line">        dfs(root.left,targetSum-root.val,res,path);</span><br><span class="line">        path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.right!=null)&#123;</span><br><span class="line">            dfs(root.right,targetSum-root.val,res,path);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h1><p>通过后序序列的最后一个节点值得到根节点，之后通过它在中序遍历中切割左右子树的中序与后序遍历，在通过递归再次找子树的结构。<br>易错点是，左右子树的区间的端点控制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        return buildTree1(inorder,0,inorder.length,postorder,0,postorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode buildTree1(int[] inorder,int inLeft,int inRight,int[] postorder, int postLeft,int postRight)&#123;</span><br><span class="line">                                    if(inRight-inLeft&lt;1)&#123;</span><br><span class="line">                                        return null;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    if(inRight-inLeft==1)&#123;</span><br><span class="line">                                        return new TreeNode(inorder[inLeft]);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    int rootVal=postorder[postRight-1];</span><br><span class="line">                                    TreeNode root=new TreeNode(rootVal);</span><br><span class="line"></span><br><span class="line">                                    int rootIndex=0;</span><br><span class="line">                                    for(rootIndex=inLeft;rootIndex&lt;inRight;rootIndex++)&#123;</span><br><span class="line">                                        if(inorder[rootIndex]==rootVal)&#123;</span><br><span class="line">                                            break;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    root.left=buildTree1(inorder,inLeft,rootIndex,postorder,postLeft,postLeft+(rootIndex-inLeft));</span><br><span class="line"></span><br><span class="line">                                    root.right=buildTree1(inorder,rootIndex+1,inRight,postorder,postLeft+(rootIndex-inLeft),postRight-1);</span><br><span class="line">                                    return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h1><p>留意区间边界</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//LC654</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;</span><br><span class="line">        return dfs(nums,0,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public TreeNode dfs(int[] nums,int l,int r)&#123;</span><br><span class="line">        if(r-l&lt;1)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(r-l==1)&#123;</span><br><span class="line">            TreeNode node=new TreeNode(nums[l]);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxIndex=l;</span><br><span class="line">        int maxVal=nums[l];</span><br><span class="line">        for(int i=l+1;i&lt;r;i++)&#123;</span><br><span class="line">            if(nums[i]&gt;maxVal)&#123;</span><br><span class="line">                maxVal=nums[i];</span><br><span class="line">                maxIndex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=new TreeNode(maxVal);</span><br><span class="line"></span><br><span class="line">        root.left=dfs(nums,l,maxIndex);</span><br><span class="line">        root.right=dfs(nums,maxIndex+1,r);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1><h2 id="迭代法-5"><a href="#迭代法-5" class="headerlink" title="迭代法"></a>迭代法</h2><p>就像迭代法遍历树，这次同时遍历两个树，注意这次的递归终止条件，因为要合并树，那么就有两个树遍历的节点t1 和 t2，如果t1 == NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。反过来如果t2 == NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if(root1==null)&#123;return root2;&#125;</span><br><span class="line">        if(root2==null)&#123;return root1;&#125;</span><br><span class="line"></span><br><span class="line">        root1.val+=root2.val;</span><br><span class="line">        root1.left=mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right=mergeTrees(root1.right,root2.right);</span><br><span class="line">        return root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="搜索二叉搜索树"><a href="#搜索二叉搜索树" class="headerlink" title="搜索二叉搜索树"></a>搜索二叉搜索树</h1><h2 id="递归法-7"><a href="#递归法-7" class="headerlink" title="递归法"></a>递归法</h2><p>二叉搜索树是一个有序树：</p><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>它的左、右子树也分别为二叉搜索树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//CL700</span><br><span class="line">class Solution &#123;</span><br><span class="line">public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        if(root==null || root.val==val)&#123;return root;&#125;</span><br><span class="line"></span><br><span class="line">        if(val &lt; root.val)&#123;</span><br><span class="line">            return searchBST(root.left,val);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return searchBST(root.right,val);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-6"><a href="#迭代法-6" class="headerlink" title="迭代法"></a>迭代法</h2><p>由于搜索树的特点，搜索时有了方向，不要用栈把所有节点遍历。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        while(root!=null)&#123;</span><br><span class="line">            if(val&lt;root.val)&#123;</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;else if(val&gt;root.val)&#123;</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p>这里注意不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。<br><strong>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。</strong></p><h2 id="递归法-8"><a href="#递归法-8" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode max;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        if(root==null)return true;</span><br><span class="line"></span><br><span class="line">        boolean left=isValidBST(root.left);</span><br><span class="line">        if(!left)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //max不为空时，它的值是此次递归的根节点的左子节点，也是上次递归的根节点</span><br><span class="line">        if(max!=null &amp;&amp; root.val&lt;=max.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max=root;</span><br><span class="line"></span><br><span class="line">        boolean right=isValidBST(root.right);</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h1><h2 id="递归法-9"><a href="#递归法-9" class="headerlink" title="递归法"></a>递归法</h2><p>由于二叉搜索树的性质，本质上还是中序遍历，同样迭代法也是在中序遍历的迭代版本，这里就不写了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> //LC530</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int res=Integer.MAX_VALUE;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;return 0;&#125;</span><br><span class="line"></span><br><span class="line">        if(root.left!=null)&#123;</span><br><span class="line">            getMinimumDifference(root.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(pre!=null)&#123;</span><br><span class="line">            res=Math.min(res,root.val-pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line"></span><br><span class="line">        if(root.right!=null)&#123;</span><br><span class="line">            getMinimumDifference(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的众数"><a href="#二叉搜索树的众数" class="headerlink" title="二叉搜索树的众数"></a>二叉搜索树的众数</h1><h2 id="递归法-10"><a href="#递归法-10" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> //LC501</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">    int maxcount=0;</span><br><span class="line">    int count=0;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    public int[] findMode(TreeNode root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        int[] res=new int[list.size()];</span><br><span class="line">        //注意i要在循环外声明</span><br><span class="line">        int i=0;</span><br><span class="line">        for(int item:list)&#123;</span><br><span class="line">            res[i++]=item;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        //中序遍历时，都要考虑pre节点是否为空。</span><br><span class="line">        if(pre==null || pre.val!=root.val)&#123;</span><br><span class="line">            count=1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        //更新maxcount，如果count较大说明之前录入的不为众数。之前的数据要清空</span><br><span class="line">        if(count&gt;maxcount)&#123;</span><br><span class="line">            maxcount=count;</span><br><span class="line">            list.clear();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;else if(count==maxcount)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="普通二叉树求众数"><a href="#普通二叉树求众数" class="headerlink" title="普通二叉树求众数"></a>普通二叉树求众数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public int[] findMode(FindModeInBinarySearchTree.TreeNode root) &#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">if (root == null) return list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">// 获得频率 Map</span><br><span class="line">searchBST(root, map);</span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()</span><br><span class="line">.sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line">list.add(mapList.get(0).getKey());</span><br><span class="line">// 把频率最高的加入 list</span><br><span class="line">for (int i = 1; i &lt; mapList.size(); i++) &#123;</span><br><span class="line">if (mapList.get(i).getValue() == mapList.get(i - 1).getValue()) &#123;</span><br><span class="line">list.add(mapList.get(i).getKey());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void searchBST(FindModeInBinarySearchTree.TreeNode curr, Map&lt;Integer, Integer&gt; map) &#123;</span><br><span class="line">if (curr == null) return;</span><br><span class="line">map.put(curr.val, map.getOrDefault(curr.val, 0) + 1);</span><br><span class="line">searchBST(curr.left, map);</span><br><span class="line">searchBST(curr.right, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求二叉树的最近公共祖先"><a href="#求二叉树的最近公共祖先" class="headerlink" title="求二叉树的最近公共祖先"></a>求二叉树的最近公共祖先</h1><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>需要注意的是：</p><ul><li><p>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。</p></li><li><p>在回溯的过程中，必然要遍历整颗二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</p></li><li><p>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//LC236</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        return dfs(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode dfs(TreeNode root,TreeNode p,TreeNode q)&#123;</span><br><span class="line">        //如果某条路线没有找到p或q，到叶子节点后就会向上返回null</span><br><span class="line">        if(root==null || root==p || root==q)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        //后序遍历</span><br><span class="line">        TreeNode left=dfs(root.left,p,q);</span><br><span class="line">        TreeNode right=dfs(root.right,p,q);</span><br><span class="line">        //不为null就为目标结点，此时的root就为公共祖先</span><br><span class="line">        if(left!=null &amp;&amp; right!=null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        //也有可能目标节点都在目前根节点的右子树，当然此次回溯的节点必不为所求得公共祖先了，反之亦然。</span><br><span class="line">        if(left==null)&#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉搜索树的公共祖先"><a href="#二叉搜索树的公共祖先" class="headerlink" title="二叉搜索树的公共祖先"></a>二叉搜索树的公共祖先</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//LC235</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(root.val&gt;p.val &amp;&amp; root.val&gt;q.val)&#123;</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;else if(root.val&lt;p.val &amp;&amp; root.val&lt;q.val)&#123;</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在二叉搜索树中插入节点"><a href="#在二叉搜索树中插入节点" class="headerlink" title="在二叉搜索树中插入节点"></a>在二叉搜索树中插入节点</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> //LC701</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode insertIntoBST(TreeNode root, int val) &#123;</span><br><span class="line">        //为空节点时插入</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            TreeNode node=new TreeNode(val);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //通过回溯阶段完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root.left或者root.right将其接住。</span><br><span class="line">        if(val&lt;root.val)&#123;root.left=insertIntoBST(root.left,val);&#125;</span><br><span class="line">        if(val&gt;root.val)&#123;root.right=insertIntoBST(root.right,val);&#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除二树的特定节点"><a href="#删除二树的特定节点" class="headerlink" title="删除二树的特定节点"></a>删除二树的特定节点</h1><h2 id="删除二叉搜索树的特定节点"><a href="#删除二叉搜索树的特定节点" class="headerlink" title="删除二叉搜索树的特定节点"></a>删除二叉搜索树的特定节点</h2><p>删除特定节点必须要改变二叉树结构，有以下五种情况：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<br>  ** 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点<br>  ** 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点<br>  ** 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点<br>  ** 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> //LC450</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">        //没有找到节点</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到了目标节点</span><br><span class="line">        if(root.val==key)&#123;</span><br><span class="line">            if(root.right==null)&#123;return root.left;&#125;</span><br><span class="line">            else if(root.left==null)&#123;return root.right;&#125;</span><br><span class="line">            //目标节点左右节点都不为空</span><br><span class="line">            else&#123;</span><br><span class="line">                //找到目标节点的右子树的最左侧叶子节点，其最小</span><br><span class="line">                TreeNode temp=root.right;</span><br><span class="line">                while(temp.left!=null)&#123;</span><br><span class="line">                    temp=temp.left;</span><br><span class="line">                &#125;</span><br><span class="line">                //最左侧叶子节点指向目标节点的左子树，则仍然为二叉搜索树</span><br><span class="line">                temp.left=root.left;</span><br><span class="line">                //删除目标节点</span><br><span class="line">                root=root.right;</span><br><span class="line">                return root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(root.left!=null)&#123;root.left=deleteNode(root.left,key);&#125;</span><br><span class="line">        if(root.right!=null)&#123;root.right=deleteNode(root.right,key);&#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="删除二叉树的特定节点"><a href="#删除二叉树的特定节点" class="headerlink" title="删除二叉树的特定节点"></a>删除二叉树的特定节点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//C++代码</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">        if (root == nullptr) return root;</span><br><span class="line">        if (root-&gt;val == key) &#123;</span><br><span class="line">            if (root-&gt;right == nullptr) &#123; // 这里第二次操作目标值：最终删除的作用</span><br><span class="line">                return root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *cur = root-&gt;right;</span><br><span class="line">            while (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(root-&gt;val, cur-&gt;val); // 这里第一次操作目标值：交换目标值其右子树最左面节点。</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> //LC669</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode trimBST(TreeNode root, int low, int high) &#123;</span><br><span class="line">        if(root==null)&#123;return root;&#125;</span><br><span class="line"></span><br><span class="line">        if(root.val&lt;low)&#123;//此时没有必要遍历左子树了</span><br><span class="line">            //新建一个节点来存root的右子树，之后返回这个节点，这个过程中，root被架空了</span><br><span class="line">            TreeNode right=trimBST(root.right,low,high);</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(root.val&gt;high)&#123;//此时没有必要遍历右子树了</span><br><span class="line">            TreeNode left=trimBST(root.left,low,high);</span><br><span class="line">            return left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(root.left!=null)&#123;root.left=trimBST(root.left,low,high);&#125;</span><br><span class="line">        if(root.right!=null)&#123;root.right=trimBST(root.right,low,high);&#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> //LC108</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</span><br><span class="line">        return dfs(nums,0,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode dfs(int[] nums,int left,int right)&#123;</span><br><span class="line">        if(left&gt;=right)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(right-left==1)&#123;</span><br><span class="line">            return new TreeNode(nums[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        int mid=left+(right-left)/2;</span><br><span class="line">        TreeNode root=new TreeNode(nums[mid]);</span><br><span class="line">        root.left=dfs(nums,left,mid);</span><br><span class="line">        root.right=dfs(nums,mid+1,right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将二叉搜索树转化为累加树"><a href="#将二叉搜索树转化为累加树" class="headerlink" title="将二叉搜索树转化为累加树"></a>将二叉搜索树转化为累加树</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> //LC538</span><br><span class="line">class Solution &#123;</span><br><span class="line">    int pre=0;</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;return;&#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        root.val+=pre;</span><br><span class="line">        pre=root.val;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;递归算法模板&quot;&gt;&lt;a href=&quot;#递归算法模板&quot; class=&quot;headerlink&quot; title=&quot;递归算法模板&quot;&gt;&lt;/a&gt;递归算法模板&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;返回值类型 dfs(参数) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (终止条件) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        存放结果;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 返回值类型;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    每层递归的逻辑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dfs(下层递归的参数);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="数据结构与算法" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="代码" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>关于如何让大脑保持清醒</title>
    <link href="http://example.com/2021/08/16/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%A7%E8%84%91%E4%BF%9D%E6%8C%81%E6%B8%85%E9%86%92/"/>
    <id>http://example.com/2021/08/16/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%A7%E8%84%91%E4%BF%9D%E6%8C%81%E6%B8%85%E9%86%92/</id>
    <published>2021-08-16T13:29:44.000Z</published>
    <updated>2021-08-16T13:35:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循序渐进的接受刺激"><a href="#循序渐进的接受刺激" class="headerlink" title="循序渐进的接受刺激"></a>循序渐进的接受刺激</h2><span id="more"></span><p><strong>循序渐进的接受刺激可以让我们更容易去做困难或者无趣的事情。每天里我们认为更无趣，更艰难的事，先去完成它。</strong></p><p>这并不是让我们不去娱乐，而是推迟我们娱乐的时间段。随着时间流逝，我们的意志力逐渐消沉时，这时就可以尽情的放松。</p><p>过多的刺激会让我们的大脑变得不清醒，比如我们刷朋友圈，看短视频等等，它让我们轻而易举的获得愉悦的感觉，让我们的大脑分泌多巴胺，肾上腺素，这时，大脑就会关闭我们大脑控制理智的一部分，去专心沉浸在预约之中。而此时，我们也就更难去做更无趣也更为慢节奏的事情了。</p><p>如果我们先在游戏或者视频中得到较高的刺激，之后我们再去做更无趣的事时，我们会难以开始或者坚持，宁愿什么也不干也不愿去做。</p><h2 id="清空大脑"><a href="#清空大脑" class="headerlink" title="清空大脑"></a>清空大脑</h2><p><strong>每一件可能的小事，每一件你必须要做的事，每一件你必须承担责任的事，每一件你必须记住的事，去把它们写下来。</strong></p><p>当我们忽然想到一些事情（不论任何事情，不管是要做的事，还是脑洞大开忽然想到的事），之后去撇开思绪，专注于眼前时，我们很可能并没有真正忘记那些事情，而是推给我们的潜意识。</p><p>当我们对需要注意的事，生活中的琐事等等事情处处留意时，我们很可能把它们都推给了潜意识，事情如果太多，我们便无法更好的专注于当下，甚至让我们产生焦虑。</p><p>把事情写下，就是把推给潜意识的思绪，转移到纸上，从而清空大脑，使大脑减负并且更清醒。</p><h2 id="艾森豪威尔法则"><a href="#艾森豪威尔法则" class="headerlink" title="艾森豪威尔法则"></a>艾森豪威尔法则</h2><p><strong>用事情重要与否，紧迫与否来衡量事情完成顺序的规则。</strong></p><p>既重要有紧迫的事，最先完成</p><p>紧迫但不重要的事，委托给别人或者稍后再做</p><p>重要但不紧迫的事，可以对这些事做些计划，在合适的时间好好解决它。</p><p>不重要同时不紧迫的事，放弃它们，不要去做。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;循序渐进的接受刺激&quot;&gt;&lt;a href=&quot;#循序渐进的接受刺激&quot; class=&quot;headerlink&quot; title=&quot;循序渐进的接受刺激&quot;&gt;&lt;/a&gt;循序渐进的接受刺激&lt;/h2&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="个人提高" scheme="http://example.com/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E9%AB%98/"/>
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="http://example.com/2021/08/14/Servlet/"/>
    <id>http://example.com/2021/08/14/Servlet/</id>
    <published>2021-08-14T13:13:22.000Z</published>
    <updated>2021-08-16T08:16:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet：  server applet"></a>Servlet：  server applet</h1><h2 id="概念：运行在服务器端的小程序"><a href="#概念：运行在服务器端的小程序" class="headerlink" title="概念：运行在服务器端的小程序"></a>概念：运行在服务器端的小程序</h2><pre><code>    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。    * 将来我们自定义一个类，实现Servlet接口，复写方法。</code></pre><span id="more"></span><h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><pre><code>    1. 创建JavaEE项目    2. 定义一个类，实现Servlet接口        * public class ServletDemo1 implements Servlet    3. 实现接口中的抽象方法    4. 配置Servlet         在web.xml中配置：        &lt;!--配置Servlet --&gt;        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;            &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;</code></pre><h2 id="执行原理："><a href="#执行原理：" class="headerlink" title="执行原理："></a>执行原理：</h2><pre><code>    1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。    3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内存，并且创建其对象    5. 调用其方法</code></pre><h2 id="Servlet中的生命周期方法："><a href="#Servlet中的生命周期方法：" class="headerlink" title="Servlet中的生命周期方法："></a>Servlet中的生命周期方法：</h2><pre><code>    1. 被创建：执行init方法，只执行一次        * Servlet什么时候被创建？            * 默认情况下，第一次被访问时，Servlet被创建            * 可以配置执行Servlet的创建时机。                * 在&lt;servlet&gt;标签下配置                    1. 第一次被访问时，创建                        * &lt;load-on-startup&gt;的值为负数                    2. 在服务器启动时，创建                        * &lt;load-on-startup&gt;的值为0或正整数        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的            * 多个用户同时访问时，可能存在线程安全问题。            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值    2. 提供服务：执行service方法，执行多次        * 每次访问Servlet时，Service方法都会被调用一次。    3. 被销毁：执行destroy方法，只执行一次        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁        * 只有服务器正常关闭时，才会执行destroy方法。        * destroy方法在Servlet被销毁之前执行，一般用于释放资源</code></pre><h2 id="Servlet3-0："><a href="#Servlet3-0：" class="headerlink" title="Servlet3.0："></a>Servlet3.0：</h2><pre><code>    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置            * @WebServlet(&quot;资源路径&quot;)            @Target(&#123;ElementType.TYPE&#125;)            @Retention(RetentionPolicy.RUNTIME)            @Documented            public @interface WebServlet &#123;                String name() default &quot;&quot;;//相当于&lt;Servlet-name&gt;                            String[] value() default &#123;&#125;;//代表urlPatterns()属性配置                            String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt;                            int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt;                            WebInitParam[] initParams() default &#123;&#125;;                            boolean asyncSupported() default false;                            String smallIcon() default &quot;&quot;;                            String largeIcon() default &quot;&quot;;                            String description() default &quot;&quot;;                            String displayName() default &quot;&quot;;            &#125;</code></pre><h2 id="IDEA与tomcat的相关配置"><a href="#IDEA与tomcat的相关配置" class="headerlink" title="IDEA与tomcat的相关配置"></a>IDEA与tomcat的相关配置</h2><pre><code>1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件    * 查看控制台的log：Using CATALINA_BASE:   &quot;C:\Users\fqy\.IntelliJIdea2018.1\system\tomcat\_itcast&quot;2. 工作空间项目    和     tomcat部署的web项目    * tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源    * WEB-INF目录下的资源不能被浏览器直接访问。3. 断点调试：使用&quot;小虫子&quot;启动 dubug 启动</code></pre><h2 id="Servlet的体系结构"><a href="#Servlet的体系结构" class="headerlink" title="Servlet的体系结构"></a>Servlet的体系结构</h2><pre><code>    Servlet -- 接口        |    GenericServlet -- 抽象类        |    HttpServlet  -- 抽象类    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对http协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost方法</code></pre><h2 id="Servlet相关配置"><a href="#Servlet相关配置" class="headerlink" title="Servlet相关配置"></a>Servlet相关配置</h2><pre><code>    1. urlpartten:Servlet访问路径        1. 一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;&#125;)        2. 路径定义规则：            1. /xxx：路径匹配            2. /xxx/xxx:多层路径，目录结构            3. *.do：扩展名匹配</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Servlet：-server-applet&quot;&gt;&lt;a href=&quot;#Servlet：-server-applet&quot; class=&quot;headerlink&quot; title=&quot;Servlet：  server applet&quot;&gt;&lt;/a&gt;Servlet：  server applet&lt;/h1&gt;&lt;h2 id=&quot;概念：运行在服务器端的小程序&quot;&gt;&lt;a href=&quot;#概念：运行在服务器端的小程序&quot; class=&quot;headerlink&quot; title=&quot;概念：运行在服务器端的小程序&quot;&gt;&lt;/a&gt;概念：运行在服务器端的小程序&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。
    * 将来我们自定义一个类，实现Servlet接口，复写方法。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    <category term="Servlet" scheme="http://example.com/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>XML与Tomcat</title>
    <link href="http://example.com/2021/08/12/XML%E4%B8%8ETomcat/"/>
    <id>http://example.com/2021/08/12/XML%E4%B8%8ETomcat/</id>
    <published>2021-08-12T14:27:31.000Z</published>
    <updated>2021-08-12T14:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XML："><a href="#XML：" class="headerlink" title="XML："></a>XML：</h1><h2 id="概念：Extensible-Markup-Language-可扩展标记语言"><a href="#概念：Extensible-Markup-Language-可扩展标记语言" class="headerlink" title="概念：Extensible Markup Language 可扩展标记语言"></a>概念：Extensible Markup Language 可扩展标记语言</h2><pre><code>    * 可扩展：标签都是自定义的。 &lt;user&gt;  &lt;student&gt;</code></pre><span id="more"></span><pre><code>    * 功能        * 存储数据            1. 配置文件            2. 在网络中传输    * xml与html的区别        1. xml标签都是自定义的，html标签是预定义。        2. xml的语法严格，html语法松散        3. xml是存储数据的，html是展示数据    * w3c:万维网联盟</code></pre><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><pre><code>    * 基本语法：        1. xml文档的后缀名 .xml        2. xml第一行必须定义为文档声明        3. xml文档中有且仅有一个根标签        4. 属性值必须使用引号(单双都可)引起来        5. 标签必须正确关闭        6. xml标签名称区分大小写    * 快速入门：        &lt;?xml version=&#39;1.0&#39; ?&gt;        &lt;users&gt;            &lt;user id=&#39;1&#39;&gt;                &lt;name&gt;zhangsan&lt;/name&gt;                &lt;age&gt;23&lt;/age&gt;                &lt;gender&gt;male&lt;/gender&gt;                &lt;br/&gt;            &lt;/user&gt;                        &lt;user id=&#39;2&#39;&gt;                &lt;name&gt;lisi&lt;/name&gt;                &lt;age&gt;24&lt;/age&gt;                &lt;gender&gt;female&lt;/gender&gt;            &lt;/user&gt;        &lt;/users&gt;            * 组成部分：        1. 文档声明            1. 格式：&lt;?xml 属性列表 ?&gt;            2. 属性列表：                * version：版本号，必须的属性                * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1                * standalone：是否独立                    * 取值：                        * yes：不依赖其他文件                        * no：依赖其他文件        2. 指令(了解)：结合css的            * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;        3. 标签：标签名称自定义的            * 规则：                * 名称可以包含字母、数字以及其他的字符                 * 名称不能以数字或者标点符号开始                 * 名称不能以字母 xml（或者 XML、Xml 等等）开始                 * 名称不能包含空格         4. 属性：            id属性值唯一        5. 文本：            * CDATA区：在该区域中的数据会被原样展示                * 格式：  &lt;![CDATA[ 数据 ]]&gt;    * 约束：规定xml文档的书写规则        * 作为框架的使用者(程序员)：            1. 能够在xml中引入约束文档            2. 能够简单的读懂约束文档                * 分类：            1. DTD:一种简单的约束技术            2. Schema:一种复杂的约束技术        * DTD：            * 引入dtd文档到xml文档中                * 内部dtd：将约束规则定义在xml文档中                * 外部dtd：将约束的规则定义在外部的dtd文件中                    * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;                    * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;        * Schema:            * 引入：                1.填写xml文档的根元素                2.引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;                3.引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;                4.为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot;             &lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;                xmlns=&quot;http://www.itcast.cn/xml&quot;                xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;</code></pre><h2 id="解析：操作xml文档，将文档中的数据读取到内存中"><a href="#解析：操作xml文档，将文档中的数据读取到内存中" class="headerlink" title="解析：操作xml文档，将文档中的数据读取到内存中"></a>解析：操作xml文档，将文档中的数据读取到内存中</h2><pre><code>    * 操作xml文档        1. 解析(读取)：将文档中的数据读取到内存中        2. 写入：将内存中的数据保存到xml文档中。持久化的存储    * 解析xml的方式：        1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树            * 优点：操作方便，可以对文档进行CRUD的所有操作            * 缺点：占内存        2. SAX：逐行读取，基于事件驱动的。            * 优点：不占内存。            * 缺点：只能读取，不能增删改        * xml常见的解析器：        1. JAXP：sun公司提供的解析器，支持dom和sax两种思想        2. DOM4J：一款非常优秀的解析器        3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。        4. PULL：Android操作系统内置的解析器，sax方式的。    * Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。        * 快速入门：            * 步骤：                1. 导入jar包                2. 获取Document对象                3. 获取对应的标签Element对象                4. 获取数据        * 代码：             //2.1获取student.xml的path            String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();            //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document            Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);            //3.获取元素对象 Element            Elements elements = document.getElementsByTag(&quot;name&quot;);                System.out.println(elements.size());            //3.1获取第一个name的Element对象            Element element = elements.get(0);            //3.2获取数据            String name = element.text();            System.out.println(name);    * 对象的使用：        1. Jsoup：工具类，可以解析html或xml文档，返回Document            * parse：解析html或xml文档，返回Document                * parse​(File in, String charsetName)：解析xml或html文件的。                * parse​(String html)：解析xml或html字符串                * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象        2. Document：文档对象。代表内存中的dom树            * 获取Element对象                * getElementById​(String id)：根据id属性值获取唯一的element对象                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合        3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用        4. Element：元素对象            1. 获取子元素对象                * getElementById​(String id)：根据id属性值获取唯一的element对象                * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合                * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合                * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合            2. 获取属性值                * String attr(String key)：根据属性名称获取属性值            3. 获取文本内容                * String text():获取文本内容                * String html():获取标签体的所有内容(包括字标签的字符串内容)        5. Node：节点对象            * 是Document和Element的父类            * 快捷查询方式：        1. selector:选择器            * 使用的方法：Elements    select​(String cssQuery)                * 语法：参考Selector类中定义的语法        2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言            * 使用Jsoup的Xpath需要额外导入jar包。            * 查询w3cshool参考手册，使用xpath的语法完成查询            * 代码：                //1.获取student.xml的path                String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();                //2.获取Document对象                Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);                        //3.根据document对象，创建JXDocument对象                JXDocument jxDocument = new JXDocument(document);                        //4.结合xpath语法查询                //4.1查询所有student标签                List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);                for (JXNode jxNode : jxNodes) &#123;                    System.out.println(jxNode);                &#125;                        System.out.println(&quot;--------------------&quot;);                        //4.2查询所有student标签下的name标签                List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);                for (JXNode jxNode : jxNodes2) &#123;                    System.out.println(jxNode);                &#125;                        System.out.println(&quot;--------------------&quot;);                        //4.3查询student标签下带有id属性的name标签                List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);                for (JXNode jxNode : jxNodes3) &#123;                    System.out.println(jxNode);                &#125;                System.out.println(&quot;--------------------&quot;);                //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast                        List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&#39;itcast&#39;]&quot;);                for (JXNode jxNode : jxNodes4) &#123;                    System.out.println(jxNode);                &#125;</code></pre><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h2><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析        * 如： html,css,JavaScript    2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器        * 如：servlet/jsp,php,asp....        3. 网络通信三要素    1. IP：电子设备(计算机)在网络中的唯一标识。    2. 端口：应用程序在计算机中的唯一标识。 0~65536    3. 传输协议：规定了数据传输的规则        1. 基础协议：            1. tcp:安全协议，三次握手。 速度稍慢            2. udp：不安全协议。 速度快</code></pre><h2 id="web服务器软件："><a href="#web服务器软件：" class="headerlink" title="web服务器软件："></a>web服务器软件：</h2><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应。    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范* Tomcat：web服务器软件    1. 下载：http://tomcat.apache.org/    2. 安装：解压压缩包即可。        * 注意：安装目录建议不要有中文和空格    3. 卸载：删除目录就行了    4. 启动：        * bin/startup.bat ,双击运行该文件即可        * 访问：浏览器输入：http://localhost:8080 回车访问自己                          http://别人的ip:8080 访问别人                * 可能遇到的问题：            1. 黑窗口一闪而过：                * 原因： 没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程                    * netstat -ano                2. 温柔：修改自身的端口号                    * conf/server.xml                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;                       connectionTimeout=&quot;20000&quot;                       redirectPort=&quot;8445&quot; /&gt;                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。                        * 好处：在访问时，就不用输入端口号    5. 关闭：        1. 正常关闭：            * bin/shutdown.bat            * ctrl+c        2. 强制关闭：            * 点击启动窗口的×    6. 配置:        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;                * docBase:项目存放的路径                * path：虚拟目录            3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写                &lt;Context docBase=&quot;D:\hello&quot; /&gt;                * 虚拟目录：xml文件的名称                * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- classes目录：放置字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;XML：&quot;&gt;&lt;a href=&quot;#XML：&quot; class=&quot;headerlink&quot; title=&quot;XML：&quot;&gt;&lt;/a&gt;XML：&lt;/h1&gt;&lt;h2 id=&quot;概念：Extensible-Markup-Language-可扩展标记语言&quot;&gt;&lt;a href=&quot;#概念：Extensible-Markup-Language-可扩展标记语言&quot; class=&quot;headerlink&quot; title=&quot;概念：Extensible Markup Language 可扩展标记语言&quot;&gt;&lt;/a&gt;概念：Extensible Markup Language 可扩展标记语言&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    * 可扩展：标签都是自定义的。 &amp;lt;user&amp;gt;  &amp;lt;student&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    <category term="XML" scheme="http://example.com/tags/XML/"/>
    
    <category term="Tomcat" scheme="http://example.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>HTML与CSS</title>
    <link href="http://example.com/2021/08/06/HTML%E4%B8%8ECSS/"/>
    <id>http://example.com/2021/08/06/HTML%E4%B8%8ECSS/</id>
    <published>2021-08-06T05:22:47.000Z</published>
    <updated>2021-08-06T05:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h1><h2 id="JavaWeb："><a href="#JavaWeb：" class="headerlink" title="JavaWeb："></a>JavaWeb：</h2><pre><code>    * 使用Java语言开发基于互联网的项目</code></pre><span id="more"></span><h2 id="软件架构："><a href="#软件架构：" class="headerlink" title="软件架构："></a>软件架构：</h2><pre><code>    1. C/S: Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装，部署，维护 麻烦    2. B/S: Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序        * 优点：            1. 开发、安装，部署，维护 简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高</code></pre><h2 id="B-S架构详解"><a href="#B-S架构详解" class="headerlink" title="B/S架构详解"></a>B/S架构详解</h2><pre><code>    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源。            * 特点：                * 所有用户访问，得到的结果是一样的。                * 如：文本，图片，音频、视频, HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源        2. 动态资源：            * 使用动态网页及时发布的资源。            * 特点：                * 所有用户访问，得到的结果可能不一样。                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="概念：是最基础的网页开发语言"><a href="#概念：是最基础的网页开发语言" class="headerlink" title="概念：是最基础的网页开发语言"></a>概念：是最基础的网页开发语言</h2><pre><code>    * Hyper Text Markup Language 超文本标记语言        * 超文本:            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.        * 标记语言:            * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml            * 标记语言不是编程语言</code></pre><h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><pre><code>    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，但是建议使用小写。</code></pre><h2 id="标签学习："><a href="#标签学习：" class="headerlink" title="标签学习："></a>标签学习：</h2><h3 id="文件标签：构成html最基本的标签"><a href="#文件标签：构成html最基本的标签" class="headerlink" title="文件标签：构成html最基本的标签"></a>文件标签：构成html最基本的标签</h3><pre><code>        * html:html文档的根标签        * head：头标签。用于指定html文档的一些属性。引入外部的资源        * title：标题标签。        * body：体标签        * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档</code></pre><h3 id="文本标签：和文本有关的标签"><a href="#文本标签：和文本有关的标签" class="headerlink" title="文本标签：和文本有关的标签"></a>文本标签：和文本有关的标签</h3><pre><code>        * 注释：&lt;!-- 注释内容 --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6:字体大小逐渐递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对其方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;:字体标签        * &lt;center&gt;:文本居中            * 属性：                * color：颜色                * size：大小                * face：字体        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)                3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF            * width：                1. 数值：width=&#39;20&#39; ,数值的单位，默认是 px(像素)                2. 数值%：占比相对于父元素的比例</code></pre><h3 id="图片标签："><a href="#图片标签：" class="headerlink" title="图片标签："></a>图片标签：</h3><pre><code>        * img：展示图片            * 属性：                * src：指定图片的位置        * 代码：             &lt;!--展示一张图片 img--&gt;            &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;                    &lt;!--                相对路径                    * 以.开头的路径                        * ./：代表当前目录  ./image/1.jpg                        * ../:代表上一级目录             --&gt;                    &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;                    &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;</code></pre><h3 id="列表标签："><a href="#列表标签：" class="headerlink" title="列表标签："></a>列表标签：</h3><pre><code>        * 有序列表：            * ol:            * li:        * 无序列表：            * ul:            * li:</code></pre><h3 id="链接标签："><a href="#链接标签：" class="headerlink" title="链接标签："></a>链接标签：</h3><pre><code>        * a:定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self:默认值，在当前页面打开                    * _blank：在空白页面打开        * 代码：             &lt;!--超链接  a--&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;                    &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;            &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;                    &lt;br&gt;                    &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;            &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;                    &lt;br&gt;            &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;</code></pre><h3 id="div和span："><a href="#div和span：" class="headerlink" title="div和span："></a>div和span：</h3><pre><code>        * div:每一个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签 内联标签</code></pre><h3 id="语义化标签：html5中为了提高程序的可读性，提供了一些标签。"><a href="#语义化标签：html5中为了提高程序的可读性，提供了一些标签。" class="headerlink" title="语义化标签：html5中为了提高程序的可读性，提供了一些标签。"></a>语义化标签：html5中为了提高程序的可读性，提供了一些标签。</h3><pre><code>        1. &lt;header&gt;：页眉        2. &lt;footer&gt;：页脚</code></pre><h3 id="表格标签："><a href="#表格标签：" class="headerlink" title="表格标签："></a>表格标签：</h3><pre><code>        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并列            * rowspan：合并行        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分            </code></pre><h3 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h3><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围        * 属性：            * action：指定提交数据的URL            * method:指定提交方式                * 分类：一共7种，2种比较常用                   * get：                        1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。                        2. 请求参数大小是有限制的。                        3. 不太安全。                   * post：                        2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制。                        3. 较为安全。        * 表单项中的数据要想被提交：必须指定其name属性        * 表单项标签：        * input：可以通过type属性值，改变元素展示的样式            * type属性：                * text：文本输入框，默认值                    * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息                    * password：密码输入框                * radio:单选框                    * 注意：                        1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。                        2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        3. checked属性，可以指定默认值                * checkbox：复选框                    * 注意：                        1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                        2. checked属性，可以指定默认值                * file：文件选择框                * hidden：隐藏域，用于提交一些信息。                * 按钮：                    * submit：提交按钮。可以提交表单                    * button：普通按钮                    * image：图片提交按钮                        * src属性指定图片的路径               * label：指定输入项的文字描述信息               * 注意：                   * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。        * select: 下拉列表            * 子元素：option，指定列表项                    * textarea：文本域            * cols：指定列数，每一行有多少个字符            * rows：默认多少行。</code></pre><h1 id="CSS：页面美化和布局控制"><a href="#CSS：页面美化和布局控制" class="headerlink" title="CSS：页面美化和布局控制"></a>CSS：页面美化和布局控制</h1><h2 id="概念：-Cascading-Style-Sheets-层叠样式表"><a href="#概念：-Cascading-Style-Sheets-层叠样式表" class="headerlink" title="概念： Cascading Style Sheets 层叠样式表"></a>概念： Cascading Style Sheets 层叠样式表</h2><pre><code>    * 层叠：多个样式可以作用在同一个html的元素上，同时生效</code></pre><h2 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h2><pre><code>    1. 功能强大    2. 将内容展示和样式控制分离        * 降低耦合度。解耦        * 让分工协作更容易        * 提高开发效率</code></pre><h2 id="CSS的使用：CSS与html结合方式"><a href="#CSS的使用：CSS与html结合方式" class="headerlink" title="CSS的使用：CSS与html结合方式"></a>CSS的使用：CSS与html结合方式</h2><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><pre><code>         * 在标签内使用style属性指定css代码         * 如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;</code></pre><h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><pre><code>        * 在head标签内，定义style标签，style标签的标签体内容就是css代码        * 如：            &lt;style&gt;                div&#123;                    color:blue;                &#125;                    &lt;/style&gt;            &lt;div&gt;hello css&lt;/div&gt;</code></pre><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><pre><code>        1. 定义css资源文件。        2. 在head标签内，定义link标签，引入外部的资源文件        * 如：            * a.css文件：                div&#123;                    color:green;                &#125;            &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;            &lt;div&gt;hello css&lt;/div&gt;            &lt;div&gt;hello css&lt;/div&gt;    * 注意：        * 1,2,3种方式 css作用范围越来越大        * 1方式不常用，后期常用2,3        * 3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;</code></pre><h3 id="css语法："><a href="#css语法：" class="headerlink" title="css语法："></a>css语法：</h3><pre><code>    * 格式：        选择器 &#123;            属性名1:属性值1;            属性名2:属性值2;            ...        &#125;    * 选择器:筛选具有相似特征的元素    * 注意：        * 每一对属性需要使用；隔开，最后一对属性可以不加；</code></pre><h3 id="选择器：筛选具有相似特征的元素"><a href="#选择器：筛选具有相似特征的元素" class="headerlink" title="选择器：筛选具有相似特征的元素"></a>选择器：筛选具有相似特征的元素</h3><pre><code>    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一                * 语法：#id属性值&#123;&#125;            2. 元素选择器：选择具有相同标签名称的元素                * 语法： 标签名称&#123;&#125;                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性值的元素。                * 语法：.class属性值&#123;&#125;                * 注意：类选择器选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素：                * 语法： *&#123;&#125;            2. 并集选择器：                * 选择器1,选择器2&#123;&#125;                        3. 子选择器：筛选选择器1元素下的选择器2元素                * 语法：  选择器1 选择器2&#123;&#125;            4. 父选择器：筛选选择器2的父元素选择器1                * 语法：  选择器1 &gt; 选择器2&#123;&#125;            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：  元素名称[属性名=&quot;属性值&quot;]&#123;&#125;            6. 伪类选择器：选择一些元素具有的状态                * 语法： 元素:状态&#123;&#125;                * 如： &lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-align：对其方式        * line-height：行高     2. 背景        * background：    3. 边框        * border：设置边框，符合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小        * float：浮动            * left            * right        </code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;web概念概述&quot;&gt;&lt;a href=&quot;#web概念概述&quot; class=&quot;headerlink&quot; title=&quot;web概念概述&quot;&gt;&lt;/a&gt;web概念概述&lt;/h1&gt;&lt;h2 id=&quot;JavaWeb：&quot;&gt;&lt;a href=&quot;#JavaWeb：&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb：&quot;&gt;&lt;/a&gt;JavaWeb：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    * 使用Java语言开发基于互联网的项目
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    <category term="HTML" scheme="http://example.com/tags/HTML/"/>
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础</title>
    <link href="http://example.com/2021/08/03/JavaScript/"/>
    <id>http://example.com/2021/08/03/JavaScript/</id>
    <published>2021-08-03T01:48:27.000Z</published>
    <updated>2021-08-06T05:29:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript："><a href="#JavaScript：" class="headerlink" title="JavaScript："></a>JavaScript：</h1><h2 id="概念：-一门客户端脚本语言"><a href="#概念：-一门客户端脚本语言" class="headerlink" title="概念：    一门客户端脚本语言"></a>概念：    一门客户端脚本语言</h2><pre><code>    * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了</code></pre><span id="more"></span><h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><pre><code>    * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</code></pre><h2 id="JavaScript发展史："><a href="#JavaScript发展史：" class="headerlink" title="JavaScript发展史："></a>JavaScript发展史：</h2><pre><code>    1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--    ，后来更名为：ScriptEase    2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript    3. 1996年，微软抄袭JavaScript开发出JScript语言    4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。    * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)</code></pre><h2 id="ECMAScript：客户端脚本语言的标准"><a href="#ECMAScript：客户端脚本语言的标准" class="headerlink" title="ECMAScript：客户端脚本语言的标准"></a>ECMAScript：客户端脚本语言的标准</h2><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><pre><code>        1. 与html结合方式            1. 内部JS：                * 定义&lt;script&gt;，标签体内容就是js代码            2. 外部JS：                * 定义&lt;script&gt;，通过src属性引入外部的js文件            * 注意：                1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。                2. &lt;script&gt;可以定义多个。        2. 注释            1. 单行注释：//注释内容            2. 多行注释：/*注释内容*/        3. 数据类型：            1. 原始数据类型(基本数据类型)：                1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)                2. string：字符串。 字符串  &quot;abc&quot; &quot;a&quot; &#39;abc&#39;                3. boolean: true和false                4. null：一个对象为空的占位符                5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined                            2. 引用数据类型：对象                    4. 变量            * 变量：一小块存储数据的内存空间            * Java语言是强类型语言，而JavaScript是弱类型语言。                * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据                * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。            * 语法：                * var 变量名 = 初始化值;                        * typeof运算符：获取变量的类型。                * 注：null运算后得到的是object        5. 运算符            1. 一元运算符：只有一个运算数的运算符                ++，-- ， +(正号)                  * ++ --: 自增(自减)                    * ++(--) 在前，先自增(自减)，再运算                    * ++(--) 在后，先运算，再自增(自减)                * +(-)：正负号                * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换                    * 其他类型转number：                        * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）                        * boolean转number：true转为1，false转为0            2. 算数运算符                + - * / % ...            3. 赋值运算符                = += -+....            4. 比较运算符                &gt; &lt; &gt;= &lt;= == ===(全等于)                * 比较方式                  1. 类型相同：直接比较                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。                  2. 类型不同：先进行类型转换，再比较                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false                            5. 逻辑运算符                &amp;&amp; || !                * 其他类型转boolean：                   1. number：0或NaN为假，其他为真                   2. string：除了空字符串(&quot;&quot;)，其他都是true                   3. null&amp;undefined:都是false                   4. 对象：所有对象都为true                        6. 三元运算符                ? : 表达式                var a = 3;                var b = 4;                        var c = a &gt; b ? 1:0;                * 语法：                    * 表达式? 值1:值2;                    * 判断表达式的值，如果是true则取值1，如果是false则取值2；                    6. 流程控制语句：            1. if...else...            2. switch:                * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)                    * switch(变量):                        case 值:                * 在JS中,switch语句可以接受任意的原始数据类型            3. while            4. do...while            5. for        7. JS特殊语法：            1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)            2. 变量的定义使用var关键字，也可以不使用                * 用： 定义的变量是局部变量                * 不用：定义的变量是全局变量(不建议)        8. 练习：99乘法表        &lt;!DOCTYPE html&gt;        &lt;html lang=&quot;en&quot;&gt;        &lt;head&gt;            &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;title&gt;99乘法表&lt;/title&gt;            &lt;style&gt;                td&#123;                    border: 1px solid;                &#125;                    &lt;/style&gt;                    &lt;script&gt;                        document.write(&quot;&lt;table  align=&#39;center&#39;&gt;&quot;);                                //1.完成基本的for循环嵌套，展示乘法表                for (var i = 1; i &lt;= 9 ; i++) &#123;                    document.write(&quot;&lt;tr&gt;&quot;);                    for (var j = 1; j &lt;=i ; j++) &#123;                        document.write(&quot;&lt;td&gt;&quot;);                                //输出  1 * 1 = 1                        document.write(i + &quot; * &quot; + j + &quot; = &quot; + ( i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);                                document.write(&quot;&lt;/td&gt;&quot;);                    &#125;                    /*//输出换行                    document.write(&quot;&lt;br&gt;&quot;);*/                            document.write(&quot;&lt;/tr&gt;&quot;);                &#125;                        //2.完成表格嵌套                document.write(&quot;&lt;/table&gt;&quot;);                    &lt;/script&gt;        &lt;/head&gt;        &lt;body&gt;                &lt;/body&gt;        &lt;/html&gt;</code></pre><h3 id="基本对象："><a href="#基本对象：" class="headerlink" title="基本对象："></a>基本对象：</h3><pre><code>        1. Function：函数(方法)对象            1. 创建：                1. var fun = new Function(形式参数列表,方法体);  //忘掉吧                2.                     function 方法名称(形式参数列表)&#123;                        方法体                    &#125;                3.                    var 方法名 = function(形式参数列表)&#123;                        方法体                   &#125;                       2. 属性：                length:代表形参的个数            3. 特点：                1. 方法定义是，形参的类型不用写,返回值类型也不写。                2. 方法是一个对象，如果定义名称相同的方法，会覆盖                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关                4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数            4. 调用：                方法名称(实际参数列表);                2. Array:数组对象            1. 创建：                1. var arr = new Array(元素列表);                2. var arr = new Array(默认长度);                3. var arr = [元素列表];            2. 方法                join(参数):将数组中的元素按照指定的分隔符拼接为字符串                push()    向数组的末尾添加一个或更多元素，并返回新的长度。            3. 属性                length:数组的长度            4. 特点：                1. JS中，数组元素的类型可变的。                2. JS中，数组长度可变的。        3. Boolean        4. Date：日期对象            1. 创建：                var date = new Date();            2. 方法：                toLocaleString()：返回当前date对象对应的时间本地字符串格式                getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差        5. Math：数学对象            1. 创建：                * 特点：Math对象不用创建，直接使用。  Math.方法名();            2. 方法：                random():返回 0 ~ 1 之间的随机数。 含0不含1                ceil(x)：对数进行上舍入。                floor(x)：对数进行下舍入。                round(x)：把数四舍五入为最接近的整数。            3. 属性：                PI        6. Number        7. String        8. RegExp：正则表达式对象            1. 正则表达式：定义字符串的组成规则。                1. 单个字符:[]                    如： [a] [ab] [a-zA-Z0-9_]                    * 特殊符号代表特殊含义的单个字符:                        \d:单个数字字符 [0-9]                        \w:单个单词字符[a-zA-Z0-9_]                2. 量词符号：                    ?：表示出现0次或1次                    *：表示出现0次或多次                    +：出现1次或多次                    &#123;m,n&#125;:表示 m&lt;= 数量 &lt;= n                        * m如果缺省： &#123;,n&#125;:最多n次                        * n如果缺省：&#123;m,&#125; 最少m次                3. 开始结束符号                    * ^:开始                    * $:结束            2. 正则对象：                1. 创建                    1. var reg = new RegExp(&quot;正则表达式&quot;);                    2. var reg = /正则表达式/;                2. 方法                        1. test(参数):验证指定的字符串是否符合正则定义的规范            9. Global            1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();            2. 方法：                encodeURI():url编码                decodeURI():url解码                encodeURIComponent():url编码,编码的字符更多                decodeURIComponent():url解码                parseInt():将字符串转为数字                    * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number                isNaN():判断一个值是否是NaN                    * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false                eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。            </code></pre><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h2><h3 id="概念：Browser-Object-Model-浏览器对象模型"><a href="#概念：Browser-Object-Model-浏览器对象模型" class="headerlink" title="概念：Browser Object Model 浏览器对象模型"></a>概念：Browser Object Model 浏览器对象模型</h3><pre><code>    * 将浏览器的各个组成部分封装成对象。</code></pre><h3 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h3><pre><code>    * Window：窗口对象    * Navigator：浏览器对象    * Screen：显示器屏幕对象    * History：历史记录对象    * Location：地址栏对象</code></pre><h3 id="Window：窗口对象"><a href="#Window：窗口对象" class="headerlink" title="Window：窗口对象"></a>Window：窗口对象</h3><pre><code>    1. 创建    2. 方法         1. 与弹出框有关的方法：            alert()    显示带有一段消息和一个确认按钮的警告框。            confirm()    显示带有一段消息以及确认按钮和取消按钮的对话框。                * 如果用户点击确定按钮，则方法返回true                * 如果用户点击取消按钮，则方法返回false            prompt()    显示可提示用户输入的对话框。                * 返回值：获取用户输入的值         2. 与打开关闭有关的方法：            close()    关闭浏览器窗口。                * 谁调用我 ，我关谁            open()    打开一个新的浏览器窗口                * 返回新的Window对象         3. 与定时器有关的方式            setTimeout()    在指定的毫秒数后调用函数或计算表达式。                * 参数：                    1. js代码或者方法对象                    2. 毫秒值                * 返回值：唯一标识，用于取消定时器            clearTimeout()    取消由 setTimeout() 方法设置的 timeout。            setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。            clearInterval()    取消由 setInterval() 设置的 timeout。    3. 属性：        1. 获取其他BOM对象：            history            location            Navigator            Screen:        2. 获取DOM对象            document    4. 特点        * Window对象不需要创建可以直接使用 window使用。 window.方法名();        * window引用可以省略。  方法名();</code></pre><h3 id="Location：地址栏对象"><a href="#Location：地址栏对象" class="headerlink" title="Location：地址栏对象"></a>Location：地址栏对象</h3><pre><code>    1. 创建(获取)：        1. window.location        2. location    2. 方法：        * reload()    重新加载当前文档。刷新    3. 属性        * href    设置或返回完整的 URL。</code></pre><h3 id="History：历史记录对象"><a href="#History：历史记录对象" class="headerlink" title="History：历史记录对象"></a>History：历史记录对象</h3><pre><code>    1. 创建(获取)：        1. window.history        2. history    2. 方法：        * back()    加载 history 列表中的前一个 URL。        * forward()    加载 history 列表中的下一个 URL。        * go(参数)    加载 history 列表中的某个具体页面。            * 参数：                * 正数：前进几个历史记录                * 负数：后退几个历史记录    3. 属性：        * length    返回当前窗口历史列表中的 URL 数量。</code></pre><h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><h3 id="概念：-Document-Object-Model-文档对象模型"><a href="#概念：-Document-Object-Model-文档对象模型" class="headerlink" title="概念： Document Object Model 文档对象模型"></a>概念： Document Object Model 文档对象模型</h3><pre><code>    * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</code></pre><h3 id="W3C-DOM-标准被分为-3-个不同的部分："><a href="#W3C-DOM-标准被分为-3-个不同的部分：" class="headerlink" title="W3C DOM 标准被分为 3 个不同的部分："></a>W3C DOM 标准被分为 3 个不同的部分：</h3><pre><code>    * 核心 DOM - 针对任何结构化文档的标准模型        * Document：文档对象        * Element：元素对象        * Attribute：属性对象        * Text：文本对象        * Comment:注释对象        * Node：节点对象，其他5个的父对象    * XML DOM - 针对 XML 文档的标准模型    * HTML DOM - 针对 HTML 文档的标准模型* 核心DOM模型：    * Document：文档对象        1. 创建(获取)：在html dom模型中可以使用window对象来获取            1. window.document            2. document        2. 方法：            1. 获取Element对象：                1. getElementById()    ： 根据id属性值获取元素对象。id属性值一般唯一                2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组                3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组                4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组            2. 创建其他DOM对象：                createAttribute(name)                createComment()                createElement()                createTextNode()        3. 属性    * Element：元素对象        1. 获取/创建：通过document来获取和创建        2. 方法：            1. removeAttribute()：删除属性            2. setAttribute()：设置属性    * Node：节点对象，其他5个的父对象        * 特点：所有dom对象都可以被认为是一个节点        * 方法：            * CRUD dom树：                * appendChild()：向节点的子节点列表的结尾添加新的子节点。                * removeChild()    ：删除（并返回）当前节点的指定子节点。                * replaceChild()：用新节点替换一个子节点。        * 属性：            * parentNode 返回节点的父节点。* HTML DOM    1. 标签体的设置和获取：innerHTML    2. 使用html元素对象的属性    3. 控制元素样式        1. 使用元素的style属性来设置            如：                 //修改样式方式1                div1.style.border = &quot;1px solid red&quot;;                div1.style.width = &quot;200px&quot;;                //font-size--&gt; fontSize                div1.style.fontSize = &quot;20px&quot;;        2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</code></pre><h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><h3 id="概念：某些组件被执行了某些操作后，触发某些代码的执行。"><a href="#概念：某些组件被执行了某些操作后，触发某些代码的执行。" class="headerlink" title="概念：某些组件被执行了某些操作后，触发某些代码的执行。"></a>概念：某些组件被执行了某些操作后，触发某些代码的执行。</h3><pre><code>    * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了    * 事件源：组件。如： 按钮 文本输入框...    * 监听器：代码。    * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。</code></pre><h3 id="常见的事件："><a href="#常见的事件：" class="headerlink" title="常见的事件："></a>常见的事件：</h3><pre><code>    1. 点击事件：        1. onclick：单击事件        2. ondblclick：双击事件    2. 焦点事件        1. onblur：失去焦点        2. onfocus:元素获得焦点。    3. 加载事件：        1. onload：一张页面或一幅图像完成加载。    4. 鼠标事件：        1. onmousedown    鼠标按钮被按下。        2. onmouseup    鼠标按键被松开。        3. onmousemove    鼠标被移动。        4. onmouseover    鼠标移到某元素之上。        5. onmouseout    鼠标从某元素移开。                    5. 键盘事件：        1. onkeydown    某个键盘按键被按下。            2. onkeyup        某个键盘按键被松开。        3. onkeypress    某个键盘按键被按下并松开。    6. 选择和改变        1. onchange    域的内容被改变。        2. onselect    文本被选中。    7. 表单事件：        1. onsubmit    确认按钮被点击。        2. onreset    重置按钮被点击。</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript：&quot;&gt;&lt;a href=&quot;#JavaScript：&quot; class=&quot;headerlink&quot; title=&quot;JavaScript：&quot;&gt;&lt;/a&gt;JavaScript：&lt;/h1&gt;&lt;h2 id=&quot;概念：-一门客户端脚本语言&quot;&gt;&lt;a href=&quot;#概念：-一门客户端脚本语言&quot; class=&quot;headerlink&quot; title=&quot;概念：    一门客户端脚本语言&quot;&gt;&lt;/a&gt;概念：    一门客户端脚本语言&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎
    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JDBC基础</title>
    <link href="http://example.com/2021/07/26/JDBC%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/07/26/JDBC%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-26T14:10:07.000Z</published>
    <updated>2021-08-03T01:54:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h1><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</code></pre><span id="more"></span><pre><code>2. 快速入门：    * 步骤：        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下            2.右键--&gt;Add As Library        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接受返回结果        7. 处理结果        8. 释放资源    * 代码实现：          //1. 导入驱动jar包        //2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);        //4.定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        //5.获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //6.执行sql        int count = stmt.executeUpdate(sql);        //7.处理结果        System.out.println(count);        //8.释放资源        stmt.close();        conn.close();3. 详解各个对象：    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。                 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                 static &#123;                        try &#123;                            java.sql.DriverManager.registerDriver(new Driver());                        &#125; catch (SQLException E) &#123;                            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);                        &#125;                    &#125;                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接：                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子：jdbc:mysql://localhost:3306/db3                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql 的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                 * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql) ：可以执行任意的sql 了解             2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码：                Statement stmt = null;                Connection conn = null;                try &#123;                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;                    //3.获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);                    //4.获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5.执行sql                    int count = stmt.executeUpdate(sql);//影响的行数                    //6.处理结果                    System.out.println(count);                    if(count &gt; 0)&#123;                        System.out.println(&quot;添加成功！&quot;);                    &#125;else&#123;                        System.out.println(&quot;添加失败！&quot;);                    &#125;                        &#125; catch (ClassNotFoundException e) &#123;                    e.printStackTrace();                &#125; catch (SQLException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    //stmt.close();                    //7. 释放资源                    //避免空指针异常                    if(stmt != null)&#123;                        try &#123;                            stmt.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                            if(conn != null)&#123;                        try &#123;                            conn.close();                        &#125; catch (SQLException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;                4. ResultSet：结果集对象,封装查询结果        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx：代表数据类型   如： int getInt() ,    String getString()            * 参数：                1. int：代表列的编号,从1开始   如： getString(1)                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)                * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据               //循环判断游标是否是最后一行末尾。                while(rs.next())&#123;                    //获取数据                    //6.2 获取数据                    int id = rs.getInt(1);                    String name = rs.getString(&quot;name&quot;);                    double balance = rs.getDouble(3);                        System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);                &#125;        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll()&#123;&#125;                3. 实现方法 select * from emp;                        5. PreparedStatement：执行sql的对象        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题            1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a            2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;         2. 解决sql注入问题：使用PreparedStatement对象来解决        3. 预编译的SQL：参数使用?作为占位符        4. 步骤：            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            2. 注册驱动            3. 获取数据库连接对象 Connection            4. 定义sql                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)             6. 给？赋值：                * 方法： setXxx(参数1,参数2)                    * 参数1：？的位置编号 从1 开始                    * 参数2：？的值            7. 执行sql，接受返回结果，不需要传递sql语句            8. 处理结果            9. 释放资源        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止SQL注入            2. 效率更高</code></pre><h1 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h1><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=    3. 抽取一个方法释放资源* 代码实现：    public class JDBCUtils &#123;    private static String url;    private static String user;    private static String password;    private static String driver;    /**     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块     */    static&#123;        //读取资源文件，获取值。        try &#123;            //1. 创建Properties集合类。            Properties pro = new Properties();            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);            String path = res.getPath();            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties            //2. 加载文件           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));            pro.load(new FileReader(path));            //3. 获取数据，赋值            url = pro.getProperty(&quot;url&quot;);            user = pro.getProperty(&quot;user&quot;);            password = pro.getProperty(&quot;password&quot;);            driver = pro.getProperty(&quot;driver&quot;);            //4. 注册驱动            Class.forName(driver);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 获取连接     * @return 连接对象     */    public static Connection getConnection() throws SQLException &#123;        return DriverManager.getConnection(url, user, password);    &#125;    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(Statement stmt,Connection conn)&#123;        if( stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( conn != null)&#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(ResultSet rs,Statement stmt, Connection conn)&#123;        if( rs != null)&#123;            try &#123;                rs.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( stmt != null)&#123;            try &#123;                stmt.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        if( conn != null)&#123;            try &#123;                conn.close();            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登录成功            * select * from user where username = &quot;&quot; and password = &quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)                        );            INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);            INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;);        2. 代码实现：            public class JDBCDemo9 &#123;                public static void main(String[] args) &#123;                    //1.键盘录入，接受用户名和密码                    Scanner sc = new Scanner(System.in);                    System.out.println(&quot;请输入用户名：&quot;);                    String username = sc.nextLine();                    System.out.println(&quot;请输入密码：&quot;);                    String password = sc.nextLine();                    //2.调用方法                    boolean flag = new JDBCDemo9().login(username, password);                    //3.判断结果，输出不同语句                    if(flag)&#123;                        //登录成功                        System.out.println(&quot;登录成功！&quot;);                    &#125;else&#123;                        System.out.println(&quot;用户名或密码错误！&quot;);                    &#125;                                        &#125;                                                    /**                 * 登录方法                 */                public boolean login(String username ,String password)&#123;                    if(username == null || password == null)&#123;                        return false;                    &#125;                    //连接数据库判断是否登录成功                    Connection conn = null;                    Statement stmt =  null;                    ResultSet rs = null;                    //1.获取连接                    try &#123;                        conn =  JDBCUtils.getConnection();                        //2.定义sql                        String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39; &quot;;                        //3.获取执行sql的对象                        stmt = conn.createStatement();                        //4.执行查询                        rs = stmt.executeQuery(sql);                        //5.判断                       /* if(rs.next())&#123;//如果有下一行，则返回true                            return true;                        &#125;else&#123;                            return false;                        &#125;*/                       return rs.next();//如果有下一行，则返回true                                &#125; catch (SQLException e) &#123;                        e.printStackTrace();                    &#125;finally &#123;                        JDBCUtils.close(rs,stmt,conn);                    &#125;                                            return false;                &#125;            &#125;</code></pre><h1 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h1><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作：    1. 开启事务    2. 提交事务    3. 回滚事务3. 使用Connection对象来管理事务    * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务        * 在执行sql之前开启事务    * 提交事务：commit()         * 当所有sql都执行完提交事务    * 回滚事务：rollback()         * 在catch中回滚事务4. 代码：    public class JDBCDemo10 &#123;        public static void main(String[] args) &#123;            Connection conn = null;            PreparedStatement pstmt1 = null;            PreparedStatement pstmt2 = null;                try &#123;                //1.获取连接                conn = JDBCUtils.getConnection();                //开启事务                conn.setAutoCommit(false);                    //2.定义sql                //2.1 张三 - 500                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;                //2.2 李四 + 500                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;                //3.获取执行sql对象                pstmt1 = conn.prepareStatement(sql1);                pstmt2 = conn.prepareStatement(sql2);                //4. 设置参数                pstmt1.setDouble(1,500);                pstmt1.setInt(2,1);                    pstmt2.setDouble(1,500);                pstmt2.setInt(2,2);                //5.执行sql                pstmt1.executeUpdate();                // 手动制造异常                int i = 3/0;                    pstmt2.executeUpdate();                //提交事务                conn.commit();            &#125; catch (Exception e) &#123;                //事务回滚                try &#123;                    if(conn != null) &#123;                        conn.rollback();                    &#125;                &#125; catch (SQLException e1) &#123;                    e1.printStackTrace();                &#125;                e.printStackTrace();            &#125;finally &#123;                JDBCUtils.close(pstmt1,conn);                JDBCUtils.close(pstmt2,null);            &#125;                &#125;        &#125;        </code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JDBC：&quot;&gt;&lt;a href=&quot;#JDBC：&quot; class=&quot;headerlink&quot; title=&quot;JDBC：&quot;&gt;&lt;/a&gt;JDBC：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库
    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    <category term="JDBC" scheme="http://example.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL基础</title>
    <link href="http://example.com/2021/07/22/MYSQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/07/22/MYSQL%E5%9F%BA%E7%A1%80/</id>
    <published>2021-07-22T15:15:00.000Z</published>
    <updated>2021-08-03T01:53:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h1><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB </code></pre><span id="more"></span><pre><code>2. 什么是数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL</code></pre><h1 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。    2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */    3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h2 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h2><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间戳类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符        * 创建表            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table  if exists 表名 ;</code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;1. 语法：    select        字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名；        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略3. 条件查询    1. where子句后跟条件    2. 运算符        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !                    -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;                        SELECT * FROM student WHERE age &gt;= 20;                        -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;                        -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;                        -- 查询年龄大于等于20 小于等于30                        SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;                        -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);                        -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断                        SELECT * FROM student WHERE english IS NULL;                        -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;            -- 查询姓名第二个字是化的人                        SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;                        -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;                        -- 查询姓名中包含德的人            SELECT * FROM student WHERE NAME LIKE &#39;%德%&#39;;1. 排序查询    * 语法：order by 子句        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...    * 排序方式：        * ASC：升序，默认的。        * DESC：降序。    * 注意：        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。    1. count：计算个数        1. 一般选择非空的列：主键        2. count(*)    2. max：计算最大值    3. min：计算最小值    4. sum：计算和    5. avg：计算平均值    * 注意：聚合函数的计算，排除null值。        解决方案：            1. 选择不包含非空的列进行计算            2. IFNULL函数3. 分组查询:    1. 语法：group by 分组字段；    2. 注意：        1. 分组之后查询的字段：分组字段、聚合函数        2. where 和 having 的区别？            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。        -- 按照性别分组。分别查询男、女同学的平均分        SELECT sex , AVG(math) FROM student GROUP BY sex;                -- 按照性别分组。分别查询男、女同学的平均分,人数                SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;                --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;                --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;                SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</code></pre><p>​<br>    4. 分页查询<br>        1. 语法：limit 开始的索引,每页查询的条数;<br>        2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数<br>            – 每页显示3条记录<br>            SELECT * FROM student LIMIT 0,3; – 第1页</p><pre><code>        SELECT * FROM student LIMIT 3,3; -- 第2页                SELECT * FROM student LIMIT 6,3; -- 第3页    3. limit 是一个MySQL&quot;方言&quot;</code></pre><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><pre><code>* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    * 分类：    1. 主键约束：primary key    2. 非空约束：not null    3. 唯一约束：unique    4. 外键约束：foreign key* 非空约束：not null，某一列的值不能为null    1. 创建表时添加约束        CREATE TABLE stu(            id INT,            NAME VARCHAR(20) NOT NULL -- name为非空        );    2. 创建表完后，添加非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;    3. 删除name的非空约束        ALTER TABLE stu MODIFY NAME VARCHAR(20);* 唯一约束：unique，某一列的值不能重复    1. 注意：        * 唯一约束可以有NULL值，但是只能有一条记录为null    2. 在创建表时，添加唯一约束        CREATE TABLE stu(            id INT,            phone_number VARCHAR(20) UNIQUE -- 手机号        );    3. 删除唯一约束        ALTER TABLE stu DROP INDEX phone_number;    4. 在表创建完后，添加唯一约束        ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。    1. 注意：        1. 含义：非空且唯一        2. 一张表只能有一个字段为主键        3. 主键就是表中记录的唯一标识    2. 在创建表时，添加主键约束        create table stu(            id int primary key,-- 给id添加主键约束            name varchar(20)        );    3. 删除主键        -- 错误 alter table stu modify id int ;        ALTER TABLE stu DROP PRIMARY KEY;    4. 创建完表后，添加主键        ALTER TABLE stu MODIFY id INT PRIMARY KEY;    5. 自动增长：        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长        2. 在创建表时，添加主键约束，并且完成主键自增长        create table stu(            id int primary key auto_increment,-- 给id添加主键约束            name varchar(20)        );</code></pre><p>​<br>​            3. 删除自动增长<br>​            ALTER TABLE stu MODIFY id INT;<br>​            4. 添加自动增长<br>​            ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</p><pre><code>* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。    1. 在创建表时，可以添加外键        * 语法：            create table 表名(                ....                外键列                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)            );    2. 删除外键        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;    3. 创建表之后，添加外键        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</code></pre><p>​<br>​        4. 级联操作<br>​            1. 添加级联操作<br>​                语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称<br>​                        FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;<br>​            2. 分类：<br>​                1. 级联更新：ON UPDATE CASCADE<br>​                2. 级联删除：ON DELETE CASCADE </p><h1 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h1><pre><code>1. 多表之间的关系    1. 分类：        1. 一对一(了解)：            * 如：人和身份证            * 分析：一个人只有一个身份证，一个身份证只能对应一个人        2. 一对多(多对一)：            * 如：部门和员工            * 分析：一个部门有多个员工，一个员工只能对应一个部门        3. 多对多：            * 如：学生和课程            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择    2. 实现关系：        1. 一对多(多对一)：            * 如：部门和员工            * 实现方式：在多的一方建立外键，指向一的一方的主键。        2. 多对多：            * 如：学生和课程            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键        3. 一对一(了解)：            * 如：人和身份证            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</code></pre><p>​        </p><pre><code>2. 数据库设计的范式    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 分类：        1. 第一范式（1NF）：每一列都是不可分割的原子数据项        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）            * 几个概念：                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称） --&gt; 分数                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称） -- &gt; 姓名                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                    例如：学号--&gt;系名，系名--&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                    例如：该表中码为：（学号，课程名称）                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性                            3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre><h1 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h1><pre><code>1. 命令行：    * 语法：        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径        * 还原：            1. 登录数据库            2. 创建数据库            3. 使用数据库            4. 执行文件。source 文件路径</code></pre><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><pre><code>* 查询语法：    select        列名列表    from        表名列表    where....* 准备sql    # 创建部门表    CREATE TABLE dept(        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(20)    );    INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);    # 创建员工表    CREATE TABLE emp (        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1), -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dept_id INT,        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)    );    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);* 笛卡尔积：    * 有两个集合A,B .取这两个集合的所有组成情况。    * 要完成多表查询，需要消除无用的数据* 多表查询的分类：    1. 内连接查询：        1. 隐式内连接：使用where条件消除无用数据            * 例子：            -- 查询所有员工信息和对应的部门信息            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;                        -- 查询员工表的名称，性别。部门表的名称            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;                        SELECT                 t1.name, -- 员工表的姓名                t1.gender,-- 员工表的性别                t2.name -- 部门表的名称            FROM                emp t1,                dept t2            WHERE                 t1.`dept_id` = t2.`id`;</code></pre><p>​<br>​            2. 显式内连接：<br>​                * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件<br>​                * 例如：<br>​                    * SELECT * FROM emp INNER JOIN dept ON emp.<code>dept_id</code> = dept.<code>id</code>;<br>​                    * SELECT * FROM emp JOIN dept ON emp.<code>dept_id</code> = dept.<code>id</code>;<br>​<br>​            3. 内连接查询：<br>​                1. 从哪些表中查询数据<br>​                2. 条件是什么<br>​                3. 查询哪些字段<br>​        2. 外链接查询：<br>​            1. 左外连接：<br>​                * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；<br>​                * 查询的是左表所有数据以及其交集部分。<br>​                * 例子：<br>​                    – 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称<br>​                    SELECT     t1.*,t2.<code>name</code> FROM emp t1 LEFT JOIN dept t2 ON t1.<code>dept_id</code> = t2.<code>id</code>;<br>​            2. 右外连接：<br>​                * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；<br>​                * 查询的是右表所有数据以及其交集部分。<br>​                * 例子：<br>​                    SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.<code>dept_id</code> = t2.<code>id</code>;<br>​        3. 子查询：<br>​            * 概念：查询中嵌套查询，称嵌套查询为子查询。<br>​                – 查询工资最高的员工信息<br>​                – 1 查询最高的工资是多少 9000<br>​                SELECT MAX(salary) FROM emp;<br>​<br>​                – 2 查询员工信息，并且工资等于9000的<br>​                SELECT * FROM emp WHERE emp.<code>salary</code> = 9000;<br>​<br>​                – 一条sql就完成这个操作。子查询<br>​                SELECT * FROM emp WHERE emp.<code>salary</code> = (SELECT MAX(salary) FROM emp);<br>​<br>            * 子查询不同情况<br>                1. 子查询的结果是单行单列的：<br>                    * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =<br>                    *<br>                    – 查询员工工资小于平均工资的人<br>                    SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);<br>                2. 子查询的结果是多行单列的：<br>                    * 子查询可以作为条件，使用运算符in来判断<br>                    – 查询’财务部’和’市场部’所有的员工信息<br>                    SELECT id FROM dept WHERE NAME = ‘财务部’ OR NAME = ‘市场部’;<br>                    SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;<br>                    – 子查询<br>                    SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = ‘财务部’ OR NAME = ‘市场部’);</p><pre><code>            3. 子查询的结果是多行多列的：                * 子查询可以作为一张虚拟表参与查询                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息                -- 子查询                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2                WHERE t1.id = t2.dept_id;                                -- 普通内连接                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;</code></pre><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><pre><code>1. 事务的基本介绍    1. 概念：        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。            2. 操作：        1. 开启事务： start transaction;        2. 回滚：rollback;        3. 提交：commit;        3. MySQL数据库中事务默认自动提交                * 事务提交的两种方式：            * 自动提交：                * mysql就是自动提交的                * 一条DML(增删改)语句会自动提交一次事务。            * 手动提交：                * Oracle 数据库默认是手动提交事务                * 需要先开启事务，再提交        * 修改事务的默认提交方式：            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交            * 修改默认提交方式： set @@autocommit = 0;2. 事务的四大特征：    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。    3. 隔离性：多个事务之间。相互独立。    4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解）    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。    * 存在问题：        1. 脏读：一个事务，读取到另一个事务中没有提交的数据        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。    * 隔离级别：        1. read uncommitted：读未提交            * 产生的问题：脏读、不可重复读、幻读        2. read committed：读已提交 （Oracle）            * 产生的问题：不可重复读、幻读        3. repeatable read：可重复读 （MySQL默认）            * 产生的问题：幻读        4. serializable：串行化            * 可以解决所有的问题        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低        * 数据库查询隔离级别：            * select @@tx_isolation;        * 数据库设置隔离级别：            * set global transaction isolation level  级别字符串;    * 演示：        set global transaction isolation level read uncommitted;        start transaction;        -- 转账操作        update account set balance = balance - 500 where id = 1;        update account set balance = balance + 500 where id = 2;</code></pre><h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><pre><code>* SQL分类：    1. DDL：操作数据库和表    2. DML：增删改表中数据    3. DQL：查询表中数据    4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权    1. 管理用户        1. 添加用户：            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;        2. 删除用户：            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;        3. 修改用户密码：                        UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;                        SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);            SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);            * mysql中忘记了root用户的密码？                1. cmd -- &gt; net stop mysql 停止mysql服务                    * 需要管理员运行该cmd                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功                4. use mysql;                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;                6. 关闭两个窗口                7. 打开任务管理器，手动结束mysqld.exe 的进程                8. 启动mysql服务                9. 使用新密码登录。        4. 查询用户：            -- 1. 切换到mysql数据库            USE myql;            -- 2. 查询user表            SELECT * FROM USER;                        * 通配符： % 表示可以在任意主机使用用户登录数据库    2. 权限管理：        1. 查询权限：            -- 查询权限            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;            SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;        2. 授予权限：            -- 授予权限            grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;            -- 给张三用户授予所有权限，在任意数据库任意表上                        GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;        3. 撤销权限：            -- 撤销权限：            revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;            REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据库的基本概念&quot;&gt;&lt;a href=&quot;#数据库的基本概念&quot; class=&quot;headerlink&quot; title=&quot;数据库的基本概念&quot;&gt;&lt;/a&gt;数据库的基本概念&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1. 数据库的英文单词： DataBase 简称 ： DB 
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="JavaWeb相关" scheme="http://example.com/categories/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="JavaWeb相关" scheme="http://example.com/tags/JavaWeb%E7%9B%B8%E5%85%B3/"/>
    
    <category term="MYSQL" scheme="http://example.com/tags/MYSQL/"/>
    
  </entry>
  
</feed>
